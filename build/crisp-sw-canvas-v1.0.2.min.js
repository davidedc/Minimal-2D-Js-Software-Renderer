/* CrispSwCanvas v1.0.2 */
class Transform2D{constructor(t){if(t&&Array.isArray(t)&&6===t.length){for(let e=0;e<6;e++)if("number"!=typeof t[e]||!isFinite(t[e]))throw new Error(`Transform2D component ${e} must be a finite number`);this.a=t[0],this.b=t[1],this.c=t[2],this.d=t[3],this.e=t[4],this.f=t[5]}else{if(t&&void 0!==t.length)throw new Error("Transform2D initialization array must have exactly 6 elements");this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0}Object.freeze(this)}static translation(t,e){return new Transform2D([1,0,0,1,t,e])}static scaling(t,e){return new Transform2D([t,0,0,e,0,0])}static rotation(t){const e=Math.cos(t),r=Math.sin(t);return new Transform2D([e,r,-r,e,0,0])}multiply(t){if(!(t instanceof Transform2D))throw new Error("Can only multiply with another Transform2D");return new Transform2D([this.a*t.a+this.c*t.b,this.b*t.a+this.d*t.b,this.a*t.c+this.c*t.d,this.b*t.c+this.d*t.d,this.a*t.e+this.c*t.f+this.e,this.b*t.e+this.d*t.f+this.f])}translate(t,e){const r=Transform2D.translation(t,e);return this.multiply(r)}scale(t,e){const r=Transform2D.scaling(t,e);return this.multiply(r)}rotate(t){const e=Transform2D.rotation(t);return this.multiply(e)}invert(){const t=this.a*this.d-this.b*this.c;if(Math.abs(t)<1e-10)throw new Error("Transform2D matrix is not invertible (determinant â‰ˆ 0)");return new Transform2D([this.d/t,-this.b/t,-this.c/t,this.a/t,(this.c*this.f-this.d*this.e)/t,(this.b*this.e-this.a*this.f)/t])}transformPoint(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Point must have numeric x and y properties");return{x:this.a*t.x+this.c*t.y+this.e,y:this.b*t.x+this.d*t.y+this.f}}transformPoints(t){return t.map((t=>this.transformPoint(t)))}toArray(){return[this.a,this.b,this.c,this.d,this.e,this.f]}get isIdentity(){return 1===this.a&&0===this.b&&0===this.c&&1===this.d&&0===this.e&&0===this.f}get determinant(){return this.a*this.d-this.b*this.c}get rotationAngle(){return Math.atan2(-this.c,this.a)}get scaleX(){return Math.sqrt(this.a*this.a+this.b*this.b)}get scaleY(){return Math.sqrt(this.c*this.c+this.d*this.d)}getScaledLineWidth(t){return t*Math.max(Math.sqrt(this.scaleX*this.scaleY),1e-4)}equals(t,e=1e-10){return t instanceof Transform2D&&Math.abs(this.a-t.a)<e&&Math.abs(this.b-t.b)<e&&Math.abs(this.c-t.c)<e&&Math.abs(this.d-t.d)<e&&Math.abs(this.e-t.e)<e&&Math.abs(this.f-t.f)<e}toString(){return`Transform2D([${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f}])`}}class Color{constructor(t,e,r,i=255,n=!1){if(t<0||t>255||e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("Color components must be in range 0-255");if(n)this._r=Math.round(t),this._g=Math.round(e),this._b=Math.round(r),this._a=Math.round(i);else{const n=i/255;this._r=Math.round(t*n),this._g=Math.round(e*n),this._b=Math.round(r*n),this._a=Math.round(i)}}get premultipliedR(){return this._r}get premultipliedG(){return this._g}get premultipliedB(){return this._b}get premultipliedA(){return this._a}get r(){return 0===this._a?0:255===this._a?this._r:Math.round(255*this._r/this._a)}get g(){return 0===this._a?0:255===this._a?this._g:Math.round(255*this._g/this._a)}get b(){return 0===this._a?0:255===this._a?this._b:Math.round(255*this._b/this._a)}get a(){return this._a}toRGBA(){return[this.r,this.g,this.b,this.a]}toPremultipliedRGBA(){return[this._r,this._g,this._b,this._a]}get normalizedAlpha(){return this._a/255}get isTransparent(){return 0===this._a}get isOpaque(){return 255===this._a}withGlobalAlpha(t){if(t<0||t>1)throw new Error("Global alpha must be in range 0-1");const e=this.r,r=this.g,i=this.b,n=this.a,s=Math.round(n*t);return new Color(e,r,i,s,!1)}blendOver(t){if(255===this._a)return this;if(0===this._a)return t;const e=1-this.normalizedAlpha,r=Math.round(this._r+t._r*e),i=Math.round(this._g+t._g*e),n=Math.round(this._b+t._b*e),s=Math.round(this._a+t._a*e);return new Color(r,i,n,s,!0)}toBMP(){return{r:this.r,g:this.g,b:this.b}}toCSS(){const t=(this.a/255).toFixed(3).replace(/\.?0+$/,"");return`rgba(${this.r}, ${this.g}, ${this.b}, ${t})`}toString(){return`Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`}equals(t){return t instanceof Color&&this._r===t._r&&this._g===t._g&&this._b===t._b&&this._a===t._a}}Color.transparent=new Color(0,0,0,0),Color.black=new Color(0,0,0,255),Color.fromCSS=function(t,e){if(!t||"string"!=typeof t)throw new Error("Invalid color format: must be a string");const r=e.parse(t);return new Color(r.r,r.g,r.b,r.a,!1)};class ColorParser{constructor(){this._cache=new Map,this._namedColors={black:{r:0,g:0,b:0},silver:{r:192,g:192,b:192},gray:{r:128,g:128,b:128},white:{r:255,g:255,b:255},maroon:{r:128,g:0,b:0},red:{r:255,g:0,b:0},purple:{r:128,g:0,b:128},fuchsia:{r:255,g:0,b:255},green:{r:0,g:128,b:0},lime:{r:0,g:255,b:0},olive:{r:128,g:128,b:0},yellow:{r:255,g:255,b:0},navy:{r:0,g:0,b:128},blue:{r:0,g:0,b:255},teal:{r:0,g:128,b:128},aqua:{r:0,g:255,b:255},aliceblue:{r:240,g:248,b:255},antiquewhite:{r:250,g:235,b:215},aquamarine:{r:127,g:255,b:212},azure:{r:240,g:255,b:255},beige:{r:245,g:245,b:220},bisque:{r:255,g:228,b:196},blanchedalmond:{r:255,g:235,b:205},blueviolet:{r:138,g:43,b:226},brown:{r:165,g:42,b:42},burlywood:{r:222,g:184,b:135},cadetblue:{r:95,g:158,b:160},chartreuse:{r:127,g:255,b:0},chocolate:{r:210,g:105,b:30},coral:{r:255,g:127,b:80},cornflowerblue:{r:100,g:149,b:237},cornsilk:{r:255,g:248,b:220},crimson:{r:220,g:20,b:60},cyan:{r:0,g:255,b:255},darkblue:{r:0,g:0,b:139},darkcyan:{r:0,g:139,b:139},darkgoldenrod:{r:184,g:134,b:11},darkgray:{r:169,g:169,b:169},darkgreen:{r:0,g:100,b:0},darkgrey:{r:169,g:169,b:169},darkkhaki:{r:189,g:183,b:107},darkmagenta:{r:139,g:0,b:139},darkolivegreen:{r:85,g:107,b:47},darkorange:{r:255,g:140,b:0},darkorchid:{r:153,g:50,b:204},darkred:{r:139,g:0,b:0},darksalmon:{r:233,g:150,b:122},darkseagreen:{r:143,g:188,b:143},darkslateblue:{r:72,g:61,b:139},darkslategray:{r:47,g:79,b:79},darkslategrey:{r:47,g:79,b:79},darkturquoise:{r:0,g:206,b:209},darkviolet:{r:148,g:0,b:211},deeppink:{r:255,g:20,b:147},deepskyblue:{r:0,g:191,b:255},dimgray:{r:105,g:105,b:105},dimgrey:{r:105,g:105,b:105},dodgerblue:{r:30,g:144,b:255},firebrick:{r:178,g:34,b:34},floralwhite:{r:255,g:250,b:240},forestgreen:{r:34,g:139,b:34},gainsboro:{r:220,g:220,b:220},ghostwhite:{r:248,g:248,b:255},gold:{r:255,g:215,b:0},goldenrod:{r:218,g:165,b:32},grey:{r:128,g:128,b:128},greenyellow:{r:173,g:255,b:47},honeydew:{r:240,g:255,b:240},hotpink:{r:255,g:105,b:180},indianred:{r:205,g:92,b:92},indigo:{r:75,g:0,b:130},ivory:{r:255,g:255,b:240},khaki:{r:240,g:230,b:140},lavender:{r:230,g:230,b:250},lavenderblush:{r:255,g:240,b:245},lawngreen:{r:124,g:252,b:0},lemonchiffon:{r:255,g:250,b:205},lightblue:{r:173,g:216,b:230},lightcoral:{r:240,g:128,b:128},lightcyan:{r:224,g:255,b:255},lightgoldenrodyellow:{r:250,g:250,b:210},lightgray:{r:211,g:211,b:211},lightgreen:{r:144,g:238,b:144},lightgrey:{r:211,g:211,b:211},lightpink:{r:255,g:182,b:193},lightsalmon:{r:255,g:160,b:122},lightseagreen:{r:32,g:178,b:170},lightskyblue:{r:135,g:206,b:250},lightslategray:{r:119,g:136,b:153},lightslategrey:{r:119,g:136,b:153},lightsteelblue:{r:176,g:196,b:222},lightyellow:{r:255,g:255,b:224},limegreen:{r:50,g:205,b:50},linen:{r:250,g:240,b:230},magenta:{r:255,g:0,b:255},mediumaquamarine:{r:102,g:205,b:170},mediumblue:{r:0,g:0,b:205},mediumorchid:{r:186,g:85,b:211},mediumpurple:{r:147,g:112,b:219},mediumseagreen:{r:60,g:179,b:113},mediumslateblue:{r:123,g:104,b:238},mediumspringgreen:{r:0,g:250,b:154},mediumturquoise:{r:72,g:209,b:204},mediumvioletred:{r:199,g:21,b:133},midnightblue:{r:25,g:25,b:112},mintcream:{r:245,g:255,b:250},mistyrose:{r:255,g:228,b:225},moccasin:{r:255,g:228,b:181},navajowhite:{r:255,g:222,b:173},oldlace:{r:253,g:245,b:230},olivedrab:{r:107,g:142,b:35},orange:{r:255,g:165,b:0},orangered:{r:255,g:69,b:0},orchid:{r:218,g:112,b:214},palegoldenrod:{r:238,g:232,b:170},palegreen:{r:152,g:251,b:152},paleturquoise:{r:175,g:238,b:238},palevioletred:{r:219,g:112,b:147},papayawhip:{r:255,g:239,b:213},peachpuff:{r:255,g:218,b:185},peru:{r:205,g:133,b:63},pink:{r:255,g:192,b:203},plum:{r:221,g:160,b:221},powderblue:{r:176,g:224,b:230},rebeccapurple:{r:102,g:51,b:153},rosybrown:{r:188,g:143,b:143},royalblue:{r:65,g:105,b:225},saddlebrown:{r:139,g:69,b:19},salmon:{r:250,g:128,b:114},sandybrown:{r:244,g:164,b:96},seagreen:{r:46,g:139,b:87},seashell:{r:255,g:245,b:238},sienna:{r:160,g:82,b:45},skyblue:{r:135,g:206,b:235},slateblue:{r:106,g:90,b:205},slategray:{r:112,g:128,b:144},slategrey:{r:112,g:128,b:144},snow:{r:255,g:250,b:250},springgreen:{r:0,g:255,b:127},steelblue:{r:70,g:130,b:180},tan:{r:210,g:180,b:140},thistle:{r:216,g:191,b:216},tomato:{r:255,g:99,b:71},turquoise:{r:64,g:224,b:208},violet:{r:238,g:130,b:238},wheat:{r:245,g:222,b:179},whitesmoke:{r:245,g:245,b:245},yellowgreen:{r:154,g:205,b:50}}}parse(t){if(this._cache.has(t))return this._cache.get(t);let e;if("string"!=typeof t)e={r:0,g:0,b:0,a:255};else{const r=t.trim().toLowerCase();if(r.startsWith("#"))e=this._parseHex(r);else if(r.startsWith("rgb"))e=this._parseRGB(r);else if(this._namedColors[r]){const t=this._namedColors[r];e={r:t.r,g:t.g,b:t.b,a:255}}else e={r:0,g:0,b:0,a:255}}return this._cache.set(t,e),e}_parseHex(t){if(3===(t=t.substring(1)).length&&(t=t.split("").map((t=>t+t)).join("")),6===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:255}}if(8===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:parseInt(t.substring(6,8),16)}}return{r:0,g:0,b:0,a:255}}_parseRGB(t){const e=t.match(/rgba?\s*\(\s*([^)]+)\s*\)/);if(!e)return{r:0,g:0,b:0,a:255};const r=e[1].split(",").map((t=>t.trim()));if(r.length<3)return{r:0,g:0,b:0,a:255};const i=Math.max(0,Math.min(255,parseInt(r[0])||0)),n=Math.max(0,Math.min(255,parseInt(r[1])||0)),s=Math.max(0,Math.min(255,parseInt(r[2])||0));let a=255;if(r.length>=4){const t=parseFloat(r[3]);isNaN(t)||(a=Math.max(0,Math.min(255,Math.round(255*t))))}return{r:i,g:n,b:s,a:a}}clearCache(){this._cache.clear()}}class ContextState{constructor(t,e,r,i,n,s,a,o){this.canvasWidth=t,this.canvasHeight=e,this.lineWidth=r||1,this.transform=i||new Transform2D,this.strokeColor=n||Color.black,this.fillColor=s||Color.black,this.globalAlpha=a||1,this.clippingMask=o||new Uint8Array(Math.ceil(t*e/8)).fill(255)}clone(){const t=new Uint8Array(this.clippingMask);return new ContextState(this.canvasWidth,this.canvasHeight,this.lineWidth,this.transform,this.strokeColor,this.fillColor,this.globalAlpha,t)}}function pointInPolygon(t,e,r){let i=!1;for(let n=0,s=r.length-1;n<r.length;s=n++){const a=r[n].x,o=r[n].y,h=r[s].x,l=r[s].y;o>e!=l>e&&t<(h-a)*(e-o)/(l-o)+a&&(i=!i)}return i}function extendLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const a=i/s,o=n/s;return{start:{x:t.x-a*r,y:t.y-o*r},end:{x:e.x+a*r,y:e.y+o*r}}}function shortenLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const a=i/s,o=n/s;return{start:{x:t.x+a*r,y:t.y+o*r},end:{x:e.x-a*r,y:e.y-o*r}}}function alignToPixelBoundary(t){return{x:Math.round(t.x)+.5,y:Math.round(t.y)+.5}}function toIntegerPoint(t){return{x:Math.round(t.x),y:Math.round(t.y)}}function roundCornerOfRectangularGeometry(t){const{x:e,y:r,w:i,h:n}=t;return{x:Math.round(e),y:Math.round(r),w:i,h:n}}function roundCornerOfRectangularGeometryWithWarning(t){const e=roundCornerOfRectangularGeometry(t);return e.x===t.x&&e.y===t.y||console.warn("Rectangular geometry is not at a grid point, rounding to nearest grid point. When this happens, HTML5 Canvas would do a non-crisp fill, while the SW renderer will do a crisp fill."),e}function getRectangularFillGeometry(t,e,r,i){return{x:t-r/2,y:e-i/2,w:r,h:i}}var getRectangularStrokeGeometry=getRectangularFillGeometry;function checkBasicConditionsForCrispRendering(t,e,r,i,n){Number.isInteger(r)&&Number.isInteger(i)||console.warn("Width and height must be integers for crisp rendering"),Number.isInteger(n)||console.warn("Stroke width must be an integer for crisp rendering"),Number.isInteger(t)||t%1==.5||console.warn("Center X must be an integer or *.5 for crisp rendering"),Number.isInteger(e)||e%1==.5||console.warn("Center Y must be an integer or *.5 for crisp rendering ")}class PixelSet{constructor(t){this.pixels=new Map,this.pixelRenderer=t}addPixel(t,e,r,i,n,s){const a=`${Math.round(t)},${Math.round(e)}`;this.pixels.set(a,{x:Math.round(t),y:Math.round(e),r:r,g:i,b:n,a:s})}paint(){for(const t of this.pixels.values())this.pixelRenderer.setPixel(t.x,t.y,t.r,t.g,t.b,t.a)}}class ScanlineSpans{constructor(){this.spans=new Map}addSpan(t,e,r){if(e>r&&([e,r]=[r,e]),this.spans.has(t)){const i=this.spans.get(t);i[0]=Math.min(i[0],e),i[1]=Math.max(i[1],r)}else this.spans.set(t,[e,r])}addPixel(t,e){if(e=Math.round(e),t=Math.round(t),this.spans.has(e)){const r=this.spans.get(e);r[0]=Math.min(r[0],t),r[1]=Math.max(r[1],t)}else this.spans.set(e,[t,t])}addToPixelSet(t,e,r,i,n){for(const[s,[a,o]]of this.spans)for(let h=a;h<=o;h++)t.addPixel(h,s,e,r,i,n)}}const ANGLE_TOLERANCE=.001;function isNearMultipleOf90Degrees(t){const e=(t%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(e)<.001||Math.abs(e-Math.PI/2)<.001||Math.abs(e-Math.PI)<.001||Math.abs(e-3*Math.PI/2)<.001||Math.abs(e-2*Math.PI)<.001}function getRotatedDimensionsIfTheCase(t,e,r){const i=(r%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(i-Math.PI/2)<.001||Math.abs(i-3*Math.PI/2)<.001?{adjustedWidth:e,adjustedHeight:t}:{adjustedWidth:t,adjustedHeight:e}}class SWRendererPixel{constructor(t,e,r,i,n){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,n?(this.context=n,this.tempClippingMask=n.tempClippingMask):this.context={globalAlpha:1}}clipPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=e*r+t,n=i>>3,s=7&i;this.tempClippingMask[n]|=1<<7-s}setPixel(t,e,r,i,n,s){t|=0,e|=0;const a=this.width,o=this.context.globalAlpha;if(t<0||t>=a||e<0||e>=this.height)return;const h=e*a+t,l=4*h;if(this.context.currentState){const t=this.context.currentState.clippingMask,e=h>>3,r=7&h;if(0===t[e])return;if(!(t[e]&1<<7-r))return}let c=0;if(255===s&&o>=1)return c=255<<24|n<<16|i<<8|r,void(this.frameBufferUint32View[h]=c);const f=s/255*o,d=this.frameBufferUint8ClampedView[l+3]/255*(1-f),u=f+d;if(u<=0)return;const g=1/u;this.frameBufferUint8ClampedView[l]=(r*f+this.frameBufferUint8ClampedView[l]*d)*g,this.frameBufferUint8ClampedView[l+1]=(i*f+this.frameBufferUint8ClampedView[l+1]*d)*g,this.frameBufferUint8ClampedView[l+2]=(n*f+this.frameBufferUint8ClampedView[l+2]*d)*g,this.frameBufferUint8ClampedView[l+3]=255*u}clearPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=4*(e*r+t);this.frameBufferUint8ClampedView[i]=0,this.frameBufferUint8ClampedView[i+1]=0,this.frameBufferUint8ClampedView[i+2]=0,this.frameBufferUint8ClampedView[i+3]=0}setPixelRuns(t,e,r,i,n){const s=this.width,a=this.height,o=this.frameBufferUint8ClampedView,h=this.frameBufferUint32View,l=this.context.globalAlpha,c=this.context.currentState,f=c?this.context.currentState.clippingMask:null,d=255===n&&l>=1;let u=0;d&&(u=255<<24|i<<16|r<<8|e);const g=d?1:n/255*l,x=d?0:1-g;if(!(g<=0))for(let n=0;n<t.length;n+=3){let l=0|t[n];const p=0|t[n+1];let M=0|t[n+2];if(p<0||p>=a)continue;if(l<0&&(M+=l,l=0,M<=0))continue;if(l+M>s&&(M=s-l,M<=0))continue;let m=p*s+l,b=4*m;if(d)for(let t=0;t<M;t++,m++,b+=4){if(c){const e=m>>3;if(0===f[e]){const e=8-(7&m),r=Math.min(e,M-t);t+=r-1,m+=r-1,b+=4*(r-1);continue}const r=7&m;if(!(f[e]&1<<7-r))continue}h[m]=u}else for(let t=0;t<M;t++,m++,b+=4){if(c){const e=m>>3;if(0===f[e]){const e=8-(7&m),r=Math.min(e,M-t);t+=r-1,m+=r-1,b+=4*(r-1);continue}const r=7&m;if(!(f[e]&1<<7-r))continue}const n=o[b+3]/255*x,s=g+n;if(s<=0)continue;const a=1/s;o[b]=(e*g+o[b]*n)*a,o[b+1]=(r*g+o[b+1]*n)*a,o[b+2]=(i*g+o[b+2]*n)*a,o[b+3]=255*s}}}setPixelFillAndStrokeRuns(t,e,r,i,n,s,a,o,h,l){t+=2;const c=this.width,f=this.height,d=this.frameBufferUint8ClampedView,u=this.frameBufferUint32View,g=this.context.globalAlpha,x=this.context.currentState,p=x?this.context.currentState.clippingMask:null,M=s/255*g,m=1-M,b=M>=1;let w=0;b&&(w=255<<24|n<<16|i<<8|r);const y=l/255*g,R=1-y,C=y>=1;let S=0;if(C&&(S=255<<24|h<<16|o<<8|a),M<=0&&y<=0)return;let P=t;for(let t=0;t<e.length;t+=6){if(P<0||P>=f){P++;continue}let s=-1!==e[t]?0|e[t]:-1,l=-1!==e[t+1]?0|e[t+1]:-1,g=-1!==e[t+2]?0|e[t+2]:-1,k=-1!==e[t+3]?0|e[t+3]:-1,_=-1!==e[t+4]?0|e[t+4]:-1,A=-1!==e[t+5]?0|e[t+5]:-1;const B=-1!==s&&l>0&&M>0,I=-1!==g&&k>0&&y>0,v=-1!==_&&A>0&&y>0;if(B||I||v){B&&(s<0&&(l+=s,s=0),s+l>c&&(l=c-s),l<=0&&(s=-1,l=0)),I&&(g<0&&(k+=g,g=0),g+k>c&&(k=c-g),k<=0&&(g=-1,k=0)),v&&(_<0&&(A+=_,_=0),_+A>c&&(A=c-_),A<=0&&(_=-1,A=0));for(let t=0;t<3;t++){let e,f,W,U,T,V,q,O,L=0;if(0===t){if(!B||-1===s||l<=0)continue;e=s,f=l,W=r,U=i,T=n,V=M,q=m,O=b,O&&(L=w)}else if(1===t){if(!I||-1===g||k<=0)continue;e=g,f=k,W=a,U=o,T=h,V=y,q=R,O=C,O&&(L=S)}else{if(!v||-1===_||A<=0)continue;e=_,f=A,W=a,U=o,T=h,V=y,q=R,O=C,O&&(L=S)}let D=P*c+e,F=4*D;for(let t=0;t<f;t++,D++,F+=4){if(x){const e=D>>3;if(e>=p.length)continue;if(0===p[e]){const e=8-(7&D),r=Math.min(e,f-t);t+=r-1,D+=r-1,F+=4*(r-1);continue}const r=7&D;if(!(p[e]&1<<7-r))continue}if(O)u[D]=L;else{const t=d[F+3]/255*q,e=V+t;if(e<=1e-5)continue;const r=1/e;d[F]=(W*V+d[F]*t)*r,d[F+1]=(U*V+d[F+1]*t)*r,d[F+2]=(T*V+d[F+2]*t)*r,d[F+3]=255*e}}}P++}else P++}}}class SWRendererLine{constructor(t){this.pixelRenderer=t,this._corners=[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],this._edges=[{p1:this._corners[0],p2:this._corners[1],invDeltaY:0,deltaX:0},{p1:this._corners[1],p2:this._corners[2],invDeltaY:0,deltaX:0},{p1:this._corners[2],p2:this._corners[3],invDeltaY:0,deltaX:0},{p1:this._corners[3],p2:this._corners[0],invDeltaY:0,deltaX:0}],this._intersections=new Array(8),this._pixelRuns=[]}drawLine(t){const{start:{x:e,y:r},end:{x:i,y:n},thickness:s,color:{r:a,g:o,b:h,a:l}}=t;if(1!==s)return void this.drawLineThick(e,r,i,n,s,a,o,h,l);let c=Math.floor(e),f=Math.floor(r),d=Math.floor(i),u=Math.floor(n);c===d&&(u>f?u--:f--),f===u&&(d>c?d--:c--);const g=this.pixelRenderer.context.globalAlpha;if(0===l||g<=0)return;const x=Math.abs(d-c),p=Math.abs(u-f);return 0===x?this._drawLine1px_vertical(c,f,u,a,o,h,l):0===p?this._drawLine1px_horizontal(c,d,f,a,o,h,l):x===p?this._drawLine1px_45degrees(c,f,d,u,a,o,h,l):this._drawLine1px_genericOrientations(c,f,d,u,x,p,a,o,h,l)}drawLine1px(t,e,r,i,n,s,a,o){t=Math.floor(t),e=Math.floor(e),r=Math.floor(r),i=Math.floor(i);const h=Math.abs(r-t),l=Math.abs(i-e);return 0===h?this._drawLine1px_vertical(t,e,i,n,s,a,o):0===l?this._drawLine1px_horizontal(t,r,e,n,s,a,o):h===l?this._drawLine1px_45degrees(t,e,r,i,n,s,a,o):this._drawLine1px_genericOrientations(t,e,r,i,h,l,n,s,a,o)}_drawLine1px_horizontal(t,e,r,i,n,s,a){const o=this.pixelRenderer.frameBufferUint8ClampedView,h=this.pixelRenderer.frameBufferUint32View,l=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(r<0||r>=c)return;const g=255===a&&u>=1;let x=0;g&&(x=255<<24|s<<16|n<<8|i);const p=g?1:a/255*u,M=g?0:1-p;if(t>e){let r=t;t=e,e=r}if(t<0&&(t=0),e>=l&&(e=l-1),t>e)return;const m=4*(r*l+t);for(let a=t;a<=e;a++){const e=m+4*(a-t),c=r*l+a;if(f){const t=c>>3,e=7&c;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(g)h[c]=x;else{const t=o[e+3]/255*M,r=p+t;if(r<=0)continue;const a=1/r;o[e]=(i*p+o[e]*t)*a,o[e+1]=(n*p+o[e+1]*t)*a,o[e+2]=(s*p+o[e+2]*t)*a,o[e+3]=255*r}}}_drawLine1px_vertical(t,e,r,i,n,s,a){const o=this.pixelRenderer.frameBufferUint8ClampedView,h=this.pixelRenderer.frameBufferUint32View,l=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(t<0||t>=l)return;const g=255===a&&u>=1;let x=0;g&&(x=255<<24|s<<16|n<<8|i);const p=g?1:a/255*u,M=g?0:1-p;if(e>r){let t=e;e=r,r=t}if(e<0&&(e=0),r>=c&&(r=c-1),!(e>r))for(let a=e;a<=r;a++){const e=4*(a*l+t),r=a*l+t;if(f){const t=r>>3,e=7&r;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(g)h[r]=x;else{const t=o[e+3]/255*M,r=p+t;if(r<=0)continue;const a=1/r;o[e]=(i*p+o[e]*t)*a,o[e+1]=(n*p+o[e+1]*t)*a,o[e+2]=(s*p+o[e+2]*t)*a,o[e+3]=255*r}}}_drawLine1px_45degrees(t,e,r,i,n,s,a,o){const h=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,c=this.pixelRenderer.width,f=this.pixelRenderer.height,d=this.pixelRenderer.context.currentState,u=d?this.pixelRenderer.context.currentState.clippingMask:null,g=this.pixelRenderer.context.globalAlpha,x=255===o&&g>=1;let p=0;x&&(p=255<<24|a<<16|s<<8|n);const M=x?1:o/255*g,m=x?0:1-M,b=t<r?1:-1,w=e<i?1:-1;let y=t,R=e;for(;!(y<0&&b<0||y>=c&&b>0||R<0&&w<0||R>=f&&w>0);){if(y>=0&&y<c&&R>=0&&R<f){const t=4*(R*c+y),e=R*c+y;let r=!0;if(d){const t=e>>3,i=7&e;!(t>=u.length||0===u[t])&&u[t]&1<<7-i||(r=!1)}if(r)if(x)l[e]=p;else{const e=h[t+3]/255*m,r=M+e;if(r>0){const i=1/r;h[t]=(n*M+h[t]*e)*i,h[t+1]=(s*M+h[t+1]*e)*i,h[t+2]=(a*M+h[t+2]*e)*i,h[t+3]=255*r}}}if(y===r&&R===i)break;y+=b,R+=w}}_drawLine1px_genericOrientations(t,e,r,i,n,s,a,o,h,l){const c=this.pixelRenderer.frameBufferUint8ClampedView,f=this.pixelRenderer.frameBufferUint32View,d=this.pixelRenderer.width,u=this.pixelRenderer.height,g=this.pixelRenderer.context.currentState,x=g?this.pixelRenderer.context.currentState.clippingMask:null,p=this.pixelRenderer.context.globalAlpha,M=255===l&&p>=1;let m=0;M&&(m=255<<24|h<<16|o<<8|a);const b=M?1:l/255*p,w=M?0:1-b,y=t<r?1:-1,R=e<i?1:-1;let C=n-s;for(;;){if(t>=0&&t<d&&e>=0&&e<u){const r=4*(e*d+t),i=e*d+t;let n=!0;if(g){const t=i>>3,e=7&i;!(t>=x.length||0===x[t])&&x[t]&1<<7-e||(n=!1)}if(n)if(M)f[i]=m;else{const t=c[r+3]/255*w,e=b+t;if(e>0){const i=1/e;c[r]=(a*b+c[r]*t)*i,c[r+1]=(o*b+c[r+1]*t)*i,c[r+2]=(h*b+c[r+2]*t)*i,c[r+3]=255*e}}}if(t===r&&e===i)break;const l=2*C;l>-s&&(C-=s,t+=y),l<n&&(C+=n,e+=R)}}drawLineThick(t,e,r,i,n,s,a,o,h){this._drawLineThickPolygonScan(t,e,r,i,n,s,a,o,h)}_drawLineThickBoundingBox(t,e,r,i,n,s,a,o,h){const l=(r-=.5)-(t-=.5),c=(i-=.5)-(e-=.5),f=Math.sqrt(l*l+c*c);if(0===f)return;const d=-c/f,u=l/f,g=n/2,x=[[t+d*g,e+u*g],[t-d*g,e-u*g],[r+d*g,i+u*g],[r-d*g,i-u*g]],p=Math.floor(Math.min(...x.map((t=>t[0])))),M=Math.ceil(Math.max(...x.map((t=>t[0])))),m=Math.floor(Math.min(...x.map((t=>t[1])))),b=Math.ceil(Math.max(...x.map((t=>t[1]))));for(let r=m;r<=b;r++)for(let i=p;i<=M;i++){const n=i-t,d=r-e,u=(n*l+d*c)/f,x=n-l/f*u,p=d-c/f*u,M=Math.sqrt(x*x+p*p);u>=0&&u<=f&&M<=g&&this.pixelRenderer.setPixel(i,r,s,a,o,h)}}_drawLineThickModifiedBresenham(t,e,r,i,n,s,a,o,h){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const l=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1;let u,g;const x=Math.sqrt(l*l+c*c);if(0===x){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,a,o,h);return}u=-c/x,g=l/x;const p=n/2;let M=l-c,m=t,b=e;for(;this._drawPerpendicularSegment(m,b,u,g,p,s,a,o,h),m!==r||b!==i;){const t=2*M;t>-c&&(M-=c,m+=f),t<l&&(M+=l,b+=d)}const w=(r-t)/x,y=(i-e)/x;this._drawSquareCap(t,e,u,g,p,-w,-y,s,a,o,h),this._drawSquareCap(r,i,u,g,p,w,y,s,a,o,h)}_drawPerpendicularSegment(t,e,r,i,n,s,a,o,h){const l=Math.ceil(n);this.pixelRenderer.setPixel(t,e,s,a,o,h);for(let c=1;c<=l;c++){const f=c/l*n,d=Math.round(t+r*f),u=Math.round(e+i*f),g=Math.round(t-r*f),x=Math.round(e-i*f);this.pixelRenderer.setPixel(d,u,s,a,o,h),this.pixelRenderer.setPixel(g,x,s,a,o,h)}}_drawSquareCap(t,e,r,i,n,s,a,o,h,l,c){const f=Math.ceil(n);for(let d=1;d<=f;d++){const u=d/f*n,g=Math.round(t+s*u),x=Math.round(e+a*u);this._drawPerpendicularSegment(g,x,r,i,n,o,h,l,c)}}_drawLineThickDistanceOptimized(t,e,r,i,n,s,a,o,h){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const l=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1,u=Math.sqrt((r-t)**2+(i-e)**2);if(0===u){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,a,o,h);return}const g=-(i-e)/u,x=(r-t)/u,p=Math.floor(n/2);let M=l-c,m=t,b=e;const w=[];for(;w.push({x:m,y:b}),m!==r||b!==i;){const t=2*M;t>-c&&(M-=c,m+=f),t<l&&(M+=l,b+=d)}for(const t of w)for(let e=-p;e<=p;e++){const r=Math.round(t.x+g*e),i=Math.round(t.y+x*e);this.pixelRenderer.setPixel(r,i,s,a,o,h)}const y=-(r-t)/u,R=-(i-e)/u;for(let r=1;r<=p;r++){const i=Math.round(t+y*r),n=Math.round(e+R*r);for(let t=-p;t<=p;t++){const e=Math.round(i+g*t),r=Math.round(n+x*t);this.pixelRenderer.setPixel(e,r,s,a,o,h)}}const C=(r-t)/u,S=(i-e)/u;for(let t=1;t<=p;t++){const e=Math.round(r+C*t),n=Math.round(i+S*t);for(let t=-p;t<=p;t++){const r=Math.round(e+g*t),i=Math.round(n+x*t);this.pixelRenderer.setPixel(r,i,s,a,o,h)}}}_drawLineThickParallelOffset(t,e,r,i,n,s,a,o,h){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const l=Math.sqrt((r-t)**2+(i-e)**2);if(0===l){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,a,o,h);return}const c=-(i-e)/l,f=(r-t)/l,d=(r-t)/l,u=(i-e)/l,g=n/2,x=Math.ceil(g);for(let n=-x;n<=x;n++){const l=n/x*g,d=t+c*l,u=e+f*l,p=r+c*l,M=i+f*l;this._drawBresenhamLine(Math.round(d),Math.round(u),Math.round(p),Math.round(M),s,a,o,h)}for(let r=-x;r<=x;r++){const i=r/x*g;for(let r=1;r<=g;r++){const n=Math.round(t-d*r+c*i),l=Math.round(e-u*r+f*i);this.pixelRenderer.setPixel(n,l,s,a,o,h)}}for(let t=-x;t<=x;t++){const e=t/x*g;for(let t=1;t<=g;t++){const n=Math.round(r+d*t+c*e),l=Math.round(i+u*t+f*e);this.pixelRenderer.setPixel(n,l,s,a,o,h)}}}_drawBresenhamLine(t,e,r,i,n,s,a,o){const h=Math.abs(r-t),l=Math.abs(i-e),c=t<r?1:-1,f=e<i?1:-1;let d=h-l;for(;this.pixelRenderer.setPixel(t,e,n,s,a,o),t!==r||e!==i;){const r=2*d;r>-l&&(d-=l,t+=c),r<h&&(d+=h,e+=f)}}_drawLineThickPolygonScan(t,e,r,i,n,s,a,o,h){const l=r-t,c=i-e,f=Math.sqrt(l*l+c*c),d=this._pixelRuns;if(d.length=0,0===f){const r=n>>1,i=0|t,l=0|e;for(let t=-r;t<=r;t++)d.push(i-r,l+t,1+(r<<1));return void this.pixelRenderer.setPixelRuns(d,s,a,o,h)}const u=1/f,g=-c*u,x=l*u,p=.5*n,M=this._corners,m=g*p,b=x*p;M[0].x=t+m,M[0].y=e+b,M[1].x=t-m,M[1].y=e-b,M[2].x=r-m,M[2].y=i-b,M[3].x=r+m,M[3].y=i+b;const w=0|Math.min(M[0].y,M[1].y,M[2].y,M[3].y),y=Math.max(M[0].y,M[1].y,M[2].y,M[3].y)+.999|0,R=this._edges;for(let t=0;t<4;t++){const e=R[t],r=M[t],i=M[t+1&3];e.p1=r,e.p2=i,r.y!==i.y&&(e.invDeltaY=1/(i.y-r.y),e.deltaX=i.x-r.x)}const C=this._intersections;for(let t=w;t<=y;t++){let e=0;for(let r=0;r<4;r++){const i=R[r],n=i.p1,s=i.p2;if(n.y!==s.y&&(t>=n.y&&t<s.y||t>=s.y&&t<n.y)){const r=(t-n.y)*i.invDeltaY;C[e++]=n.x+r*i.deltaX}}if(1===e){const e=0|C[0];d.push(e,t,1)}else if(2===e){const e=C[0],r=C[1],i=e<r?0|e:0|r,n=(e>r?e+.999|0:r+.999|0)-i;n>0&&d.push(i,t,n)}}d.length>0&&this.pixelRenderer.setPixelRuns(d,s,a,o,h)}}class SWRendererRect{constructor(t,e,r,i,n,s){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=s}drawRect(t){if(t.clippingOnly){if(isNearMultipleOf90Degrees(t.rotation)){const{adjustedWidth:e,adjustedHeight:r}=getRotatedDimensionsIfTheCase(t.width,t.height,t.rotation);this.drawAxisAlignedRect(t.center.x,t.center.y,e,r,!0)}else this.drawRotatedRect(t.center.x,t.center.y,t.width,t.height,t.rotation,!0);return}const{center:e,width:r,height:i,rotation:n,clippingOnly:s,strokeWidth:a,strokeColor:{r:o,g:h,b:l,a:c},fillColor:{r:f,g:d,b:u,a:g}}=t;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:x}=getRotatedDimensionsIfTheCase(r,i,n);this.drawAxisAlignedRect(e.x,e.y,t,x,s,a,o,h,l,c,f,d,u,g)}else this.drawRotatedRect(e.x,e.y,r,i,n,s,a,o,h,l,c,f,d,u,g)}clearRect(t){const e=t.center,r=t.width,i=t.height,n=t.rotation;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:s}=getRotatedDimensionsIfTheCase(r,i,n);if(t===this.width&&s===this.height&&e.x===t/2&&e.y===s/2)return void this.frameBufferUint8ClampedView.fill(0);this.clearAxisAlignedRect(e.x,e.y,t,s)}else this.fillRotatedRect(e.x,e.y,r,i,n,!1,!0)}drawRotatedRect(t,e,r,i,n,s,a,o,h,l,c,f,d,u,g){const x=Math.cos(n),p=Math.sin(n);if((s||g>0)&&this.fillRotatedRect(t,e,r,i,n,s,!1,f,d,u,g),!s&&c>0){const n=r/2,s=i/2,f=[[-n,-s],[n,-s],[n,s],[-n,s]].map((([r,i])=>({x:t+r*x-i*p,y:e+r*p+i*x})));if(1===a)for(let t=0;t<4;t++){const e=f[t],r=f[(t+1)%4];this.lineRenderer.drawLine1px(e.x,e.y,r.x,r.y,o,h,l,c)}else{const t=a/2;for(let e=0;e<4;e+=2){const r=extendLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,a,o,h,l,c)}for(let e=1;e<4;e+=2){const r=shortenLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,a,o,h,l,c)}}}}drawAxisAlignedRect(t,e,r,i,n,s,a,o,h,l,c,f,d,u){if(n&&(s=0),n||u>0){let a=null;if(a=255==l&&s>0?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i)),n){for(let t=Math.floor(a.y);t<Math.ceil(a.y+a.h);t++)for(let e=Math.floor(a.x);e<Math.ceil(a.x+a.w);e++)this.pixelRenderer.clipPixel(e,t);return}const o=this.pixelRenderer.context.globalAlpha,h=255===u&&o>=1;let g=0;h&&(g=255<<24|d<<16|f<<8|c);for(let t=Math.floor(a.y);t<Math.ceil(a.y+a.h);t++)for(let e=Math.floor(a.x);e<Math.ceil(a.x+a.w);e++){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}h?this.frameBufferUint32View[r]=g:this.pixelRenderer.setPixel(e,t,c,f,d,u)}}if(l>0&&s>0){let n=getRectangularStrokeGeometry(t,e,r,i);const c=s/2;for(let t=Math.floor(n.x-c);t<n.x+n.w+c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(t,n.y+e,a,o,h,l),this.pixelRenderer.setPixel(t,n.y+n.h+e,a,o,h,l);for(let t=Math.floor(n.y+c);t<n.y+n.h-c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(n.x+e,t,a,o,h,l),this.pixelRenderer.setPixel(n.x+n.w+e,t,a,o,h,l)}}clearAxisAlignedRect(t,e,r,i){t=Math.round(t),e=Math.round(e),r=Math.round(r),i=Math.round(i);const n=t-Math.floor(r/2),s=e-Math.floor(i/2),a=n+r,o=s+i;for(let t=s;t<o;t++)for(let e=n;e<a;e++)this.pixelRenderer.clearPixel(e,t)}fillRotatedRect(t,e,r,i,n,s,a,o,h,l,c){const f=Math.cos(n),d=Math.sin(n),u=r/2,g=i/2,x=[{x:t+u*f-g*d,y:e+u*d+g*f},{x:t+u*f+g*d,y:e+u*d-g*f},{x:t-u*f+g*d,y:e-u*d-g*f},{x:t-u*f-g*d,y:e-u*d+g*f}],p=[];for(let t=0;t<4;t++){const e=x[t],r=x[(t+1)%4],i=r.y-e.y,n=e.x-r.x,s=r.x*e.y-e.x*r.y;p.push({a:i,b:n,c:s})}const M=Math.floor(Math.min(...x.map((t=>t.x)))),m=Math.ceil(Math.max(...x.map((t=>t.x)))),b=Math.floor(Math.min(...x.map((t=>t.y)))),w=Math.ceil(Math.max(...x.map((t=>t.y)))),y=this.pixelRenderer.context.globalAlpha;if(s)for(let t=b;t<=w;t++)for(let e=M;e<=m;e++){p.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clipPixel(e,t)}else if(a)for(let t=b;t<=w;t++)for(let e=M;e<=m;e++){p.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clearPixel(e,t)}else{const t=255===c&&y>=1;let e=0;t&&(e=255<<24|l<<16|h<<8|o);for(let r=b;r<=w;r++)for(let i=M;i<=m;i++){if(p.every((t=>t.a*i+t.b*r+t.c>=0))){if(i<0||i>=this.width||r<0||r>=this.height)continue;const n=r*this.width+i;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=n>>3,r=7&n;if(0===t[e])continue;if(!(t[e]&1<<7-r))continue}t?this.frameBufferUint32View[n]=e:this.pixelRenderer.setPixel(i,r,o,h,l,c)}}}}}class SWRendererArc{constructor(t){this.pixelRenderer=t}drawArc(t){const{center:e,radius:r,startAngle:i,endAngle:n,strokeWidth:s,strokeColor:{r:a,g:o,b:h,a:l},fillColor:{r:c,g:f,b:d,a:u}}=t;u>0&&this.drawArcHelper(e.x,e.y,r,i,n,c,f,d,u,!0),l>0&&s>0&&this.drawArcHelper(e.x,e.y,r,i,n,a,o,h,l,!1,s)}drawArcHelper(t,e,r,i,n,s,a,o,h,l=!1,c=1){function f(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<i&&(r+=2*Math.PI),r>=i&&r<=n}if(i=i%360*Math.PI/180,(n=n%360*Math.PI/180)<i&&(n+=2*Math.PI),c>1&&(c*=.75),t-=1,e-=1,l){const i=(r-.5)*(r-.5);for(let n=-r;n<=r;n++)for(let l=-r;l<=r;l++)l*l+n*n<=i&&f(l,n)&&this.pixelRenderer.setPixel(Math.round(t+l),Math.round(e+n),Math.round(s),a,o,h)}if(!l||c>0){const l=new Set;let d=0,u=r,g=3-2*r;for(;u>=d;){[[d,u],[-d,u],[d,-u],[-d,-u],[u,d],[-u,d],[u,-d],[-u,-d]].forEach((([r,s])=>{f(r,s)&&this.addThickArcPoint(l,t,e,t+r,e+s,c,i,n)})),d++,g>0?(u--,g=g+4*(d-u)+10):g=g+4*d+6}for(let t of l){const[e,r]=t.split(",").map(Number);this.pixelRenderer.setPixel(e,r,s,a,o,h)}}}drawArcHQ(t){const{center:e,radius:r,startAngle:i,endAngle:n,strokeWidth:s,strokeColor:{r:a,g:o,b:h,a:l},fillColor:{r:c,g:f,b:d,a:u}}=t;e.x-=.5,e.y-=.5,u>0&&this.drawArcHQHelper(e.x,e.y,r,i,n,c,f,d,u,!0),l>0&&s>0&&this.drawArcHQHelper(e.x,e.y,r,i,n,a,o,h,l,!1,s)}drawArcHQHelper(t,e,r,i,n,s,a,o,h,l=!1,c=1){i=i%360*Math.PI/180,(n=n%360*Math.PI/180)<i&&(n+=2*Math.PI),c*=.5,t-=.5,e-=.5,r=Math.floor(r)+.5,t=Math.round(t),e=Math.round(e);const f=Math.floor(t-r-c),d=Math.ceil(t+r+c),u=Math.floor(e-r-c),g=Math.ceil(e+r+c);function x(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<i&&(r+=2*Math.PI),r>=i&&r<=n}const p=r*r;if(l)for(let r=u;r<=g;r++)for(let i=f;i<=d;i++){const n=i-t,l=r-e;n*n+l*l<=p&&x(n,l)&&this.pixelRenderer.setPixel(i,r,s,a,o,h)}if(c>0)for(let i=u;i<=g;i++)for(let n=f;n<=d;n++){const l=n-t,f=i-e,d=l*l+f*f;Math.abs(Math.sqrt(d)-r)<=c&&x(l,f)&&this.pixelRenderer.setPixel(n,i,s,a,o,h)}}addStrokePixel(t,e,r){t.add(`${e},${r}`)}addThickPoint(t,e,r,i){const n=Math.floor(i/2);for(let s=-n;s<i-n;s++)for(let a=-n;a<i-n;a++)this.addStrokePixel(t,Math.round(e+a),Math.round(r+s))}addThickArcPoint(t,e,r,i,n,s,a,o){const h=Math.floor(s/2);for(let l=-h;l<s-h;l++)for(let c=-h;c<s-h;c++){const s=i+c,h=n+l;let f=Math.atan2(h-r,s-e);f<0&&(f+=2*Math.PI),f<a&&(f+=2*Math.PI),f>=a&&f<=o&&t.add(`${Math.round(s)},${Math.round(h)}`)}}}class SWRendererCircle{constructor(t){this.pixelRenderer=t}drawCircle(t){const{center:e,radius:r,strokeWidth:i,strokeColor:{r:n,g:s,b:a,a:o},fillColor:{r:h,g:l,b:c,a:f},clippingOnly:d}=t;if(!0===d)return void this._clipCircleShape(t);const u=f>0;if(!u&&(1===i&&o>0)){return void(255===o&&this.pixelRenderer.context.globalAlpha>=1?this.draw1PxStrokeFullCircleBresenhamOpaque(e.x,e.y,r,n,s,a):this.draw1PxStrokeFullCircleBresenhamAlpha(e.x,e.y,r,n,s,a,o))}const g=i>0&&o>0,x=255===f&&this.pixelRenderer.context.globalAlpha>=1;if(u&&!g&&x)return void this.drawOpaqueFillFullCircleBresenham(e.x,e.y,r,h,l,c);if(u&&!g&&!x)return void this.drawSemiTransparentFillFullCircleBresenham(e.x,e.y,r,h,l,c,f);const p=i>0?r-i/2:r,M=r+i/2;this.drawFullCircleFast(e.x,e.y,p,M,h,l,c,f,n,s,a,o)}drawFullCircleSlow(t,e,r,i,n,s,a,o,h,l,c,f){const d=t-.5,u=e-.5,g=Math.max(0,Math.floor(u-i-1)),x=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),p=Math.max(0,Math.floor(d-i-1)),M=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),m=(r+i)/2,b=m*m,w=o>0,y=f>0&&i>r;if(w&&!y)for(let t=g;t<=x;t++){const e=t-u,r=b-e*e;if(r<0)continue;const i=Math.sqrt(r),h=Math.max(p,Math.ceil(d-i+1e-4)),l=Math.min(M,Math.floor(d+i-1e-4));for(let e=h;e<=l;e++)this.pixelRenderer.setPixel(e,t,n,s,a,o)}else if(y&&!w){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(p,Math.ceil(d-a)),g=Math.min(M,Math.floor(d+a));if(r<=0||s>e)for(let t=o;t<=g;t++)this.pixelRenderer.setPixel(t,i,h,l,c,f);else{const t=Math.sqrt(e-s),r=Math.min(g,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t));for(let t=o;t<=r;t++)this.pixelRenderer.setPixel(t,i,h,l,c,f);for(let t=n;t<=g;t++)this.pixelRenderer.setPixel(t,i,h,l,c,f)}}}else if(w&&y){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const g=i-u,x=g*g;if(x>t)continue;const m=Math.sqrt(t-x),w=Math.max(p,Math.ceil(d-m)),y=Math.min(M,Math.floor(d+m));let R=-1,C=-1;if(r>0&&x<=e){const t=Math.sqrt(e-x);R=Math.min(y,Math.floor(d-t)),C=Math.max(w,Math.ceil(d+t))}const S=b-x;let P=-1,k=-1;if(S>=0){const t=Math.sqrt(S);P=Math.max(p,Math.ceil(d-t+1e-4)),k=Math.min(M,Math.floor(d+t-1e-4))}if(P>=0)for(let t=P;t<=k;t++)this.pixelRenderer.setPixel(t,i,n,s,a,o);if(r<=0||x>e)for(let t=w;t<=y;t++)this.pixelRenderer.setPixel(t,i,h,l,c,f);else{for(let t=w;t<=R;t++)this.pixelRenderer.setPixel(t,i,h,l,c,f);for(let t=C;t<=y;t++)this.pixelRenderer.setPixel(t,i,h,l,c,f)}}}}drawFullCircleFast(t,e,r,i,n,s,a,o,h,l,c,f){const d=t-.5,u=e-.5,g=Math.max(0,Math.floor(u-i-1)),x=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),p=Math.max(0,Math.floor(d-i-1)),M=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),m=(r+i)/2,b=m*m,w=o>0,y=f>0&&i>r,R=[],C=[];if(w&&!y){for(let t=g;t<=x;t++){const e=t-u,r=b-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(p,Math.ceil(d-i+1e-4)),s=Math.min(M,Math.floor(d+i-1e-4))-n+1;s>0&&R.push(n,t,s)}R.length>0&&this.pixelRenderer.setPixelRuns(R,n,s,a,o)}else if(y&&!w){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(p,Math.ceil(d-a)),h=Math.min(M,Math.floor(d+a));if(r<=0||s>e){const t=h-o+1;t>0&&C.push(o,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(h,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t)),a=r-o+1;a>0&&C.push(o,i,a);const l=h-n+1;l>0&&C.push(n,i,l)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,h,l,c,f)}else if(w&&y){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(p,Math.ceil(d-a)),h=Math.min(M,Math.floor(d+a));let l=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);l=Math.min(h,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=b-s;let g=-1,x=-1;if(f>=0){const t=Math.sqrt(f);g=Math.max(p,Math.ceil(d-t+1e-4)),x=Math.min(M,Math.floor(d+t-1e-4))}if(g>=0){const t=x-g+1;t>0&&R.push(g,i,t)}if(r<=0||s>e){const t=h-o+1;t>0&&C.push(o,i,t)}else{const t=l-o+1;t>0&&C.push(o,i,t);const e=h-c+1;e>0&&C.push(c,i,e)}}R.length>0&&this.pixelRenderer.setPixelRuns(R,n,s,a,o),C.length>0&&this.pixelRenderer.setPixelRuns(C,h,l,c,f)}}drawFullCircleFastest(t,e,r,i,n,s,a,o,h,l,c,f){const d=t-.5,u=e-.5,g=Math.max(0,Math.floor(u-i-1)),x=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),p=Math.max(0,Math.floor(d-i-1)),M=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),m=(r+i)/2,b=m*m,w=o>0,y=f>0&&i>r,R=[],C=[],S=[];if(w&&!y){for(let t=g;t<=x;t++){const e=t-u,r=b-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(p,Math.ceil(d-i+1e-4)),s=Math.min(M,Math.floor(d+i-1e-4))-n+1;s>0&&R.push(n,t,s)}R.length>0&&this.pixelRenderer.setPixelRuns(R,n,s,a,o)}else if(y&&!w){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(p,Math.ceil(d-a)),h=Math.min(M,Math.floor(d+a));if(r<=0||s>e){const t=h-o+1;t>0&&C.push(o,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(h,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t)),a=r-o+1;a>0&&C.push(o,i,a);const l=h-n+1;l>0&&C.push(n,i,l)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,h,l,c,f)}else if(w&&y){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(p,Math.ceil(d-a)),h=Math.min(M,Math.floor(d+a));let l=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);l=Math.min(h,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=b-s;let g=-1,x=-1,m=0;if(f>=0){const t=Math.sqrt(f);g=Math.max(p,Math.ceil(d-t+1e-4)),x=Math.min(M,Math.floor(d+t-1e-4)),m=x-g+1}let w=-1,y=0,R=-1,C=0;r<0||s>e?(w=o,y=h-o+1):(w=o,y=l-o+1,R=c,C=h-c+1),S.push(m>0?g:-1,m>0?m:-1,y>0?w:-1,y>0?y:-1,C>0?R:-1,C>0?C:-1)}S.length>0&&this.pixelRenderer.setPixelFillAndStrokeRuns(g,S,n,s,a,o,h,l,c,f)}}draw1PxStrokeFullCircleBresenhamOpaque(t,e,r,i,n,s){const a=this.pixelRenderer,o=a.width,h=a.height,l=(a.frameBufferUint8ClampedView,a.frameBufferUint32View),c=a.context,f=c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=r,g=Math.floor(t),x=Math.floor(e),p=Math.floor(u);if(p<0)return;if(0===p){if(u>=0){const r=Math.round(t),o=Math.round(e);a.setPixel(r,o,i,n,s,255)}return}let M=0,m=0;u>0&&2*u%2==1&&(M=1,m=1);if(g+p<0||g-p-M>=o||x+p<0||x-p-m>=h)return;let b=0,w=p,y=3-2*p;for(;b<=w;){const t=g+b,e=x+w,r=g+w,i=x+b,n=g+w,s=x-b-m,a=g+b,c=x-w-m,u=g-b-M,p=x-w-m,R=g-w-M,C=x-b-m,S=g-w-M,P=x+b,k=g-b-M,_=x+w;if(t>=0&&t<o&&e>=0&&e<h){const r=e*o+t;(!f||0!==f[r>>3]&&f[r>>3]&1<<7-(7&r))&&(l[r]=d)}if(r>=0&&r<o&&i>=0&&i<h&&b!==w){const t=i*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}if(n>=0&&n<o&&s>=0&&s<h){const t=s*o+n;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}if(a>=0&&a<o&&c>=0&&c<h){const t=c*o+a;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}if(u>=0&&u<o&&p>=0&&p<h){const t=p*o+u;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}if(R>=0&&R<o&&C>=0&&C<h&&b!==w){const t=C*o+R;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}if(S>=0&&S<o&&P>=0&&P<h){const t=P*o+S;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}if(k>=0&&k<o&&_>=0&&_<h){const t=_*o+k;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}y<0?y=y+4*b+6:(y=y+4*(b-w)+10,w--),b++}}draw1PxStrokeFullCircleBresenhamAlpha(t,e,r,i,n,s,a){const o=this.pixelRenderer,h=o.context.globalAlpha;if(0===a||h<=0)return;const l=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d.currentState?d.currentState.clippingMask:null,g=a/255*h,x=1-g;if(g<=0)return;const p=r,M=Math.floor(t),m=Math.floor(e),b=Math.floor(p);if(b<0)return;if(0===b){if(p>=0){const r=Math.round(t),h=Math.round(e);o.setPixel(r,h,i,n,s,a)}return}let w=0,y=0;p>0&&2*p%2==1&&(w=1,y=1);if(M+b<0||M-b-w>=l||m+b<0||m-b-y>=c)return;let R=0,C=b,S=3-2*b;const P=new Set;for(;R<=C;){const t=M+R,e=m+C,r=M+C,i=m+R,n=M+C,s=m-R-y,a=M+R,o=m-C-y,h=M-R-w,f=m-C-y,d=M-C-w,u=m-R-y,g=M-C-w,x=m+R,p=M-R-w,b=m+C;t>=0&&t<l&&e>=0&&e<c&&P.add(e*l+t),r>=0&&r<l&&i>=0&&i<c&&P.add(i*l+r),n>=0&&n<l&&s>=0&&s<c&&P.add(s*l+n),a>=0&&a<l&&o>=0&&o<c&&P.add(o*l+a),h>=0&&h<l&&f>=0&&f<c&&P.add(f*l+h),d>=0&&d<l&&u>=0&&u<c&&P.add(u*l+d),g>=0&&g<l&&x>=0&&x<c&&P.add(x*l+g),p>=0&&p<l&&b>=0&&b<c&&P.add(b*l+p),S<0?S=S+4*R+6:(S=S+4*(R-C)+10,C--),R++}if(P.size>0)for(const t of P){const e=4*t;let r=!1;if(u){const e=t>>3,i=7&t;0!==u[e]&&u[e]&1<<7-i||(r=!0)}if(!r){const t=f[e+3]/255*x,r=g+t;if(r>0){const a=1/r;f[e]=(i*g+f[e]*t)*a,f[e+1]=(n*g+f[e+1]*t)*a,f[e+2]=(s*g+f[e+2]*t)*a,f[e+3]=255*r}}}}_generateRelativeHorizontalExtentsBresenham(t){const e=t,r=Math.floor(e);if(r<0)return null;let i=0,n=0;if(e>0&&2*e%2==1&&(i=1,n=1),0===r)return{relativeExtents:[0],intRadius:0,xOffset:i,yOffset:n};const s=new Array(r+1).fill(0);let a=0,o=r,h=3-2*r;for(;a<=o;)s[o]=Math.max(s[o],a),s[a]=Math.max(s[a],o),h<0?h=h+4*a+6:(h=h+4*(a-o)+10,o--),a++;return{relativeExtents:s,intRadius:r,xOffset:i,yOffset:n}}drawOpaqueFillFullCircleBresenham(t,e,r,i,n,s){const a=this.pixelRenderer,o=a.width,h=a.height,l=(a.frameBufferUint8ClampedView,a.frameBufferUint32View),c=a.context,f=c&&c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=this._generateRelativeHorizontalExtentsBresenham(r);if(!u)return;const{relativeExtents:g,intRadius:x,xOffset:p,yOffset:M}=u;if(0===x&&r>=0){const r=Math.round(t),i=Math.round(e);if(r>=0&&r<o&&i>=0&&i<h){const t=i*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(l[t]=d)}return}const m=Math.floor(t-.5),b=Math.floor(e-.5),w=g[0];if(!(m+w<0||m-w-p>=o||b+x<0||b-x-M>=h))if(f)for(let t=0;t<=x;t++){const e=g[t],r=m-e-p+1,i=m+e,n=b+t,s=b-t-M+1;if(n>=0&&n<h){const t=Math.max(0,r),e=n*o+Math.min(o-1,i);let s=n*o+t;for(;s<=e;){const t=s>>3,r=7&s;if(0===r&&s+7<=e){const e=f[t];if(255===e){const t=s+7;for(;s<=t;)l[s]=d,s++;continue}if(0===e){s+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(l[s]=d),s++}}if(t>0&&!(1===t&&0===M)&&s>=0&&s<h){const t=Math.max(0,r),e=s*o+Math.min(o-1,i);let n=s*o+t;for(;n<=e;){const t=n>>3,r=7&n;if(0===r&&n+7<=e){const e=f[t];if(255===e){const t=n+7;for(;n<=t;)l[n]=d,n++;continue}if(0===e){n+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(l[n]=d),n++}}}else for(let t=0;t<=x;t++){const e=g[t],r=m-e-p+1,i=m+e,n=b+t,s=b-t-M+1;if(n>=0&&n<h){let t=n*o+Math.max(0,r);const e=n*o+Math.min(o-1,i);for(;t<=e;)l[t]=d,t++}if(t>0&&!(1===t&&0===M)&&s>=0&&s<h){let t=s*o+Math.max(0,r);const e=s*o+Math.min(o-1,i);for(;t<=e;)l[t]=d,t++}}}drawSemiTransparentFillFullCircleBresenham(t,e,r,i,n,s,a){const o=this.pixelRenderer,h=o.context.globalAlpha;if(0===a||h<=0)return;const l=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d&&d.currentState?d.currentState.clippingMask:null,g=a/255*h,x=1-g;if(g<=0)return;const p=this._generateRelativeHorizontalExtentsBresenham(r);if(!p)return;const{relativeExtents:M,intRadius:m,xOffset:b,yOffset:w}=p;if(0===m&&r>=0){const r=Math.round(t),h=Math.round(e);return void o.setPixel(r,h,i,n,s,a)}const y=Math.floor(t-.5),R=Math.floor(e-.5),C=M[0];if(y+C<0||y-C-b>=l||R+m<0||R-m-w>=c)return;const S=t=>{const e=4*t,r=f[e+3]/255*x,a=g+r;if(a>0){const t=1/a;f[e]=(i*g+f[e]*r)*t,f[e+1]=(n*g+f[e+1]*r)*t,f[e+2]=(s*g+f[e+2]*r)*t,f[e+3]=255*a}};if(u)for(let t=0;t<=m;t++){const e=M[t],r=y-e-b+1,i=y+e,n=R+t,s=R-t-w+1;if(n>=0&&n<c){const t=Math.max(0,r),e=n*l+Math.min(l-1,i);let s=n*l+t;for(;s<=e;){const t=s>>3,r=7&s,i=1<<7-r;if(0===r&&s+7<=e){if(0===u[t]){s+=8;continue}}0!==(u[t]&i)&&S(s),s++}}if(t>0&&!(1===t&&0===w)&&s>=0&&s<c){const t=Math.max(0,r),e=s*l+Math.min(l-1,i);let n=s*l+t;for(;n<=e;){const t=n>>3,r=7&n,i=1<<7-r;if(0===r&&n+7<=e){if(0===u[t]){n+=8;continue}}0!==(u[t]&i)&&S(n),n++}}}else for(let t=0;t<=m;t++){const e=M[t],r=y-e-b+1,i=y+e,n=R+t,s=R-t-w+1;if(n>=0&&n<c){let t=n*l+Math.max(0,r);const e=n*l+Math.min(l-1,i);for(;t<=e;)S(t),t++}if(t>0&&!(1===t&&0===w)&&s>=0&&s<c){let t=s*l+Math.max(0,r);const e=s*l+Math.min(l-1,i);for(;t<=e;)S(t),t++}}}_clipCircleShape(t){const{center:e,radius:r}=t,i=this.pixelRenderer,n=this._generateRelativeHorizontalExtentsBresenham(r);if(!n)return;const{relativeExtents:s,intRadius:a,xOffset:o,yOffset:h}=n;if(0===a&&r>=0){const t=Math.round(e.x),r=Math.round(e.y);return void i.clipPixel(t,r)}const l=Math.floor(e.x-.5),c=Math.floor(e.y-.5);for(let t=0;t<=a;t++){const e=s[t],r=l-e-o+1,n=l+e,a=c+t,f=c-t-h+1;if(a>=0&&a<i.height){const t=Math.max(0,r),e=Math.min(i.width-1,n);for(let r=t;r<=e;r++)i.clipPixel(r,a)}if(t>0&&!(1===t&&0===h)&&f>=0&&f<i.height){const t=Math.max(0,r),e=Math.min(i.width-1,n);for(let r=t;r<=e;r++)i.clipPixel(r,f)}}}}class SWRendererRoundedRect{constructor(t,e,r,i,n,s,a){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=s,this.swRectRenderer=a}drawRoundedRect(t){const{center:e,width:r,height:i,radius:n,rotation:s,strokeWidth:a,strokeColor:{r:o,g:h,b:l,a:c},fillColor:{r:f,g:d,b:u,a:g}}=t;if(isNearMultipleOf90Degrees(s)){const{adjustedWidth:t,adjustedHeight:x}=getRotatedDimensionsIfTheCase(r,i,s),p=n>2?n-1:n;0==a||255===c||a<5&&255===c?this.drawCrispAxisAlignedRoundedRectThinOpaqueStroke(e.x,e.y,t,x,p,a,o,h,l,c,f,d,u,g):this.drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(e.x,e.y,t,x,p,a,o,h,l,c,f,d,u,g)}else this.drawRotatedRoundedRect(e.x,e.y,r,i,n,s,a,o,h,l,c,f,d,u,g)}drawCrispAxisAlignedRoundedRectThinOpaqueStroke(t,e,r,i,n,s,a,o,h,l,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");if(u>0&&this.drawRoundedRectFill(t,e,r,i,n,s,c,f,d,u,255==l&&s>0),l>0&&s>0)if(1===s){let s=getRectangularStrokeGeometry(t,e,r,i),c=Math.round(Math.min(n,Math.min(s.w,s.h)/2));for(let t=Math.floor(s.x+c);t<s.x+s.w-c;t++)this.pixelRenderer.setPixel(t,s.y-.5,a,o,h,l),this.pixelRenderer.setPixel(t,s.y+s.h-.5,a,o,h,l);for(let t=Math.floor(s.y+c);t<s.y+s.h-c;t++)this.pixelRenderer.setPixel(s.x-.5,t,a,o,h,l),this.pixelRenderer.setPixel(s.x+s.w-.5,t,a,o,h,l);const f=(t,e,r,i)=>{for(let n=r;n<=i;n+=Math.PI/180){const r=c-.5,i=t+r*Math.cos(n),s=e+r*Math.sin(n);this.pixelRenderer.setPixel(Math.floor(i),Math.floor(s),a,o,h,l)}};f(s.x+c,s.y+c,Math.PI,3*Math.PI/2),f(s.x+s.w-c,s.y+c,3*Math.PI/2,2*Math.PI),f(s.x+s.w-c,s.y+s.h-c,0,Math.PI/2),f(s.x+c,s.y+s.h-c,Math.PI/2,Math.PI)}else this.drawRoundedRectStroke(t,e,r,i,n,s,a,o,h,l)}drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(t,e,r,i,n,s,a,o,h,l,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");u>0&&this.drawRoundedRectFill(t,e,r,i,n,s,c,f,d,u,255==l&&s>0),l>0&&s>0&&this.drawRoundedRectStroke(t,e,r,i,n,s,a,o,h,l)}drawRoundedRectFill(t,e,r,i,n,s,a,o,h,l,c=!1){let f=null;f=c?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i));let d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));function u(t,e){if(t>=f.x+d&&t<f.x+f.w-d&&e>=f.y&&e<f.y+f.h)return!0;if(t>=f.x&&t<f.x+f.w&&e>=f.y+d&&e<f.y+f.h-d)return!0;const r=[{x:f.x+d,y:f.y+d},{x:f.x+f.w-d,y:f.y+d},{x:f.x+f.w-d,y:f.y+f.h-d},{x:f.x+d,y:f.y+f.h-d}];for(const i of r){const r=t-i.x+1,n=e-i.y+1;if(r*r+n*n<d*d)return!0}return!1}const g=this.pixelRenderer.context.globalAlpha,x=255===l&&g>=1;let p=0;x&&(p=255<<24|h<<16|o<<8|a);for(let t=Math.floor(f.y);t<=Math.ceil(f.y+f.h);t++)for(let e=Math.floor(f.x);e<=Math.ceil(f.x+f.w);e++)if(u(Math.ceil(e),Math.ceil(t))){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}x?this.frameBufferUint32View[r]=p:this.pixelRenderer.setPixel(e,t,a,o,h,l)}}drawRoundedRectStroke(t,e,r,i,n,s,a,o,h,l){const c=s/2;let f=getRectangularStrokeGeometry(t,e,r,i),d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));const u=new PixelSet(this.pixelRenderer),g=new ScanlineSpans;for(let t=f.y-c;t<f.y+c;t++)g.addSpan(t,f.x+d,f.x+f.w-d);for(let t=f.y+f.h-c;t<f.y+f.h+c;t++)g.addSpan(t,f.x+d,f.x+f.w-d);g.addToPixelSet(u,a,o,h,l);const x=new ScanlineSpans,p=new ScanlineSpans;for(let t=f.y+d;t<f.y+f.h-d;t++){for(let e=f.x-c;e<f.x+c;e++)x.addPixel(e,t);for(let e=f.x+f.w-c;e<f.x+f.w+c;e++)p.addPixel(e,t)}x.addToPixelSet(u,a,o,h,l),p.addToPixelSet(u,a,o,h,l);const M=(t,e,r,i)=>{const n=new ScanlineSpans,s=Math.PI/180;for(let a=r;a<=i;a+=s)for(let r=-c;r<c;r++){const i=d+r,s=t+i*Math.cos(a),o=e+i*Math.sin(a);n.addPixel(Math.floor(s),Math.floor(o))}n.addToPixelSet(u,a,o,h,l)};M(f.x+d,f.y+d,Math.PI,3*Math.PI/2),M(f.x+f.w-d,f.y+d,3*Math.PI/2,2*Math.PI),M(f.x+f.w-d,f.y+f.h-d,0,Math.PI/2),M(f.x+d,f.y+f.h-d,Math.PI/2,Math.PI),u.paint()}drawRotatedRoundedRect(t,e,r,i,n,s,a,o,h,l,c,f,d,u,g){const x=Math.cos(s),p=Math.sin(s),M=r/2,m=i/2,b=[[-M+n,-m+n],[M-n,-m+n],[M-n,m-n],[-M+n,m-n]].map((([r,i])=>({x:t+r*x-i*p,y:e+r*p+i*x}))),w=b.map(((t,e)=>{const r=b[(e+1)%4],i=r.x-t.x,n=r.y-t.y,s=Math.sqrt(i*i+n*n);return{dx:i/s,dy:n/s}})),y=b.map(((t,e)=>{const r=w[(e+3)%4],i=w[e],s=-r.dy,a=r.dx,o=-i.dy,h=i.dx;return{start:{x:t.x-n*s,y:t.y-n*a},end:{x:t.x-n*o,y:t.y-n*h}}}));if(g>0){this.swRectRenderer.fillRotatedRect(t,e,r-2*n,i-2*n,s,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+-n*p,e+(-i/2+n/2)*x,r-2*n,n,s,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+(r/2-n/2)*x,e+(r/2-n/2)*p,n,i-2*n,s,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+n*p,e+(i/2-n/2)*x,r-2*n,n,s,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+(-r/2+n/2)*x,e+(-r/2+n/2)*p,n,i-2*n,s,!1,!1,f,d,u,g);const a=180*s/Math.PI;b.forEach(((t,e)=>{const r=[[180,270],[270,360],[0,90],[90,180]][e],i=(r[0]+a)%360,s=(r[1]+a)%360;drawArcSWHelper(t.x,t.y,n,i,s,f,d,u,g,!0)}))}if(c>0){for(let t=0;t<4;t++){const e=y[t],r=y[(t+1)%4];this.lineRenderer.drawLineThick(e.end.x,e.end.y,r.start.x,r.start.y,a,o,h,l,c)}const t=180*s/Math.PI;b.forEach(((e,r)=>{const i=[[180,270],[270,360],[0,90],[90,180]][r],s=(i[0]+t)%360,f=(i[1]+t)%360;drawArcSWHelper(e.x,e.y,n,s,f,o,h,l,c,!1,a)}))}}}class CrispSwCanvas{static version="1.0.2";constructor(t,e){if("object"==typeof t){const e=t;this.width=e.width,this.height=e.height,this.title=e.title||""}else this.width=t,this.height=e,this.title="";this._context=new CrispSwContext(this)}getContext(t){if("2d"!==t)throw new Error("Only '2d' context is supported");return this._context}}const isNode="undefined"==typeof window&&"undefined"!=typeof process,_colorParser=new ColorParser;class CrispSwContext{constructor(t){this.canvas=t,t.title||(t.title=""),this.displayCanvas={width:t.width,height:t.height,title:t.title},this.title=t.title,this.stateStack=[new ContextState(t.width,t.height)],this.frameBufferUint8ClampedView=new Uint8ClampedArray(t.width*t.height*4).fill(0),this.frameBufferUint32View=new Uint32Array(this.frameBufferUint8ClampedView.buffer),this.tempClippingMask=new Uint8Array(Math.ceil(t.width*t.height/8)).fill(0),this.pixelRenderer=new SWRendererPixel(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this),this.lineRenderer=new SWRendererLine(this.pixelRenderer),this.rectRenderer=new SWRendererRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer),this.roundedRectRenderer=new SWRendererRoundedRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer,this.rectRenderer),this.circleRenderer=new SWRendererCircle(this.pixelRenderer),this.arcRenderer=new SWRendererArc(this.pixelRenderer)}get currentState(){return this.stateStack[this.stateStack.length-1]}save(){this.stateStack.push(this.currentState.clone())}restore(){if(this.stateStack.length<=1)throw new Error("Cannot restore() - stack is empty");this.stateStack.pop()}scale(t,e){this.currentState.transform=this.currentState.transform.scale(t,e)}rotate(t){this.currentState.transform=this.currentState.transform.rotate(t)}translate(t,e){this.currentState.transform=this.currentState.transform.translate(t,e)}resetTransform(){this.currentState.transform=new Transform2D}set fillStyle(t){this.currentState.fillColor=Color.fromCSS(t,_colorParser)}get fillStyle(){return this.currentState.fillColor.toCSS()}set strokeStyle(t){this.currentState.strokeColor=Color.fromCSS(t,_colorParser)}get strokeStyle(){return this.currentState.strokeColor.toCSS()}set lineWidth(t){this.currentState.lineWidth=t}set globalAlpha(t){this.currentState.globalAlpha=Math.max(0,Math.min(1,t))}get globalAlpha(){return this.currentState.globalAlpha}beginPath(){this.tempClippingMask.fill(0)}fill(){throw new Error("fill() is not supported - use fillRect() instead")}stroke(){throw new Error("stroke() is not supported - use strokeRect() instead")}strokeLine(t,e,r,i){const n=this.currentState,s=n.transform.getScaledLineWidth(n.lineWidth),a=n.transform.transformPoint({x:t,y:e}),o=n.transform.transformPoint({x:r,y:i});this.lineRenderer.drawLine({start:{x:a.x,y:a.y},end:{x:o.x,y:o.y},thickness:s,color:n.strokeColor})}clearRect(t,e,r,i){const n=this.currentState,s=n.transform.transformPoint({x:t+r/2,y:e+i/2}),a=n.transform.rotationAngle;this.rectRenderer.clearRect({center:{x:s.x,y:s.y},width:r,height:i,rotation:a})}rect(t,e,r,i){const n=this.currentState,s=n.transform.transformPoint({x:t+r/2,y:e+i/2}),a=n.transform.rotationAngle,o=n.transform.scaleX,h=n.transform.scaleY;this.rectRenderer.drawRect({center:{x:s.x,y:s.y},width:r*o,height:i*h,rotation:a,clippingOnly:!0})}clip(){for(let t=0;t<this.currentState.clippingMask.length;t++)this.currentState.clippingMask[t]=this.currentState.clippingMask[t]&this.tempClippingMask[t]}fillRect(t,e,r,i){const n=this.currentState,s=n.transform.transformPoint({x:t+r/2,y:e+i/2}),a=n.transform.rotationAngle,o=n.transform.scaleX,h=n.transform.scaleY;this.rectRenderer.drawRect({center:{x:s.x,y:s.y},width:r*o,height:i*h,rotation:a,clippingOnly:!1,strokeWidth:0,strokeColor:Color.transparent,fillColor:n.fillColor})}strokeRect(t,e,r,i){const n=this.currentState,s=n.transform.getScaledLineWidth(n.lineWidth),a=n.transform.transformPoint({x:t+r/2,y:e+i/2}),o=n.transform.rotationAngle,h=n.transform.scaleX,l=n.transform.scaleY;this.rectRenderer.drawRect({center:{x:a.x,y:a.y},width:r*h,height:i*l,rotation:o,clippingOnly:!1,strokeWidth:s,strokeColor:n.strokeColor,fillColor:Color.transparent})}blitToCanvas(t){if(isNode)return;const e=new ImageData(this.frameBufferUint8ClampedView,this.canvas.width,this.canvas.height);t.getContext("2d").putImageData(e,0,0)}fillCircle(t,e,r,i){const n=this.currentState,s=n.transform.transformPoint({x:t,y:e}),a=n.transform.scaleX,o=n.transform.scaleY,h=r*Math.max(a,o),l={center:{x:s.x,y:s.y},radius:h,strokeWidth:0,strokeColor:Color.transparent,fillColor:i};this.circleRenderer.drawCircle(l)}strokeCircle(t,e,r,i,n){const s=this.currentState,a=s.transform.transformPoint({x:t,y:e}),o=s.transform.scaleX,h=s.transform.scaleY,l=r*Math.max(o,h),c=s.transform.getScaledLineWidth(i),f={center:{x:a.x,y:a.y},radius:l,strokeWidth:c,strokeColor:n,fillColor:Color.transparent};this.circleRenderer.drawCircle(f)}fillAndStrokeCircle(t,e,r,i,n,s){const a=this.currentState,o=a.transform.transformPoint({x:t,y:e}),h=a.transform.scaleX,l=a.transform.scaleY,c=r*Math.max(h,l),f=a.transform.getScaledLineWidth(n),d={center:{x:o.x,y:o.y},radius:c,strokeWidth:f,strokeColor:s,fillColor:i};this.circleRenderer.drawCircle(d)}getImageData(t,e,r,i){const n=this.canvas.width,s=this.canvas.height;t=Math.max(0,Math.min(Math.floor(t),n)),e=Math.max(0,Math.min(Math.floor(e),s)),r=Math.max(0,Math.min(Math.floor(r),n-t)),i=Math.max(0,Math.min(Math.floor(i),s-e));const a=new Uint8ClampedArray(r*i*4);if(0===t&&0===e&&r===n&&i===s)a.set(this.frameBufferUint8ClampedView);else for(let s=0;s<i;s++)for(let i=0;i<r;i++){const o=4*((e+s)*n+(t+i)),h=4*(s*r+i);a[h]=this.frameBufferUint8ClampedView[o],a[h+1]=this.frameBufferUint8ClampedView[o+1],a[h+2]=this.frameBufferUint8ClampedView[o+2],a[h+3]=this.frameBufferUint8ClampedView[o+3]}const o=new ImageData(a,r,i);return void 0===o.canvasTitle&&Object.defineProperty(o,"canvasTitle",{get:()=>this.canvas.title||this.title||"",configurable:!0}),o}roundRect(t,e,r,i,n){const s=this.currentState,a=t+r/2,o=e+i/2;s.transform.transformPoint({x:a,y:o}),s.transform.rotationAngle,s.transform.scaleX,s.transform.scaleY;throw new Error("CrispSwContext.roundRect() for path definition / clipping is not yet implemented.")}fillRoundRect(t,e,r,i,n){const s=this.currentState,a=t+r/2,o=e+i/2,h=s.transform.transformPoint({x:a,y:o}),l=s.transform.rotationAngle,c=s.transform.scaleX,f=s.transform.scaleY,d=n*Math.min(Math.abs(c),Math.abs(f));this.roundedRectRenderer.drawRoundedRect({center:{x:h.x,y:h.y},width:r*c,height:i*f,radius:d,rotation:l,fillColor:s.fillColor,strokeWidth:0,strokeColor:Color.transparent})}strokeRoundRect(t,e,r,i,n){const s=this.currentState,a=s.transform.getScaledLineWidth(s.lineWidth),o=t+r/2,h=e+i/2,l=s.transform.transformPoint({x:o,y:h}),c=s.transform.rotationAngle,f=s.transform.scaleX,d=s.transform.scaleY,u=n*Math.min(Math.abs(f),Math.abs(d));this.roundedRectRenderer.drawRoundedRect({center:{x:l.x,y:l.y},width:r*f,height:i*d,radius:u,rotation:c,fillColor:Color.transparent,strokeWidth:a,strokeColor:s.strokeColor})}arc(t,e,r,i,n,s=!1){if(!(Math.abs(Math.abs(n-i)-2*Math.PI)<1e-9))throw new Error("CrispSwContext.arc() for path definition/clipping is only implemented for full circles. Use fillArc/outerStrokeArc for drawing partial arcs.");{const i=this.currentState,n=i.transform.transformPoint({x:t,y:e}),s=i.transform.scaleX,a=i.transform.scaleY,o=r*Math.max(Math.abs(s),Math.abs(a));this.circleRenderer.drawCircle({center:{x:n.x,y:n.y},radius:o,clippingOnly:!0,strokeWidth:0,strokeColor:Color.transparent,fillColor:Color.transparent})}}fillArc(t,e,r,i,n,s=!1){const a=this.currentState,o=a.transform.transformPoint({x:t,y:e}),h=a.transform.scaleX,l=a.transform.scaleY,c=r*Math.min(Math.abs(h),Math.abs(l)),f=180*i/Math.PI,d=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:o.x,y:o.y},radius:c,startAngle:f,endAngle:d,anticlockwise:s,fillColor:a.fillColor,strokeWidth:0,strokeColor:Color.transparent})}outerStrokeArc(t,e,r,i,n,s=!1){const a=this.currentState,o=a.transform.getScaledLineWidth(a.lineWidth),h=a.transform.transformPoint({x:t,y:e}),l=a.transform.scaleX,c=a.transform.scaleY,f=r*Math.min(Math.abs(l),Math.abs(c)),d=180*i/Math.PI,u=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:h.x,y:h.y},radius:f,startAngle:d,endAngle:u,anticlockwise:s,fillColor:Color.transparent,strokeWidth:o,strokeColor:a.strokeColor})}fillAndOuterStrokeArc(t,e,r,i,n,s=!1){const a=this.currentState,o=a.transform.getScaledLineWidth(a.lineWidth),h=a.transform.transformPoint({x:t,y:e}),l=a.transform.scaleX,c=a.transform.scaleY,f=r*Math.min(Math.abs(l),Math.abs(c)),d=180*i/Math.PI,u=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:h.x,y:h.y},radius:f,startAngle:d,endAngle:u,anticlockwise:s,fillColor:a.fillColor,strokeWidth:o,strokeColor:a.strokeColor})}}