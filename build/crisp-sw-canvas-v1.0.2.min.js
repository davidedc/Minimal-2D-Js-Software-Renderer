/* CrispSwCanvas v1.0.2 */
class TransformationMatrix{constructor(){this.elements=new Float64Array([1,0,0,0,1,0,0,0,1])}clone(){const t=new TransformationMatrix;return t.elements.set(this.elements),t}reset(){return this.elements.set([1,0,0,0,1,0,0,0,1]),this}get(t,e){return this.elements[3*e+t]}set(t,e,r){this.elements[3*e+t]=r}multiply(t){const e=new TransformationMatrix;for(let r=0;r<3;r++)for(let i=0;i<3;i++){let n=0;for(let e=0;e<3;e++)n+=this.get(i,e)*t.get(e,r);e.set(i,r,n)}return e}translate(t,e){const r=new TransformationMatrix;return r.elements.set([1,0,0,0,1,0,t,e,1]),this.multiply(r)}scale(t,e){const r=new TransformationMatrix;return r.elements.set([t,0,0,0,e,0,0,0,1]),this.multiply(r)}rotate(t){const e=new TransformationMatrix,r=Math.cos(t),i=Math.sin(t);return e.elements.set([r,i,0,-i,r,0,0,0,1]),this.multiply(e)}}function getScaledLineWidth(t,e){const r=Math.sqrt(t[0]*t[0]+t[1]*t[1]),i=Math.sqrt(t[3]*t[3]+t[4]*t[4]);return e*Math.max(Math.sqrt(r*i),1e-4)}function transformPoint(t,e,r){return{tx:r[0]*t+r[3]*e+r[6],ty:r[1]*t+r[4]*e+r[7]}}function getRotationAngle(t){return Math.atan2(-t[3],t[0])}function getScaleFactors(t){return{scaleX:Math.sqrt(t[0]*t[0]+t[1]*t[1]),scaleY:Math.sqrt(t[3]*t[3]+t[4]*t[4])}}function parseColor(t){if(!t||"string"!=typeof t)throw new Error("Invalid color format: must be a string");if((t=t.trim().replace(/\s+/g,"")).startsWith("#")){let e,r,i;if(4===t.length)return e=parseInt(t[1]+t[1],16),r=parseInt(t[2]+t[2],16),i=parseInt(t[3]+t[3],16),normalizeColor(e,r,i,1);if(7===t.length)return e=parseInt(t.substring(1,3),16),r=parseInt(t.substring(3,5),16),i=parseInt(t.substring(5,7),16),normalizeColor(e,r,i,1)}const e=t.match(/^rgb\((\d+),(\d+),(\d+)\)$/i),r=t.match(/^rgba\((\d+),(\d+),(\d+),([0-9]*\.?[0-9]+)\)$/i);if(e){const[t,r,i,n]=e;if(r>255||i>255||n>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+r,+i,+n,1)}if(r){const[t,e,i,n,s]=r;if(e>255||i>255||n>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+e,+i,+n,+s)}throw new Error(`Invalid color format: ${t}`)}function normalizeColor(t,e,r,i){return{r:Math.round(Math.max(0,Math.min(255,t))),g:Math.round(Math.max(0,Math.min(255,e))),b:Math.round(Math.max(0,Math.min(255,r))),a:Math.max(0,Math.min(255,255*i))}}function colorToString(t,e,r,i){return"object"==typeof t?`rgba(${t.r}, ${t.g}, ${t.b}, ${(t.a/255).toFixed(3).replace(/\.?0+$/,"")})`:`rgba(${t}, ${e}, ${r}, ${(i/255).toFixed(3).replace(/\.?0+$/,"")})`}class ContextState{constructor(t,e,r,i,n,s,o,a){this.canvasWidth=t,this.canvasHeight=e,this.lineWidth=r||1,this.transform=i||new TransformationMatrix,this.strokeColor=n||{r:0,g:0,b:0,a:1},this.fillColor=s||{r:0,g:0,b:0,a:1},this.globalAlpha=o||1,this.clippingMask=a||new Uint8Array(Math.ceil(t*e/8)).fill(255)}clone(){const t=new Uint8Array(this.clippingMask);return new ContextState(this.canvasWidth,this.canvasHeight,this.lineWidth,this.transform.clone(),{...this.strokeColor},{...this.fillColor},this.globalAlpha,t)}}function pointInPolygon(t,e,r){let i=!1;for(let n=0,s=r.length-1;n<r.length;s=n++){const o=r[n].x,a=r[n].y,l=r[s].x,h=r[s].y;a>e!=h>e&&t<(l-o)*(e-a)/(h-a)+o&&(i=!i)}return i}function extendLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const o=i/s,a=n/s;return{start:{x:t.x-o*r,y:t.y-a*r},end:{x:e.x+o*r,y:e.y+a*r}}}function shortenLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const o=i/s,a=n/s;return{start:{x:t.x+o*r,y:t.y+a*r},end:{x:e.x-o*r,y:e.y-a*r}}}function alignToPixelBoundary(t){return{x:Math.round(t.x)+.5,y:Math.round(t.y)+.5}}function toIntegerPoint(t){return{x:Math.round(t.x),y:Math.round(t.y)}}function roundCornerOfRectangularGeometry(t){const{x:e,y:r,w:i,h:n}=t;return{x:Math.round(e),y:Math.round(r),w:i,h:n}}function roundCornerOfRectangularGeometryWithWarning(t){const e=roundCornerOfRectangularGeometry(t);return e.x===t.x&&e.y===t.y||console.warn("Rectangular geometry is not at a grid point, rounding to nearest grid point. When this happens, HTML5 Canvas would do a non-crisp fill, while the SW renderer will do a crisp fill."),e}function getRectangularFillGeometry(t,e,r,i){return{x:t-r/2,y:e-i/2,w:r,h:i}}var getRectangularStrokeGeometry=getRectangularFillGeometry;function checkBasicConditionsForCrispRendering(t,e,r,i,n){Number.isInteger(r)&&Number.isInteger(i)||console.warn("Width and height must be integers for crisp rendering"),Number.isInteger(n)||console.warn("Stroke width must be an integer for crisp rendering"),Number.isInteger(t)||t%1==.5||console.warn("Center X must be an integer or *.5 for crisp rendering"),Number.isInteger(e)||e%1==.5||console.warn("Center Y must be an integer or *.5 for crisp rendering ")}const ANGLE_TOLERANCE=.001;function isNearMultipleOf90Degrees(t){const e=(t%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(e)<.001||Math.abs(e-Math.PI/2)<.001||Math.abs(e-Math.PI)<.001||Math.abs(e-3*Math.PI/2)<.001||Math.abs(e-2*Math.PI)<.001}function getRotatedDimensionsIfTheCase(t,e,r){const i=(r%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(i-Math.PI/2)<.001||Math.abs(i-3*Math.PI/2)<.001?{adjustedWidth:e,adjustedHeight:t}:{adjustedWidth:t,adjustedHeight:e}}class SWRendererPixel{constructor(t,e,r,i,n){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,n?(this.context=n,this.tempClippingMask=n.tempClippingMask):this.context={globalAlpha:1}}clipPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=e*r+t,n=i>>3,s=7&i;this.tempClippingMask[n]|=1<<7-s}setPixel(t,e,r,i,n,s){t|=0,e|=0;const o=this.width,a=this.context.globalAlpha;if(t<0||t>=o||e<0||e>=this.height)return;const l=e*o+t,h=4*l;if(this.context.currentState){const t=this.context.currentState.clippingMask,e=l>>3,r=7&l;if(0===t[e])return;if(!(t[e]&1<<7-r))return}let c=0;if(255===s&&a>=1)return c=255<<24|n<<16|i<<8|r,void(this.frameBufferUint32View[l]=c);const f=s/255*a,d=this.frameBufferUint8ClampedView[h+3]/255*(1-f),u=f+d;if(u<=0)return;const x=1/u;this.frameBufferUint8ClampedView[h]=(r*f+this.frameBufferUint8ClampedView[h]*d)*x,this.frameBufferUint8ClampedView[h+1]=(i*f+this.frameBufferUint8ClampedView[h+1]*d)*x,this.frameBufferUint8ClampedView[h+2]=(n*f+this.frameBufferUint8ClampedView[h+2]*d)*x,this.frameBufferUint8ClampedView[h+3]=255*u}clearPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=4*(e*r+t);this.frameBufferUint8ClampedView[i]=0,this.frameBufferUint8ClampedView[i+1]=0,this.frameBufferUint8ClampedView[i+2]=0,this.frameBufferUint8ClampedView[i+3]=0}setPixelRuns(t,e,r,i,n){const s=this.width,o=this.height,a=this.frameBufferUint8ClampedView,l=this.frameBufferUint32View,h=this.context.globalAlpha,c=this.context.currentState,f=c?this.context.currentState.clippingMask:null,d=255===n&&h>=1;let u=0;d&&(u=255<<24|i<<16|r<<8|e);const x=d?1:n/255*h,M=d?0:1-x;if(!(x<=0))for(let n=0;n<t.length;n+=3){let h=0|t[n];const m=0|t[n+1];let p=0|t[n+2];if(m<0||m>=o)continue;if(h<0&&(p+=h,h=0,p<=0))continue;if(h+p>s&&(p=s-h,p<=0))continue;let g=m*s+h,w=4*g;if(d)for(let t=0;t<p;t++,g++,w+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,w+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}l[g]=u}else for(let t=0;t<p;t++,g++,w+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,w+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}const n=a[w+3]/255*M,s=x+n;if(s<=0)continue;const o=1/s;a[w]=(e*x+a[w]*n)*o,a[w+1]=(r*x+a[w+1]*n)*o,a[w+2]=(i*x+a[w+2]*n)*o,a[w+3]=255*s}}}setPixelFillAndStrokeRuns(t,e,r,i,n,s,o,a,l,h){t+=2;const c=this.width,f=this.height,d=this.frameBufferUint8ClampedView,u=this.frameBufferUint32View,x=this.context.globalAlpha,M=this.context.currentState,m=M?this.context.currentState.clippingMask:null,p=s/255*x,g=1-p,w=p>=1;let R=0;w&&(R=255<<24|n<<16|i<<8|r);const y=h/255*x,C=1-y,S=y>=1;let P=0;if(S&&(P=255<<24|l<<16|a<<8|o),p<=0&&y<=0)return;let b=t;for(let t=0;t<e.length;t+=6){if(b<0||b>=f){b++;continue}let s=-1!==e[t]?0|e[t]:-1,h=-1!==e[t+1]?0|e[t+1]:-1,x=-1!==e[t+2]?0|e[t+2]:-1,k=-1!==e[t+3]?0|e[t+3]:-1,B=-1!==e[t+4]?0|e[t+4]:-1,_=-1!==e[t+5]?0|e[t+5]:-1;const U=-1!==s&&h>0&&p>0,v=-1!==x&&k>0&&y>0,A=-1!==B&&_>0&&y>0;if(U||v||A){U&&(s<0&&(h+=s,s=0),s+h>c&&(h=c-s),h<=0&&(s=-1,h=0)),v&&(x<0&&(k+=x,x=0),x+k>c&&(k=c-x),k<=0&&(x=-1,k=0)),A&&(B<0&&(_+=B,B=0),B+_>c&&(_=c-B),_<=0&&(B=-1,_=0));for(let t=0;t<3;t++){let e,f,V,L,W,q,F,I,O=0;if(0===t){if(!U||-1===s||h<=0)continue;e=s,f=h,V=r,L=i,W=n,q=p,F=g,I=w,I&&(O=R)}else if(1===t){if(!v||-1===x||k<=0)continue;e=x,f=k,V=o,L=a,W=l,q=y,F=C,I=S,I&&(O=P)}else{if(!A||-1===B||_<=0)continue;e=B,f=_,V=o,L=a,W=l,q=y,F=C,I=S,I&&(O=P)}let T=b*c+e,D=4*T;for(let t=0;t<f;t++,T++,D+=4){if(M){const e=T>>3;if(e>=m.length)continue;if(0===m[e]){const e=8-(7&T),r=Math.min(e,f-t);t+=r-1,T+=r-1,D+=4*(r-1);continue}const r=7&T;if(!(m[e]&1<<7-r))continue}if(I)u[T]=O;else{const t=d[D+3]/255*F,e=q+t;if(e<=1e-5)continue;const r=1/e;d[D]=(V*q+d[D]*t)*r,d[D+1]=(L*q+d[D+1]*t)*r,d[D+2]=(W*q+d[D+2]*t)*r,d[D+3]=255*e}}}b++}else b++}}}class SWRendererLine{constructor(t){this.pixelRenderer=t,this._corners=[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],this._edges=[{p1:this._corners[0],p2:this._corners[1],invDeltaY:0,deltaX:0},{p1:this._corners[1],p2:this._corners[2],invDeltaY:0,deltaX:0},{p1:this._corners[2],p2:this._corners[3],invDeltaY:0,deltaX:0},{p1:this._corners[3],p2:this._corners[0],invDeltaY:0,deltaX:0}],this._intersections=new Array(8),this._pixelRuns=[]}drawLine(t){const{start:{x:e,y:r},end:{x:i,y:n},thickness:s,color:{r:o,g:a,b:l,a:h}}=t;if(1!==s)return void this.drawLineThick(e,r,i,n,s,o,a,l,h);let c=Math.floor(e),f=Math.floor(r),d=Math.floor(i),u=Math.floor(n);c===d&&(u>f?u--:f--),f===u&&(d>c?d--:c--);const x=this.pixelRenderer.context.globalAlpha;if(0===h||x<=0)return;const M=Math.abs(d-c),m=Math.abs(u-f);return 0===M?this._drawLine1px_vertical(c,f,u,o,a,l,h):0===m?this._drawLine1px_horizontal(c,d,f,o,a,l,h):M===m?this._drawLine1px_45degrees(c,f,d,u,o,a,l,h):this._drawLine1px_genericOrientations(c,f,d,u,M,m,o,a,l,h)}drawLine1px(t,e,r,i,n,s,o,a){t=Math.floor(t),e=Math.floor(e),r=Math.floor(r),i=Math.floor(i);const l=Math.abs(r-t),h=Math.abs(i-e);return 0===l?this._drawLine1px_vertical(t,e,i,n,s,o,a):0===h?this._drawLine1px_horizontal(t,r,e,n,s,o,a):l===h?this._drawLine1px_45degrees(t,e,r,i,n,s,o,a):this._drawLine1px_genericOrientations(t,e,r,i,l,h,n,s,o,a)}_drawLine1px_horizontal(t,e,r,i,n,s,o){const a=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(r<0||r>=c)return;const x=255===o&&u>=1;let M=0;x&&(M=255<<24|s<<16|n<<8|i);const m=x?1:o/255*u,p=x?0:1-m;if(t>e){let r=t;t=e,e=r}if(t<0&&(t=0),e>=h&&(e=h-1),t>e)return;const g=4*(r*h+t);for(let o=t;o<=e;o++){const e=g+4*(o-t),c=r*h+o;if(f){const t=c>>3,e=7&c;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[c]=M;else{const t=a[e+3]/255*p,r=m+t;if(r<=0)continue;const o=1/r;a[e]=(i*m+a[e]*t)*o,a[e+1]=(n*m+a[e+1]*t)*o,a[e+2]=(s*m+a[e+2]*t)*o,a[e+3]=255*r}}}_drawLine1px_vertical(t,e,r,i,n,s,o){const a=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(t<0||t>=h)return;const x=255===o&&u>=1;let M=0;x&&(M=255<<24|s<<16|n<<8|i);const m=x?1:o/255*u,p=x?0:1-m;if(e>r){let t=e;e=r,r=t}if(e<0&&(e=0),r>=c&&(r=c-1),!(e>r))for(let o=e;o<=r;o++){const e=4*(o*h+t),r=o*h+t;if(f){const t=r>>3,e=7&r;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[r]=M;else{const t=a[e+3]/255*p,r=m+t;if(r<=0)continue;const o=1/r;a[e]=(i*m+a[e]*t)*o,a[e+1]=(n*m+a[e+1]*t)*o,a[e+2]=(s*m+a[e+2]*t)*o,a[e+3]=255*r}}}_drawLine1px_45degrees(t,e,r,i,n,s,o,a){const l=this.pixelRenderer.frameBufferUint8ClampedView,h=this.pixelRenderer.frameBufferUint32View,c=this.pixelRenderer.width,f=this.pixelRenderer.height,d=this.pixelRenderer.context.currentState,u=d?this.pixelRenderer.context.currentState.clippingMask:null,x=this.pixelRenderer.context.globalAlpha,M=255===a&&x>=1;let m=0;M&&(m=255<<24|o<<16|s<<8|n);const p=M?1:a/255*x,g=M?0:1-p,w=t<r?1:-1,R=e<i?1:-1;let y=t,C=e;for(;!(y<0&&w<0||y>=c&&w>0||C<0&&R<0||C>=f&&R>0);){if(y>=0&&y<c&&C>=0&&C<f){const t=4*(C*c+y),e=C*c+y;let r=!0;if(d){const t=e>>3,i=7&e;!(t>=u.length||0===u[t])&&u[t]&1<<7-i||(r=!1)}if(r)if(M)h[e]=m;else{const e=l[t+3]/255*g,r=p+e;if(r>0){const i=1/r;l[t]=(n*p+l[t]*e)*i,l[t+1]=(s*p+l[t+1]*e)*i,l[t+2]=(o*p+l[t+2]*e)*i,l[t+3]=255*r}}}if(y===r&&C===i)break;y+=w,C+=R}}_drawLine1px_genericOrientations(t,e,r,i,n,s,o,a,l,h){const c=this.pixelRenderer.frameBufferUint8ClampedView,f=this.pixelRenderer.frameBufferUint32View,d=this.pixelRenderer.width,u=this.pixelRenderer.height,x=this.pixelRenderer.context.currentState,M=x?this.pixelRenderer.context.currentState.clippingMask:null,m=this.pixelRenderer.context.globalAlpha,p=255===h&&m>=1;let g=0;p&&(g=255<<24|l<<16|a<<8|o);const w=p?1:h/255*m,R=p?0:1-w,y=t<r?1:-1,C=e<i?1:-1;let S=n-s;for(;;){if(t>=0&&t<d&&e>=0&&e<u){const r=4*(e*d+t),i=e*d+t;let n=!0;if(x){const t=i>>3,e=7&i;!(t>=M.length||0===M[t])&&M[t]&1<<7-e||(n=!1)}if(n)if(p)f[i]=g;else{const t=c[r+3]/255*R,e=w+t;if(e>0){const i=1/e;c[r]=(o*w+c[r]*t)*i,c[r+1]=(a*w+c[r+1]*t)*i,c[r+2]=(l*w+c[r+2]*t)*i,c[r+3]=255*e}}}if(t===r&&e===i)break;const h=2*S;h>-s&&(S-=s,t+=y),h<n&&(S+=n,e+=C)}}drawLineThick(t,e,r,i,n,s,o,a,l){this._drawLineThickPolygonScan(t,e,r,i,n,s,o,a,l)}_drawLineThickBoundingBox(t,e,r,i,n,s,o,a,l){const h=(r-=.5)-(t-=.5),c=(i-=.5)-(e-=.5),f=Math.sqrt(h*h+c*c);if(0===f)return;const d=-c/f,u=h/f,x=n/2,M=[[t+d*x,e+u*x],[t-d*x,e-u*x],[r+d*x,i+u*x],[r-d*x,i-u*x]],m=Math.floor(Math.min(...M.map((t=>t[0])))),p=Math.ceil(Math.max(...M.map((t=>t[0])))),g=Math.floor(Math.min(...M.map((t=>t[1])))),w=Math.ceil(Math.max(...M.map((t=>t[1]))));for(let r=g;r<=w;r++)for(let i=m;i<=p;i++){const n=i-t,d=r-e,u=(n*h+d*c)/f,M=n-h/f*u,m=d-c/f*u,p=Math.sqrt(M*M+m*m);u>=0&&u<=f&&p<=x&&this.pixelRenderer.setPixel(i,r,s,o,a,l)}}_drawLineThickModifiedBresenham(t,e,r,i,n,s,o,a,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1;let u,x;const M=Math.sqrt(h*h+c*c);if(0===M){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,o,a,l);return}u=-c/M,x=h/M;const m=n/2;let p=h-c,g=t,w=e;for(;this._drawPerpendicularSegment(g,w,u,x,m,s,o,a,l),g!==r||w!==i;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,w+=d)}const R=(r-t)/M,y=(i-e)/M;this._drawSquareCap(t,e,u,x,m,-R,-y,s,o,a,l),this._drawSquareCap(r,i,u,x,m,R,y,s,o,a,l)}_drawPerpendicularSegment(t,e,r,i,n,s,o,a,l){const h=Math.ceil(n);this.pixelRenderer.setPixel(t,e,s,o,a,l);for(let c=1;c<=h;c++){const f=c/h*n,d=Math.round(t+r*f),u=Math.round(e+i*f),x=Math.round(t-r*f),M=Math.round(e-i*f);this.pixelRenderer.setPixel(d,u,s,o,a,l),this.pixelRenderer.setPixel(x,M,s,o,a,l)}}_drawSquareCap(t,e,r,i,n,s,o,a,l,h,c){const f=Math.ceil(n);for(let d=1;d<=f;d++){const u=d/f*n,x=Math.round(t+s*u),M=Math.round(e+o*u);this._drawPerpendicularSegment(x,M,r,i,n,a,l,h,c)}}_drawLineThickDistanceOptimized(t,e,r,i,n,s,o,a,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1,u=Math.sqrt((r-t)**2+(i-e)**2);if(0===u){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,o,a,l);return}const x=-(i-e)/u,M=(r-t)/u,m=Math.floor(n/2);let p=h-c,g=t,w=e;const R=[];for(;R.push({x:g,y:w}),g!==r||w!==i;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,w+=d)}for(const t of R)for(let e=-m;e<=m;e++){const r=Math.round(t.x+x*e),i=Math.round(t.y+M*e);this.pixelRenderer.setPixel(r,i,s,o,a,l)}const y=-(r-t)/u,C=-(i-e)/u;for(let r=1;r<=m;r++){const i=Math.round(t+y*r),n=Math.round(e+C*r);for(let t=-m;t<=m;t++){const e=Math.round(i+x*t),r=Math.round(n+M*t);this.pixelRenderer.setPixel(e,r,s,o,a,l)}}const S=(r-t)/u,P=(i-e)/u;for(let t=1;t<=m;t++){const e=Math.round(r+S*t),n=Math.round(i+P*t);for(let t=-m;t<=m;t++){const r=Math.round(e+x*t),i=Math.round(n+M*t);this.pixelRenderer.setPixel(r,i,s,o,a,l)}}}_drawLineThickParallelOffset(t,e,r,i,n,s,o,a,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.sqrt((r-t)**2+(i-e)**2);if(0===h){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,o,a,l);return}const c=-(i-e)/h,f=(r-t)/h,d=(r-t)/h,u=(i-e)/h,x=n/2,M=Math.ceil(x);for(let n=-M;n<=M;n++){const h=n/M*x,d=t+c*h,u=e+f*h,m=r+c*h,p=i+f*h;this._drawBresenhamLine(Math.round(d),Math.round(u),Math.round(m),Math.round(p),s,o,a,l)}for(let r=-M;r<=M;r++){const i=r/M*x;for(let r=1;r<=x;r++){const n=Math.round(t-d*r+c*i),h=Math.round(e-u*r+f*i);this.pixelRenderer.setPixel(n,h,s,o,a,l)}}for(let t=-M;t<=M;t++){const e=t/M*x;for(let t=1;t<=x;t++){const n=Math.round(r+d*t+c*e),h=Math.round(i+u*t+f*e);this.pixelRenderer.setPixel(n,h,s,o,a,l)}}}_drawBresenhamLine(t,e,r,i,n,s,o,a){const l=Math.abs(r-t),h=Math.abs(i-e),c=t<r?1:-1,f=e<i?1:-1;let d=l-h;for(;this.pixelRenderer.setPixel(t,e,n,s,o,a),t!==r||e!==i;){const r=2*d;r>-h&&(d-=h,t+=c),r<l&&(d+=l,e+=f)}}_drawLineThickPolygonScan(t,e,r,i,n,s,o,a,l){const h=r-t,c=i-e,f=Math.sqrt(h*h+c*c),d=this._pixelRuns;if(d.length=0,0===f){const r=n>>1,i=0|t,h=0|e;for(let t=-r;t<=r;t++)d.push(i-r,h+t,1+(r<<1));return void this.pixelRenderer.setPixelRuns(d,s,o,a,l)}const u=1/f,x=-c*u,M=h*u,m=.5*n,p=this._corners,g=x*m,w=M*m;p[0].x=t+g,p[0].y=e+w,p[1].x=t-g,p[1].y=e-w,p[2].x=r-g,p[2].y=i-w,p[3].x=r+g,p[3].y=i+w;const R=0|Math.min(p[0].y,p[1].y,p[2].y,p[3].y),y=Math.max(p[0].y,p[1].y,p[2].y,p[3].y)+.999|0,C=this._edges;for(let t=0;t<4;t++){const e=C[t],r=p[t],i=p[t+1&3];e.p1=r,e.p2=i,r.y!==i.y&&(e.invDeltaY=1/(i.y-r.y),e.deltaX=i.x-r.x)}const S=this._intersections;for(let t=R;t<=y;t++){let e=0;for(let r=0;r<4;r++){const i=C[r],n=i.p1,s=i.p2;if(n.y!==s.y&&(t>=n.y&&t<s.y||t>=s.y&&t<n.y)){const r=(t-n.y)*i.invDeltaY;S[e++]=n.x+r*i.deltaX}}if(1===e){const e=0|S[0];d.push(e,t,1)}else if(2===e){const e=S[0],r=S[1],i=e<r?0|e:0|r,n=(e>r?e+.999|0:r+.999|0)-i;n>0&&d.push(i,t,n)}}d.length>0&&this.pixelRenderer.setPixelRuns(d,s,o,a,l)}}class SWRendererRect{constructor(t,e,r,i,n,s){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=s}drawRect(t){if(t.clippingOnly){if(isNearMultipleOf90Degrees(t.rotation)){const{adjustedWidth:e,adjustedHeight:r}=getRotatedDimensionsIfTheCase(t.width,t.height,t.rotation);this.drawAxisAlignedRect(t.center.x,t.center.y,e,r,!0)}else this.drawRotatedRect(t.center.x,t.center.y,t.width,t.height,t.rotation,!0);return}const{center:e,width:r,height:i,rotation:n,clippingOnly:s,strokeWidth:o,strokeColor:{r:a,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:x}}=t;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:M}=getRotatedDimensionsIfTheCase(r,i,n);this.drawAxisAlignedRect(e.x,e.y,t,M,s,o,a,l,h,c,f,d,u,x)}else this.drawRotatedRect(e.x,e.y,r,i,n,s,o,a,l,h,c,f,d,u,x)}clearRect(t){const e=t.center,r=t.width,i=t.height,n=t.rotation;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:s}=getRotatedDimensionsIfTheCase(r,i,n);if(t===this.width&&s===this.height&&e.x===t/2&&e.y===s/2)return void this.frameBufferUint8ClampedView.fill(0);this.clearAxisAlignedRect(e.x,e.y,t,s)}else this.fillRotatedRect(e.x,e.y,r,i,n,!1,!0)}drawRotatedRect(t,e,r,i,n,s,o,a,l,h,c,f,d,u,x){const M=Math.cos(n),m=Math.sin(n);if((s||x>0)&&this.fillRotatedRect(t,e,r,i,n,s,!1,f,d,u,x),!s&&c>0){const n=r/2,s=i/2,f=[[-n,-s],[n,-s],[n,s],[-n,s]].map((([r,i])=>({x:t+r*M-i*m,y:e+r*m+i*M})));if(1===o)for(let t=0;t<4;t++){const e=f[t],r=f[(t+1)%4];this.lineRenderer.drawLine1px(e.x,e.y,r.x,r.y,a,l,h,c)}else{const t=o/2;for(let e=0;e<4;e+=2){const r=extendLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,o,a,l,h,c)}for(let e=1;e<4;e+=2){const r=shortenLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,o,a,l,h,c)}}}}drawAxisAlignedRect(t,e,r,i,n,s,o,a,l,h,c,f,d,u){if(n&&(s=0),n||u>0){let o=null;if(o=255==h&&s>0?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i)),n){for(let t=Math.floor(o.y);t<Math.ceil(o.y+o.h);t++)for(let e=Math.floor(o.x);e<Math.ceil(o.x+o.w);e++)this.pixelRenderer.clipPixel(e,t);return}const a=this.pixelRenderer.context.globalAlpha,l=255===u&&a>=1;let x=0;l&&(x=255<<24|d<<16|f<<8|c);for(let t=Math.floor(o.y);t<Math.ceil(o.y+o.h);t++)for(let e=Math.floor(o.x);e<Math.ceil(o.x+o.w);e++){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}l?this.frameBufferUint32View[r]=x:this.pixelRenderer.setPixel(e,t,c,f,d,u)}}if(h>0&&s>0){let n=getRectangularStrokeGeometry(t,e,r,i);const c=s/2;for(let t=Math.floor(n.x-c);t<n.x+n.w+c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(t,n.y+e,o,a,l,h),this.pixelRenderer.setPixel(t,n.y+n.h+e,o,a,l,h);for(let t=Math.floor(n.y+c);t<n.y+n.h-c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(n.x+e,t,o,a,l,h),this.pixelRenderer.setPixel(n.x+n.w+e,t,o,a,l,h)}}clearAxisAlignedRect(t,e,r,i){t=Math.round(t),e=Math.round(e),r=Math.round(r),i=Math.round(i);const n=t-Math.floor(r/2),s=e-Math.floor(i/2),o=n+r,a=s+i;for(let t=s;t<a;t++)for(let e=n;e<o;e++)this.pixelRenderer.clearPixel(e,t)}fillRotatedRect(t,e,r,i,n,s,o,a,l,h,c){const f=Math.cos(n),d=Math.sin(n),u=r/2,x=i/2,M=[{x:t+u*f-x*d,y:e+u*d+x*f},{x:t+u*f+x*d,y:e+u*d-x*f},{x:t-u*f+x*d,y:e-u*d-x*f},{x:t-u*f-x*d,y:e-u*d+x*f}],m=[];for(let t=0;t<4;t++){const e=M[t],r=M[(t+1)%4],i=r.y-e.y,n=e.x-r.x,s=r.x*e.y-e.x*r.y;m.push({a:i,b:n,c:s})}const p=Math.floor(Math.min(...M.map((t=>t.x)))),g=Math.ceil(Math.max(...M.map((t=>t.x)))),w=Math.floor(Math.min(...M.map((t=>t.y)))),R=Math.ceil(Math.max(...M.map((t=>t.y)))),y=this.pixelRenderer.context.globalAlpha;if(s)for(let t=w;t<=R;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clipPixel(e,t)}else if(o)for(let t=w;t<=R;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clearPixel(e,t)}else{const t=255===c&&y>=1;let e=0;t&&(e=255<<24|h<<16|l<<8|a);for(let r=w;r<=R;r++)for(let i=p;i<=g;i++){if(m.every((t=>t.a*i+t.b*r+t.c>=0))){if(i<0||i>=this.width||r<0||r>=this.height)continue;const n=r*this.width+i;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=n>>3,r=7&n;if(0===t[e])continue;if(!(t[e]&1<<7-r))continue}t?this.frameBufferUint32View[n]=e:this.pixelRenderer.setPixel(i,r,a,l,h,c)}}}}}class SWRendererCircle{constructor(t){this.pixelRenderer=t}drawCircle(t){const{center:e,radius:r,strokeWidth:i,strokeColor:{r:n,g:s,b:o,a:a},fillColor:{r:l,g:h,b:c,a:f}}=t,d=f>0;if(!d&&(1===i&&a>0)){return void(255===a&&this.pixelRenderer.context.globalAlpha>=1?this.draw1PxStrokeFullCircleBresenhamOpaque(e.x,e.y,r,n,s,o):this.draw1PxStrokeFullCircleBresenhamAlpha(e.x,e.y,r,n,s,o,a))}const u=i>0&&a>0,x=255===f&&this.pixelRenderer.context.globalAlpha>=1;if(d&&!u&&x)return void this.drawOpaqueFillFullCircleBresenham(e.x,e.y,r,l,h,c);if(d&&!u&&!x)return void this.drawSemiTransparentFillFullCircleBresenham(e.x,e.y,r,l,h,c,f);const M=i>0?r-i/2:r,m=r+i/2;this.drawFullCircleFast(e.x,e.y,M,m,l,h,c,f,n,s,o,a)}drawFullCircleSlow(t,e,r,i,n,s,o,a,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,w=g*g,R=a>0,y=f>0&&i>r;if(R&&!y)for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),l=Math.max(m,Math.ceil(d-i+1e-4)),h=Math.min(p,Math.floor(d+i-1e-4));for(let e=l;e<=h;e++)this.pixelRenderer.setPixel(e,t,n,s,o,a)}else if(y&&!R){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),x=Math.min(p,Math.floor(d+o));if(r<=0||s>e)for(let t=a;t<=x;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{const t=Math.sqrt(e-s),r=Math.min(x,Math.floor(d-t)),n=Math.max(a,Math.ceil(d+t));for(let t=a;t<=r;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=n;t<=x;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}else if(R&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const x=i-u,M=x*x;if(M>t)continue;const g=Math.sqrt(t-M),R=Math.max(m,Math.ceil(d-g)),y=Math.min(p,Math.floor(d+g));let C=-1,S=-1;if(r>0&&M<=e){const t=Math.sqrt(e-M);C=Math.min(y,Math.floor(d-t)),S=Math.max(R,Math.ceil(d+t))}const P=w-M;let b=-1,k=-1;if(P>=0){const t=Math.sqrt(P);b=Math.max(m,Math.ceil(d-t+1e-4)),k=Math.min(p,Math.floor(d+t-1e-4))}if(b>=0)for(let t=b;t<=k;t++)this.pixelRenderer.setPixel(t,i,n,s,o,a);if(r<=0||M>e)for(let t=R;t<=y;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{for(let t=R;t<=C;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=S;t<=y;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}}drawFullCircleFast(t,e,r,i,n,s,o,a,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,w=g*g,R=a>0,y=f>0&&i>r,C=[],S=[];if(R&&!y){for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(m,Math.ceil(d-i+1e-4)),s=Math.min(p,Math.floor(d+i-1e-4))-n+1;s>0&&C.push(n,t,s)}C.length>0&&this.pixelRenderer.setPixelRuns(C,n,s,o,a)}else if(y&&!R){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));if(r<=0||s>e){const t=l-a+1;t>0&&S.push(a,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),n=Math.max(a,Math.ceil(d+t)),o=r-a+1;o>0&&S.push(a,i,o);const h=l-n+1;h>0&&S.push(n,i,h)}}S.length>0&&this.pixelRenderer.setPixelRuns(S,l,h,c,f)}else if(R&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(a,Math.ceil(d+t))}const f=w-s;let x=-1,M=-1;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4))}if(x>=0){const t=M-x+1;t>0&&C.push(x,i,t)}if(r<=0||s>e){const t=l-a+1;t>0&&S.push(a,i,t)}else{const t=h-a+1;t>0&&S.push(a,i,t);const e=l-c+1;e>0&&S.push(c,i,e)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,n,s,o,a),S.length>0&&this.pixelRenderer.setPixelRuns(S,l,h,c,f)}}drawFullCircleFastest(t,e,r,i,n,s,o,a,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,w=g*g,R=a>0,y=f>0&&i>r,C=[],S=[],P=[];if(R&&!y){for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(m,Math.ceil(d-i+1e-4)),s=Math.min(p,Math.floor(d+i-1e-4))-n+1;s>0&&C.push(n,t,s)}C.length>0&&this.pixelRenderer.setPixelRuns(C,n,s,o,a)}else if(y&&!R){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));if(r<=0||s>e){const t=l-a+1;t>0&&S.push(a,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),n=Math.max(a,Math.ceil(d+t)),o=r-a+1;o>0&&S.push(a,i,o);const h=l-n+1;h>0&&S.push(n,i,h)}}S.length>0&&this.pixelRenderer.setPixelRuns(S,l,h,c,f)}else if(R&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(a,Math.ceil(d+t))}const f=w-s;let x=-1,M=-1,g=0;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4)),g=M-x+1}let R=-1,y=0,C=-1,S=0;r<0||s>e?(R=a,y=l-a+1):(R=a,y=h-a+1,C=c,S=l-c+1),P.push(g>0?x:-1,g>0?g:-1,y>0?R:-1,y>0?y:-1,S>0?C:-1,S>0?S:-1)}P.length>0&&this.pixelRenderer.setPixelFillAndStrokeRuns(x,P,n,s,o,a,l,h,c,f)}}draw1PxStrokeFullCircleBresenhamOpaque(t,e,r,i,n,s){const o=this.pixelRenderer;if(!o)return void console.error("Pixel renderer not found!");const a=o.width,l=o.height,h=(o.frameBufferUint8ClampedView,o.frameBufferUint32View),c=o.context,f=c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=r,x=Math.floor(t),M=Math.floor(e),m=Math.floor(u);if(m<0)return;if(0===m){if(u>=0){const r=Math.round(t),a=Math.round(e);o.setPixel(r,a,i,n,s,255)}return}let p=0,g=0;u>0&&2*u%2==1&&(p=1,g=1);if(x+m<0||x-m-p>=a||M+m<0||M-m-g>=l)return;let w=0,R=m,y=3-2*m;for(;w<=R;){const t=x+w,e=M+R,r=x+R,i=M+w,n=x+R,s=M-w-g,o=x+w,c=M-R-g,u=x-w-p,m=M-R-g,C=x-R-p,S=M-w-g,P=x-R-p,b=M+w,k=x-w-p,B=M+R;if(t>=0&&t<a&&e>=0&&e<l){const r=e*a+t;(!f||0!==f[r>>3]&&f[r>>3]&1<<7-(7&r))&&(h[r]=d)}if(r>=0&&r<a&&i>=0&&i<l&&w!==R){const t=i*a+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(n>=0&&n<a&&s>=0&&s<l){const t=s*a+n;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(o>=0&&o<a&&c>=0&&c<l){const t=c*a+o;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(u>=0&&u<a&&m>=0&&m<l){const t=m*a+u;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(C>=0&&C<a&&S>=0&&S<l&&w!==R){const t=S*a+C;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(P>=0&&P<a&&b>=0&&b<l){const t=b*a+P;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(k>=0&&k<a&&B>=0&&B<l){const t=B*a+k;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}y<0?y=y+4*w+6:(y=y+4*(w-R)+10,R--),w++}}draw1PxStrokeFullCircleBresenhamAlpha(t,e,r,i,n,s,o){const a=this.pixelRenderer;if(!a)return void console.error("Pixel renderer not found!");const l=a.context.globalAlpha;if(0===o||l<=0)return;const h=a.width,c=a.height,f=a.frameBufferUint8ClampedView,d=a.context,u=d.currentState?d.currentState.clippingMask:null,x=o/255*l,M=1-x;if(x<=0)return;const m=r,p=Math.floor(t),g=Math.floor(e),w=Math.floor(m);if(w<0)return;if(0===w){if(m>=0){const r=Math.round(t),l=Math.round(e);a.setPixel(r,l,i,n,s,o)}return}let R=0,y=0;m>0&&2*m%2==1&&(R=1,y=1);if(p+w<0||p-w-R>=h||g+w<0||g-w-y>=c)return;let C=0,S=w,P=3-2*w;const b=new Set;for(;C<=S;){const t=p+C,e=g+S,r=p+S,i=g+C,n=p+S,s=g-C-y,o=p+C,a=g-S-y,l=p-C-R,f=g-S-y,d=p-S-R,u=g-C-y,x=p-S-R,M=g+C,m=p-C-R,w=g+S;t>=0&&t<h&&e>=0&&e<c&&b.add(e*h+t),r>=0&&r<h&&i>=0&&i<c&&b.add(i*h+r),n>=0&&n<h&&s>=0&&s<c&&b.add(s*h+n),o>=0&&o<h&&a>=0&&a<c&&b.add(a*h+o),l>=0&&l<h&&f>=0&&f<c&&b.add(f*h+l),d>=0&&d<h&&u>=0&&u<c&&b.add(u*h+d),x>=0&&x<h&&M>=0&&M<c&&b.add(M*h+x),m>=0&&m<h&&w>=0&&w<c&&b.add(w*h+m),P<0?P=P+4*C+6:(P=P+4*(C-S)+10,S--),C++}if(b.size>0)for(const t of b){const e=4*t;let r=!1;if(u){const e=t>>3,i=7&t;0!==u[e]&&u[e]&1<<7-i||(r=!0)}if(!r){const t=f[e+3]/255*M,r=x+t;if(r>0){const o=1/r;f[e]=(i*x+f[e]*t)*o,f[e+1]=(n*x+f[e+1]*t)*o,f[e+2]=(s*x+f[e+2]*t)*o,f[e+3]=255*r}}}}_generateRelativeHorizontalExtentsBresenham(t){const e=t,r=Math.floor(e);if(r<0)return null;let i=0,n=0;if(e>0&&2*e%2==1&&(i=1,n=1),0===r)return{relativeExtents:[0],intRadius:0,xOffset:i,yOffset:n};const s=new Array(r+1).fill(0);let o=0,a=r,l=3-2*r;for(;o<=a;)s[a]=Math.max(s[a],o),s[o]=Math.max(s[o],a),l<0?l=l+4*o+6:(l=l+4*(o-a)+10,a--),o++;return{relativeExtents:s,intRadius:r,xOffset:i,yOffset:n}}drawOpaqueFillFullCircleBresenham(t,e,r,i,n,s){const o=this.pixelRenderer;if(!o)return void console.error("Pixel renderer not found!");const a=o.width,l=o.height,h=(o.frameBufferUint8ClampedView,o.frameBufferUint32View),c=o.context,f=c&&c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=this._generateRelativeHorizontalExtentsBresenham(r);if(!u)return;const{relativeExtents:x,intRadius:M,xOffset:m,yOffset:p}=u;if(0===M&&r>=0){const r=Math.round(t),i=Math.round(e);if(r>=0&&r<a&&i>=0&&i<l){const t=i*a+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}return}const g=Math.floor(t-.5),w=Math.floor(e-.5),R=x[0];if(!(g+R<0||g-R-m>=a||w+M<0||w-M-p>=l))if(f)for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,i=g+e,n=w+t,s=w-t-p+1;if(n>=0&&n<l){const t=Math.max(0,r),e=n*a+Math.min(a-1,i);let s=n*a+t;for(;s<=e;){const t=s>>3,r=7&s;if(0===r&&s+7<=e){const e=f[t];if(255===e){const t=s+7;for(;s<=t;)h[s]=d,s++;continue}if(0===e){s+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[s]=d),s++}}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){const t=Math.max(0,r),e=s*a+Math.min(a-1,i);let n=s*a+t;for(;n<=e;){const t=n>>3,r=7&n;if(0===r&&n+7<=e){const e=f[t];if(255===e){const t=n+7;for(;n<=t;)h[n]=d,n++;continue}if(0===e){n+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[n]=d),n++}}}else for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,i=g+e,n=w+t,s=w-t-p+1;if(n>=0&&n<l){let t=n*a+Math.max(0,r);const e=n*a+Math.min(a-1,i);for(;t<=e;)h[t]=d,t++}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){let t=s*a+Math.max(0,r);const e=s*a+Math.min(a-1,i);for(;t<=e;)h[t]=d,t++}}}drawSemiTransparentFillFullCircleBresenham(t,e,r,i,n,s,o){const a=this.pixelRenderer;if(!a)return void console.error("Pixel renderer not found!");const l=a.context.globalAlpha;if(0===o||l<=0)return;const h=a.width,c=a.height,f=a.frameBufferUint8ClampedView,d=a.context,u=d&&d.currentState?d.currentState.clippingMask:null,x=o/255*l,M=1-x;if(x<=0)return;const m=this._generateRelativeHorizontalExtentsBresenham(r);if(!m)return;const{relativeExtents:p,intRadius:g,xOffset:w,yOffset:R}=m;if(0===g&&r>=0){const r=Math.round(t),l=Math.round(e);return void a.setPixel(r,l,i,n,s,o)}const y=Math.floor(t-.5),C=Math.floor(e-.5),S=p[0];if(y+S<0||y-S-w>=h||C+g<0||C-g-R>=c)return;const P=t=>{const e=4*t,r=f[e+3]/255*M,o=x+r;if(o>0){const t=1/o;f[e]=(i*x+f[e]*r)*t,f[e+1]=(n*x+f[e+1]*r)*t,f[e+2]=(s*x+f[e+2]*r)*t,f[e+3]=255*o}};if(u)for(let t=0;t<=g;t++){const e=p[t],r=y-e-w+1,i=y+e,n=C+t,s=C-t-R+1;if(n>=0&&n<c){const t=Math.max(0,r),e=n*h+Math.min(h-1,i);let s=n*h+t;for(;s<=e;){const t=s>>3,r=7&s,i=1<<7-r;if(0===r&&s+7<=e){if(0===u[t]){s+=8;continue}}0!==(u[t]&i)&&P(s),s++}}if(t>0&&!(1===t&&0===R)&&s>=0&&s<c){const t=Math.max(0,r),e=s*h+Math.min(h-1,i);let n=s*h+t;for(;n<=e;){const t=n>>3,r=7&n,i=1<<7-r;if(0===r&&n+7<=e){if(0===u[t]){n+=8;continue}}0!==(u[t]&i)&&P(n),n++}}}else for(let t=0;t<=g;t++){const e=p[t],r=y-e-w+1,i=y+e,n=C+t,s=C-t-R+1;if(n>=0&&n<c){let t=n*h+Math.max(0,r);const e=n*h+Math.min(h-1,i);for(;t<=e;)P(t),t++}if(t>0&&!(1===t&&0===R)&&s>=0&&s<c){let t=s*h+Math.max(0,r);const e=s*h+Math.min(h-1,i);for(;t<=e;)P(t),t++}}}}class CrispSwCanvas{static version="1.0.2";constructor(t,e){if("object"==typeof t){const e=t;this.width=e.width,this.height=e.height,this.title=e.title||""}else this.width=t,this.height=e,this.title="";this._context=new CrispSwContext(this)}getContext(t){if("2d"!==t)throw new Error("Only '2d' context is supported");return this._context}}const isNode="undefined"==typeof window&&"undefined"!=typeof process;class CrispSwContext{constructor(t){this.canvas=t,t.title||(t.title=""),this.displayCanvas={width:t.width,height:t.height,title:t.title},this.title=t.title,this.stateStack=[new ContextState(t.width,t.height)],this.frameBufferUint8ClampedView=new Uint8ClampedArray(t.width*t.height*4).fill(0),this.frameBufferUint32View=new Uint32Array(this.frameBufferUint8ClampedView.buffer),this.tempClippingMask=new Uint8Array(Math.ceil(t.width*t.height/8)).fill(0),this.pixelRenderer=new SWRendererPixel(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this),this.lineRenderer=new SWRendererLine(this.pixelRenderer),this.rectRenderer=new SWRendererRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer),this.circleRenderer=new SWRendererCircle(this.pixelRenderer)}get currentState(){return this.stateStack[this.stateStack.length-1]}save(){this.stateStack.push(this.currentState.clone())}restore(){if(this.stateStack.length<=1)throw new Error("Cannot restore() - stack is empty");this.stateStack.pop()}scale(t,e){this.currentState.transform=this.currentState.transform.scale(t,e)}rotate(t){this.currentState.transform=this.currentState.transform.rotate(t)}translate(t,e){this.currentState.transform=this.currentState.transform.translate(t,e)}resetTransform(){this.currentState.transform.reset()}set fillStyle(t){this.currentState.fillColor=parseColor(t)}set strokeStyle(t){this.currentState.strokeColor=parseColor(t)}set lineWidth(t){this.currentState.lineWidth=t}set globalAlpha(t){this.currentState.globalAlpha=Math.max(0,Math.min(1,t))}get globalAlpha(){return this.currentState.globalAlpha}beginPath(){this.tempClippingMask.fill(0)}fill(){throw new Error("fill() is not supported - use fillRect() instead")}stroke(){throw new Error("stroke() is not supported - use strokeRect() instead")}strokeLine(t,e,r,i){const n=this.currentState,s=getScaledLineWidth(n.transform.elements,n.lineWidth),o=transformPoint(t,e,n.transform.elements),a=transformPoint(r,i,n.transform.elements);this.lineRenderer.drawLine({start:{x:o.tx,y:o.ty},end:{x:a.tx,y:a.ty},thickness:s,color:n.strokeColor})}clearRect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements);this.rectRenderer.clearRect({center:{x:s.tx,y:s.ty},width:r,height:i,rotation:o})}rect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements),{scaleX:a,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*a,height:i*l,rotation:o,clippingOnly:!0})}clip(){for(let t=0;t<this.currentState.clippingMask.length;t++)this.currentState.clippingMask[t]=this.currentState.clippingMask[t]&this.tempClippingMask[t]}fillRect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements),{scaleX:a,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*a,height:i*l,rotation:o,clippingOnly:!1,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:n.fillColor})}strokeRect(t,e,r,i){const n=this.currentState,s=getScaledLineWidth(n.transform.elements,n.lineWidth),o=transformPoint(t+r/2,e+i/2,n.transform.elements),a=getRotationAngle(n.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:o.tx,y:o.ty},width:r*l,height:i*h,rotation:a,clippingOnly:!1,strokeWidth:s,strokeColor:n.strokeColor,fillColor:{r:0,g:0,b:0,a:0}})}blitToCanvas(t){if(isNode)return;const e=new ImageData(this.frameBufferUint8ClampedView,this.canvas.width,this.canvas.height);t.getContext("2d").putImageData(e,0,0)}fillCircle(t,e,r,i,n,s,o){const a=this.currentState,l=transformPoint(t,e,a.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(a.transform.elements),f=r*Math.max(h,c),d={center:{x:l.tx,y:l.ty},radius:f,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:{r:i,g:n,b:s,a:o}};this.circleRenderer.drawCircle(d)}strokeCircle(t,e,r,i,n,s,o,a){const l=this.currentState,h=transformPoint(t,e,l.transform.elements),{scaleX:c,scaleY:f}=getScaleFactors(l.transform.elements),d=r*Math.max(c,f),u=getScaledLineWidth(l.transform.elements,i),x={center:{x:h.tx,y:h.ty},radius:d,strokeWidth:u,strokeColor:{r:n,g:s,b:o,a:a},fillColor:{r:0,g:0,b:0,a:0}};this.circleRenderer.drawCircle(x)}fillAndStrokeCircle(t,e,r,i,n,s,o,a,l,h,c,f){const d=this.currentState,u=transformPoint(t,e,d.transform.elements),{scaleX:x,scaleY:M}=getScaleFactors(d.transform.elements),m=r*Math.max(x,M),p=getScaledLineWidth(d.transform.elements,a),g={center:{x:u.tx,y:u.ty},radius:m,strokeWidth:p,strokeColor:{r:l,g:h,b:c,a:f},fillColor:{r:i,g:n,b:s,a:o}};this.circleRenderer.drawCircle(g)}getImageData(t,e,r,i){const n=this.canvas.width,s=this.canvas.height;t=Math.max(0,Math.min(Math.floor(t),n)),e=Math.max(0,Math.min(Math.floor(e),s)),r=Math.max(0,Math.min(Math.floor(r),n-t)),i=Math.max(0,Math.min(Math.floor(i),s-e));const o=new Uint8ClampedArray(r*i*4);if(0===t&&0===e&&r===n&&i===s)o.set(this.frameBufferUint8ClampedView);else for(let s=0;s<i;s++)for(let i=0;i<r;i++){const a=4*((e+s)*n+(t+i)),l=4*(s*r+i);o[l]=this.frameBufferUint8ClampedView[a],o[l+1]=this.frameBufferUint8ClampedView[a+1],o[l+2]=this.frameBufferUint8ClampedView[a+2],o[l+3]=this.frameBufferUint8ClampedView[a+3]}const a=new ImageData(o,r,i);return void 0===a.canvasTitle&&Object.defineProperty(a,"canvasTitle",{get:()=>this.canvas.title||this.title||"",configurable:!0}),a}}