/* CrispSwCanvas v1.0.2 */
class TransformationMatrix{constructor(){this.elements=new Float64Array([1,0,0,0,1,0,0,0,1])}clone(){const t=new TransformationMatrix;return t.elements.set(this.elements),t}reset(){return this.elements.set([1,0,0,0,1,0,0,0,1]),this}get(t,e){return this.elements[3*e+t]}set(t,e,r){this.elements[3*e+t]=r}multiply(t){const e=new TransformationMatrix;for(let r=0;r<3;r++)for(let n=0;n<3;n++){let i=0;for(let e=0;e<3;e++)i+=this.get(n,e)*t.get(e,r);e.set(n,r,i)}return e}translate(t,e){const r=new TransformationMatrix;return r.elements.set([1,0,0,0,1,0,t,e,1]),this.multiply(r)}scale(t,e){const r=new TransformationMatrix;return r.elements.set([t,0,0,0,e,0,0,0,1]),this.multiply(r)}rotate(t){const e=new TransformationMatrix,r=Math.cos(t),n=Math.sin(t);return e.elements.set([r,n,0,-n,r,0,0,0,1]),this.multiply(e)}}function getScaledLineWidth(t,e){const r=Math.sqrt(t[0]*t[0]+t[1]*t[1]),n=Math.sqrt(t[3]*t[3]+t[4]*t[4]);return e*Math.max(Math.sqrt(r*n),1e-4)}function transformPoint(t,e,r){return{tx:r[0]*t+r[3]*e+r[6],ty:r[1]*t+r[4]*e+r[7]}}function getRotationAngle(t){return Math.atan2(-t[3],t[0])}function getScaleFactors(t){return{scaleX:Math.sqrt(t[0]*t[0]+t[1]*t[1]),scaleY:Math.sqrt(t[3]*t[3]+t[4]*t[4])}}function parseColor(t){if(!t||"string"!=typeof t)throw new Error("Invalid color format: must be a string");if((t=t.trim().replace(/\s+/g,"")).startsWith("#")){let e,r,n;if(4===t.length)return e=parseInt(t[1]+t[1],16),r=parseInt(t[2]+t[2],16),n=parseInt(t[3]+t[3],16),normalizeColor(e,r,n,1);if(7===t.length)return e=parseInt(t.substring(1,3),16),r=parseInt(t.substring(3,5),16),n=parseInt(t.substring(5,7),16),normalizeColor(e,r,n,1)}const e=t.match(/^rgb\((\d+),(\d+),(\d+)\)$/i),r=t.match(/^rgba\((\d+),(\d+),(\d+),([0-9]*\.?[0-9]+)\)$/i);if(e){const[t,r,n,i]=e;if(r>255||n>255||i>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+r,+n,+i,1)}if(r){const[t,e,n,i,s]=r;if(e>255||n>255||i>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+e,+n,+i,+s)}throw new Error(`Invalid color format: ${t}`)}function normalizeColor(t,e,r,n){return{r:Math.round(Math.max(0,Math.min(255,t))),g:Math.round(Math.max(0,Math.min(255,e))),b:Math.round(Math.max(0,Math.min(255,r))),a:Math.max(0,Math.min(255,255*n))}}function colorToString(t,e,r,n){return"object"==typeof t?`rgba(${t.r}, ${t.g}, ${t.b}, ${(t.a/255).toFixed(3).replace(/\.?0+$/,"")})`:`rgba(${t}, ${e}, ${r}, ${(n/255).toFixed(3).replace(/\.?0+$/,"")})`}class ContextState{constructor(t,e,r,n,i,s,a,o){this.canvasWidth=t,this.canvasHeight=e,this.lineWidth=r||1,this.transform=n||new TransformationMatrix,this.strokeColor=i||{r:0,g:0,b:0,a:1},this.fillColor=s||{r:0,g:0,b:0,a:1},this.globalAlpha=a||1,this.clippingMask=o||new Uint8Array(Math.ceil(t*e/8)).fill(255)}clone(){const t=new Uint8Array(this.clippingMask);return new ContextState(this.canvasWidth,this.canvasHeight,this.lineWidth,this.transform.clone(),{...this.strokeColor},{...this.fillColor},this.globalAlpha,t)}}function pointInPolygon(t,e,r){let n=!1;for(let i=0,s=r.length-1;i<r.length;s=i++){const a=r[i].x,o=r[i].y,l=r[s].x,h=r[s].y;o>e!=h>e&&t<(l-a)*(e-o)/(h-o)+a&&(n=!n)}return n}function extendLine(t,e,r){const n=e.x-t.x,i=e.y-t.y,s=Math.sqrt(n*n+i*i);if(0===s)return{start:t,end:e};const a=n/s,o=i/s;return{start:{x:t.x-a*r,y:t.y-o*r},end:{x:e.x+a*r,y:e.y+o*r}}}function shortenLine(t,e,r){const n=e.x-t.x,i=e.y-t.y,s=Math.sqrt(n*n+i*i);if(0===s)return{start:t,end:e};const a=n/s,o=i/s;return{start:{x:t.x+a*r,y:t.y+o*r},end:{x:e.x-a*r,y:e.y-o*r}}}function alignToPixelBoundary(t){return{x:Math.round(t.x)+.5,y:Math.round(t.y)+.5}}function toIntegerPoint(t){return{x:Math.round(t.x),y:Math.round(t.y)}}function roundCornerOfRectangularGeometry(t){const{x:e,y:r,w:n,h:i}=t;return{x:Math.round(e),y:Math.round(r),w:n,h:i}}function roundCornerOfRectangularGeometryWithWarning(t){const e=roundCornerOfRectangularGeometry(t);return e.x===t.x&&e.y===t.y||console.warn("Rectangular geometry is not at a grid point, rounding to nearest grid point. When this happens, HTML5 Canvas would do a non-crisp fill, while the SW renderer will do a crisp fill."),e}function getRectangularFillGeometry(t,e,r,n){return{x:t-r/2,y:e-n/2,w:r,h:n}}var getRectangularStrokeGeometry=getRectangularFillGeometry;function checkBasicConditionsForCrispRendering(t,e,r,n,i){Number.isInteger(r)&&Number.isInteger(n)||console.warn("Width and height must be integers for crisp rendering"),Number.isInteger(i)||console.warn("Stroke width must be an integer for crisp rendering"),Number.isInteger(t)||t%1==.5||console.warn("Center X must be an integer or *.5 for crisp rendering"),Number.isInteger(e)||e%1==.5||console.warn("Center Y must be an integer or *.5 for crisp rendering ")}class PixelSet{constructor(t){this.pixels=new Map,this.pixelRenderer=t}addPixel(t,e,r,n,i,s){const a=`${Math.round(t)},${Math.round(e)}`;this.pixels.set(a,{x:Math.round(t),y:Math.round(e),r:r,g:n,b:i,a:s})}paint(){for(const t of this.pixels.values())this.pixelRenderer.setPixel(t.x,t.y,t.r,t.g,t.b,t.a)}}class ScanlineSpans{constructor(){this.spans=new Map}addSpan(t,e,r){if(e>r&&([e,r]=[r,e]),this.spans.has(t)){const n=this.spans.get(t);n[0]=Math.min(n[0],e),n[1]=Math.max(n[1],r)}else this.spans.set(t,[e,r])}addPixel(t,e){if(e=Math.round(e),t=Math.round(t),this.spans.has(e)){const r=this.spans.get(e);r[0]=Math.min(r[0],t),r[1]=Math.max(r[1],t)}else this.spans.set(e,[t,t])}addToPixelSet(t,e,r,n,i){for(const[s,[a,o]]of this.spans)for(let l=a;l<=o;l++)t.addPixel(l,s,e,r,n,i)}}const ANGLE_TOLERANCE=.001;function isNearMultipleOf90Degrees(t){const e=(t%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(e)<.001||Math.abs(e-Math.PI/2)<.001||Math.abs(e-Math.PI)<.001||Math.abs(e-3*Math.PI/2)<.001||Math.abs(e-2*Math.PI)<.001}function getRotatedDimensionsIfTheCase(t,e,r){const n=(r%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(n-Math.PI/2)<.001||Math.abs(n-3*Math.PI/2)<.001?{adjustedWidth:e,adjustedHeight:t}:{adjustedWidth:t,adjustedHeight:e}}class SWRendererPixel{constructor(t,e,r,n,i){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=n,i?(this.context=i,this.tempClippingMask=i.tempClippingMask):this.context={globalAlpha:1}}clipPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const n=e*r+t,i=n>>3,s=7&n;this.tempClippingMask[i]|=1<<7-s}setPixel(t,e,r,n,i,s){t|=0,e|=0;const a=this.width,o=this.context.globalAlpha;if(t<0||t>=a||e<0||e>=this.height)return;const l=e*a+t,h=4*l;if(this.context.currentState){const t=this.context.currentState.clippingMask,e=l>>3,r=7&l;if(0===t[e])return;if(!(t[e]&1<<7-r))return}let c=0;if(255===s&&o>=1)return c=255<<24|i<<16|n<<8|r,void(this.frameBufferUint32View[l]=c);const f=s/255*o,d=this.frameBufferUint8ClampedView[h+3]/255*(1-f),u=f+d;if(u<=0)return;const x=1/u;this.frameBufferUint8ClampedView[h]=(r*f+this.frameBufferUint8ClampedView[h]*d)*x,this.frameBufferUint8ClampedView[h+1]=(n*f+this.frameBufferUint8ClampedView[h+1]*d)*x,this.frameBufferUint8ClampedView[h+2]=(i*f+this.frameBufferUint8ClampedView[h+2]*d)*x,this.frameBufferUint8ClampedView[h+3]=255*u}clearPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const n=4*(e*r+t);this.frameBufferUint8ClampedView[n]=0,this.frameBufferUint8ClampedView[n+1]=0,this.frameBufferUint8ClampedView[n+2]=0,this.frameBufferUint8ClampedView[n+3]=0}setPixelRuns(t,e,r,n,i){const s=this.width,a=this.height,o=this.frameBufferUint8ClampedView,l=this.frameBufferUint32View,h=this.context.globalAlpha,c=this.context.currentState,f=c?this.context.currentState.clippingMask:null,d=255===i&&h>=1;let u=0;d&&(u=255<<24|n<<16|r<<8|e);const x=d?1:i/255*h,M=d?0:1-x;if(!(x<=0))for(let i=0;i<t.length;i+=3){let h=0|t[i];const m=0|t[i+1];let p=0|t[i+2];if(m<0||m>=a)continue;if(h<0&&(p+=h,h=0,p<=0))continue;if(h+p>s&&(p=s-h,p<=0))continue;let g=m*s+h,w=4*g;if(d)for(let t=0;t<p;t++,g++,w+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,w+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}l[g]=u}else for(let t=0;t<p;t++,g++,w+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,w+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}const i=o[w+3]/255*M,s=x+i;if(s<=0)continue;const a=1/s;o[w]=(e*x+o[w]*i)*a,o[w+1]=(r*x+o[w+1]*i)*a,o[w+2]=(n*x+o[w+2]*i)*a,o[w+3]=255*s}}}setPixelFillAndStrokeRuns(t,e,r,n,i,s,a,o,l,h){t+=2;const c=this.width,f=this.height,d=this.frameBufferUint8ClampedView,u=this.frameBufferUint32View,x=this.context.globalAlpha,M=this.context.currentState,m=M?this.context.currentState.clippingMask:null,p=s/255*x,g=1-p,w=p>=1;let R=0;w&&(R=255<<24|i<<16|n<<8|r);const y=h/255*x,S=1-y,C=y>=1;let P=0;if(C&&(P=255<<24|l<<16|o<<8|a),p<=0&&y<=0)return;let k=t;for(let t=0;t<e.length;t+=6){if(k<0||k>=f){k++;continue}let s=-1!==e[t]?0|e[t]:-1,h=-1!==e[t+1]?0|e[t+1]:-1,x=-1!==e[t+2]?0|e[t+2]:-1,b=-1!==e[t+3]?0|e[t+3]:-1,A=-1!==e[t+4]?0|e[t+4]:-1,B=-1!==e[t+5]?0|e[t+5]:-1;const I=-1!==s&&h>0&&p>0,W=-1!==x&&b>0&&y>0,U=-1!==A&&B>0&&y>0;if(I||W||U){I&&(s<0&&(h+=s,s=0),s+h>c&&(h=c-s),h<=0&&(s=-1,h=0)),W&&(x<0&&(b+=x,x=0),x+b>c&&(b=c-x),b<=0&&(x=-1,b=0)),U&&(A<0&&(B+=A,A=0),A+B>c&&(B=c-A),B<=0&&(A=-1,B=0));for(let t=0;t<3;t++){let e,f,_,v,V,F,L,T,q=0;if(0===t){if(!I||-1===s||h<=0)continue;e=s,f=h,_=r,v=n,V=i,F=p,L=g,T=w,T&&(q=R)}else if(1===t){if(!W||-1===x||b<=0)continue;e=x,f=b,_=a,v=o,V=l,F=y,L=S,T=C,T&&(q=P)}else{if(!U||-1===A||B<=0)continue;e=A,f=B,_=a,v=o,V=l,F=y,L=S,T=C,T&&(q=P)}let O=k*c+e,E=4*O;for(let t=0;t<f;t++,O++,E+=4){if(M){const e=O>>3;if(e>=m.length)continue;if(0===m[e]){const e=8-(7&O),r=Math.min(e,f-t);t+=r-1,O+=r-1,E+=4*(r-1);continue}const r=7&O;if(!(m[e]&1<<7-r))continue}if(T)u[O]=q;else{const t=d[E+3]/255*L,e=F+t;if(e<=1e-5)continue;const r=1/e;d[E]=(_*F+d[E]*t)*r,d[E+1]=(v*F+d[E+1]*t)*r,d[E+2]=(V*F+d[E+2]*t)*r,d[E+3]=255*e}}}k++}else k++}}}class SWRendererLine{constructor(t){this.pixelRenderer=t,this._corners=[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],this._edges=[{p1:this._corners[0],p2:this._corners[1],invDeltaY:0,deltaX:0},{p1:this._corners[1],p2:this._corners[2],invDeltaY:0,deltaX:0},{p1:this._corners[2],p2:this._corners[3],invDeltaY:0,deltaX:0},{p1:this._corners[3],p2:this._corners[0],invDeltaY:0,deltaX:0}],this._intersections=new Array(8),this._pixelRuns=[]}drawLine(t){const{start:{x:e,y:r},end:{x:n,y:i},thickness:s,color:{r:a,g:o,b:l,a:h}}=t;if(1!==s)return void this.drawLineThick(e,r,n,i,s,a,o,l,h);let c=Math.floor(e),f=Math.floor(r),d=Math.floor(n),u=Math.floor(i);c===d&&(u>f?u--:f--),f===u&&(d>c?d--:c--);const x=this.pixelRenderer.context.globalAlpha;if(0===h||x<=0)return;const M=Math.abs(d-c),m=Math.abs(u-f);return 0===M?this._drawLine1px_vertical(c,f,u,a,o,l,h):0===m?this._drawLine1px_horizontal(c,d,f,a,o,l,h):M===m?this._drawLine1px_45degrees(c,f,d,u,a,o,l,h):this._drawLine1px_genericOrientations(c,f,d,u,M,m,a,o,l,h)}drawLine1px(t,e,r,n,i,s,a,o){t=Math.floor(t),e=Math.floor(e),r=Math.floor(r),n=Math.floor(n);const l=Math.abs(r-t),h=Math.abs(n-e);return 0===l?this._drawLine1px_vertical(t,e,n,i,s,a,o):0===h?this._drawLine1px_horizontal(t,r,e,i,s,a,o):l===h?this._drawLine1px_45degrees(t,e,r,n,i,s,a,o):this._drawLine1px_genericOrientations(t,e,r,n,l,h,i,s,a,o)}_drawLine1px_horizontal(t,e,r,n,i,s,a){const o=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(r<0||r>=c)return;const x=255===a&&u>=1;let M=0;x&&(M=255<<24|s<<16|i<<8|n);const m=x?1:a/255*u,p=x?0:1-m;if(t>e){let r=t;t=e,e=r}if(t<0&&(t=0),e>=h&&(e=h-1),t>e)return;const g=4*(r*h+t);for(let a=t;a<=e;a++){const e=g+4*(a-t),c=r*h+a;if(f){const t=c>>3,e=7&c;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[c]=M;else{const t=o[e+3]/255*p,r=m+t;if(r<=0)continue;const a=1/r;o[e]=(n*m+o[e]*t)*a,o[e+1]=(i*m+o[e+1]*t)*a,o[e+2]=(s*m+o[e+2]*t)*a,o[e+3]=255*r}}}_drawLine1px_vertical(t,e,r,n,i,s,a){const o=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(t<0||t>=h)return;const x=255===a&&u>=1;let M=0;x&&(M=255<<24|s<<16|i<<8|n);const m=x?1:a/255*u,p=x?0:1-m;if(e>r){let t=e;e=r,r=t}if(e<0&&(e=0),r>=c&&(r=c-1),!(e>r))for(let a=e;a<=r;a++){const e=4*(a*h+t),r=a*h+t;if(f){const t=r>>3,e=7&r;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[r]=M;else{const t=o[e+3]/255*p,r=m+t;if(r<=0)continue;const a=1/r;o[e]=(n*m+o[e]*t)*a,o[e+1]=(i*m+o[e+1]*t)*a,o[e+2]=(s*m+o[e+2]*t)*a,o[e+3]=255*r}}}_drawLine1px_45degrees(t,e,r,n,i,s,a,o){const l=this.pixelRenderer.frameBufferUint8ClampedView,h=this.pixelRenderer.frameBufferUint32View,c=this.pixelRenderer.width,f=this.pixelRenderer.height,d=this.pixelRenderer.context.currentState,u=d?this.pixelRenderer.context.currentState.clippingMask:null,x=this.pixelRenderer.context.globalAlpha,M=255===o&&x>=1;let m=0;M&&(m=255<<24|a<<16|s<<8|i);const p=M?1:o/255*x,g=M?0:1-p,w=t<r?1:-1,R=e<n?1:-1;let y=t,S=e;for(;!(y<0&&w<0||y>=c&&w>0||S<0&&R<0||S>=f&&R>0);){if(y>=0&&y<c&&S>=0&&S<f){const t=4*(S*c+y),e=S*c+y;let r=!0;if(d){const t=e>>3,n=7&e;!(t>=u.length||0===u[t])&&u[t]&1<<7-n||(r=!1)}if(r)if(M)h[e]=m;else{const e=l[t+3]/255*g,r=p+e;if(r>0){const n=1/r;l[t]=(i*p+l[t]*e)*n,l[t+1]=(s*p+l[t+1]*e)*n,l[t+2]=(a*p+l[t+2]*e)*n,l[t+3]=255*r}}}if(y===r&&S===n)break;y+=w,S+=R}}_drawLine1px_genericOrientations(t,e,r,n,i,s,a,o,l,h){const c=this.pixelRenderer.frameBufferUint8ClampedView,f=this.pixelRenderer.frameBufferUint32View,d=this.pixelRenderer.width,u=this.pixelRenderer.height,x=this.pixelRenderer.context.currentState,M=x?this.pixelRenderer.context.currentState.clippingMask:null,m=this.pixelRenderer.context.globalAlpha,p=255===h&&m>=1;let g=0;p&&(g=255<<24|l<<16|o<<8|a);const w=p?1:h/255*m,R=p?0:1-w,y=t<r?1:-1,S=e<n?1:-1;let C=i-s;for(;;){if(t>=0&&t<d&&e>=0&&e<u){const r=4*(e*d+t),n=e*d+t;let i=!0;if(x){const t=n>>3,e=7&n;!(t>=M.length||0===M[t])&&M[t]&1<<7-e||(i=!1)}if(i)if(p)f[n]=g;else{const t=c[r+3]/255*R,e=w+t;if(e>0){const n=1/e;c[r]=(a*w+c[r]*t)*n,c[r+1]=(o*w+c[r+1]*t)*n,c[r+2]=(l*w+c[r+2]*t)*n,c[r+3]=255*e}}}if(t===r&&e===n)break;const h=2*C;h>-s&&(C-=s,t+=y),h<i&&(C+=i,e+=S)}}drawLineThick(t,e,r,n,i,s,a,o,l){this._drawLineThickPolygonScan(t,e,r,n,i,s,a,o,l)}_drawLineThickBoundingBox(t,e,r,n,i,s,a,o,l){const h=(r-=.5)-(t-=.5),c=(n-=.5)-(e-=.5),f=Math.sqrt(h*h+c*c);if(0===f)return;const d=-c/f,u=h/f,x=i/2,M=[[t+d*x,e+u*x],[t-d*x,e-u*x],[r+d*x,n+u*x],[r-d*x,n-u*x]],m=Math.floor(Math.min(...M.map((t=>t[0])))),p=Math.ceil(Math.max(...M.map((t=>t[0])))),g=Math.floor(Math.min(...M.map((t=>t[1])))),w=Math.ceil(Math.max(...M.map((t=>t[1]))));for(let r=g;r<=w;r++)for(let n=m;n<=p;n++){const i=n-t,d=r-e,u=(i*h+d*c)/f,M=i-h/f*u,m=d-c/f*u,p=Math.sqrt(M*M+m*m);u>=0&&u<=f&&p<=x&&this.pixelRenderer.setPixel(n,r,s,a,o,l)}}_drawLineThickModifiedBresenham(t,e,r,n,i,s,a,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),n=Math.floor(n-.5);const h=Math.abs(r-t),c=Math.abs(n-e),f=t<r?1:-1,d=e<n?1:-1;let u,x;const M=Math.sqrt(h*h+c*c);if(0===M){const r=Math.floor(i/2);for(let n=-r;n<=r;n++)for(let i=-r;i<=r;i++)this.pixelRenderer.setPixel(t+i,e+n,s,a,o,l);return}u=-c/M,x=h/M;const m=i/2;let p=h-c,g=t,w=e;for(;this._drawPerpendicularSegment(g,w,u,x,m,s,a,o,l),g!==r||w!==n;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,w+=d)}const R=(r-t)/M,y=(n-e)/M;this._drawSquareCap(t,e,u,x,m,-R,-y,s,a,o,l),this._drawSquareCap(r,n,u,x,m,R,y,s,a,o,l)}_drawPerpendicularSegment(t,e,r,n,i,s,a,o,l){const h=Math.ceil(i);this.pixelRenderer.setPixel(t,e,s,a,o,l);for(let c=1;c<=h;c++){const f=c/h*i,d=Math.round(t+r*f),u=Math.round(e+n*f),x=Math.round(t-r*f),M=Math.round(e-n*f);this.pixelRenderer.setPixel(d,u,s,a,o,l),this.pixelRenderer.setPixel(x,M,s,a,o,l)}}_drawSquareCap(t,e,r,n,i,s,a,o,l,h,c){const f=Math.ceil(i);for(let d=1;d<=f;d++){const u=d/f*i,x=Math.round(t+s*u),M=Math.round(e+a*u);this._drawPerpendicularSegment(x,M,r,n,i,o,l,h,c)}}_drawLineThickDistanceOptimized(t,e,r,n,i,s,a,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),n=Math.floor(n-.5);const h=Math.abs(r-t),c=Math.abs(n-e),f=t<r?1:-1,d=e<n?1:-1,u=Math.sqrt((r-t)**2+(n-e)**2);if(0===u){const r=Math.floor(i/2);for(let n=-r;n<=r;n++)for(let i=-r;i<=r;i++)this.pixelRenderer.setPixel(t+i,e+n,s,a,o,l);return}const x=-(n-e)/u,M=(r-t)/u,m=Math.floor(i/2);let p=h-c,g=t,w=e;const R=[];for(;R.push({x:g,y:w}),g!==r||w!==n;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,w+=d)}for(const t of R)for(let e=-m;e<=m;e++){const r=Math.round(t.x+x*e),n=Math.round(t.y+M*e);this.pixelRenderer.setPixel(r,n,s,a,o,l)}const y=-(r-t)/u,S=-(n-e)/u;for(let r=1;r<=m;r++){const n=Math.round(t+y*r),i=Math.round(e+S*r);for(let t=-m;t<=m;t++){const e=Math.round(n+x*t),r=Math.round(i+M*t);this.pixelRenderer.setPixel(e,r,s,a,o,l)}}const C=(r-t)/u,P=(n-e)/u;for(let t=1;t<=m;t++){const e=Math.round(r+C*t),i=Math.round(n+P*t);for(let t=-m;t<=m;t++){const r=Math.round(e+x*t),n=Math.round(i+M*t);this.pixelRenderer.setPixel(r,n,s,a,o,l)}}}_drawLineThickParallelOffset(t,e,r,n,i,s,a,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),n=Math.floor(n-.5);const h=Math.sqrt((r-t)**2+(n-e)**2);if(0===h){const r=Math.floor(i/2);for(let n=-r;n<=r;n++)for(let i=-r;i<=r;i++)this.pixelRenderer.setPixel(t+i,e+n,s,a,o,l);return}const c=-(n-e)/h,f=(r-t)/h,d=(r-t)/h,u=(n-e)/h,x=i/2,M=Math.ceil(x);for(let i=-M;i<=M;i++){const h=i/M*x,d=t+c*h,u=e+f*h,m=r+c*h,p=n+f*h;this._drawBresenhamLine(Math.round(d),Math.round(u),Math.round(m),Math.round(p),s,a,o,l)}for(let r=-M;r<=M;r++){const n=r/M*x;for(let r=1;r<=x;r++){const i=Math.round(t-d*r+c*n),h=Math.round(e-u*r+f*n);this.pixelRenderer.setPixel(i,h,s,a,o,l)}}for(let t=-M;t<=M;t++){const e=t/M*x;for(let t=1;t<=x;t++){const i=Math.round(r+d*t+c*e),h=Math.round(n+u*t+f*e);this.pixelRenderer.setPixel(i,h,s,a,o,l)}}}_drawBresenhamLine(t,e,r,n,i,s,a,o){const l=Math.abs(r-t),h=Math.abs(n-e),c=t<r?1:-1,f=e<n?1:-1;let d=l-h;for(;this.pixelRenderer.setPixel(t,e,i,s,a,o),t!==r||e!==n;){const r=2*d;r>-h&&(d-=h,t+=c),r<l&&(d+=l,e+=f)}}_drawLineThickPolygonScan(t,e,r,n,i,s,a,o,l){const h=r-t,c=n-e,f=Math.sqrt(h*h+c*c),d=this._pixelRuns;if(d.length=0,0===f){const r=i>>1,n=0|t,h=0|e;for(let t=-r;t<=r;t++)d.push(n-r,h+t,1+(r<<1));return void this.pixelRenderer.setPixelRuns(d,s,a,o,l)}const u=1/f,x=-c*u,M=h*u,m=.5*i,p=this._corners,g=x*m,w=M*m;p[0].x=t+g,p[0].y=e+w,p[1].x=t-g,p[1].y=e-w,p[2].x=r-g,p[2].y=n-w,p[3].x=r+g,p[3].y=n+w;const R=0|Math.min(p[0].y,p[1].y,p[2].y,p[3].y),y=Math.max(p[0].y,p[1].y,p[2].y,p[3].y)+.999|0,S=this._edges;for(let t=0;t<4;t++){const e=S[t],r=p[t],n=p[t+1&3];e.p1=r,e.p2=n,r.y!==n.y&&(e.invDeltaY=1/(n.y-r.y),e.deltaX=n.x-r.x)}const C=this._intersections;for(let t=R;t<=y;t++){let e=0;for(let r=0;r<4;r++){const n=S[r],i=n.p1,s=n.p2;if(i.y!==s.y&&(t>=i.y&&t<s.y||t>=s.y&&t<i.y)){const r=(t-i.y)*n.invDeltaY;C[e++]=i.x+r*n.deltaX}}if(1===e){const e=0|C[0];d.push(e,t,1)}else if(2===e){const e=C[0],r=C[1],n=e<r?0|e:0|r,i=(e>r?e+.999|0:r+.999|0)-n;i>0&&d.push(n,t,i)}}d.length>0&&this.pixelRenderer.setPixelRuns(d,s,a,o,l)}}class SWRendererRect{constructor(t,e,r,n,i,s){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=n,this.lineRenderer=i,this.pixelRenderer=s}drawRect(t){if(t.clippingOnly){if(isNearMultipleOf90Degrees(t.rotation)){const{adjustedWidth:e,adjustedHeight:r}=getRotatedDimensionsIfTheCase(t.width,t.height,t.rotation);this.drawAxisAlignedRect(t.center.x,t.center.y,e,r,!0)}else this.drawRotatedRect(t.center.x,t.center.y,t.width,t.height,t.rotation,!0);return}const{center:e,width:r,height:n,rotation:i,clippingOnly:s,strokeWidth:a,strokeColor:{r:o,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:x}}=t;if(isNearMultipleOf90Degrees(i)){const{adjustedWidth:t,adjustedHeight:M}=getRotatedDimensionsIfTheCase(r,n,i);this.drawAxisAlignedRect(e.x,e.y,t,M,s,a,o,l,h,c,f,d,u,x)}else this.drawRotatedRect(e.x,e.y,r,n,i,s,a,o,l,h,c,f,d,u,x)}clearRect(t){const e=t.center,r=t.width,n=t.height,i=t.rotation;if(isNearMultipleOf90Degrees(i)){const{adjustedWidth:t,adjustedHeight:s}=getRotatedDimensionsIfTheCase(r,n,i);if(t===this.width&&s===this.height&&e.x===t/2&&e.y===s/2)return void this.frameBufferUint8ClampedView.fill(0);this.clearAxisAlignedRect(e.x,e.y,t,s)}else this.fillRotatedRect(e.x,e.y,r,n,i,!1,!0)}drawRotatedRect(t,e,r,n,i,s,a,o,l,h,c,f,d,u,x){const M=Math.cos(i),m=Math.sin(i);if((s||x>0)&&this.fillRotatedRect(t,e,r,n,i,s,!1,f,d,u,x),!s&&c>0){const i=r/2,s=n/2,f=[[-i,-s],[i,-s],[i,s],[-i,s]].map((([r,n])=>({x:t+r*M-n*m,y:e+r*m+n*M})));if(1===a)for(let t=0;t<4;t++){const e=f[t],r=f[(t+1)%4];this.lineRenderer.drawLine1px(e.x,e.y,r.x,r.y,o,l,h,c)}else{const t=a/2;for(let e=0;e<4;e+=2){const r=extendLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,a,o,l,h,c)}for(let e=1;e<4;e+=2){const r=shortenLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,a,o,l,h,c)}}}}drawAxisAlignedRect(t,e,r,n,i,s,a,o,l,h,c,f,d,u){if(i&&(s=0),i||u>0){let a=null;if(a=255==h&&s>0?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,n)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,n)),i){for(let t=Math.floor(a.y);t<Math.ceil(a.y+a.h);t++)for(let e=Math.floor(a.x);e<Math.ceil(a.x+a.w);e++)this.pixelRenderer.clipPixel(e,t);return}const o=this.pixelRenderer.context.globalAlpha,l=255===u&&o>=1;let x=0;l&&(x=255<<24|d<<16|f<<8|c);for(let t=Math.floor(a.y);t<Math.ceil(a.y+a.h);t++)for(let e=Math.floor(a.x);e<Math.ceil(a.x+a.w);e++){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,n=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-n))continue}l?this.frameBufferUint32View[r]=x:this.pixelRenderer.setPixel(e,t,c,f,d,u)}}if(h>0&&s>0){let i=getRectangularStrokeGeometry(t,e,r,n);const c=s/2;for(let t=Math.floor(i.x-c);t<i.x+i.w+c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(t,i.y+e,a,o,l,h),this.pixelRenderer.setPixel(t,i.y+i.h+e,a,o,l,h);for(let t=Math.floor(i.y+c);t<i.y+i.h-c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(i.x+e,t,a,o,l,h),this.pixelRenderer.setPixel(i.x+i.w+e,t,a,o,l,h)}}clearAxisAlignedRect(t,e,r,n){t=Math.round(t),e=Math.round(e),r=Math.round(r),n=Math.round(n);const i=t-Math.floor(r/2),s=e-Math.floor(n/2),a=i+r,o=s+n;for(let t=s;t<o;t++)for(let e=i;e<a;e++)this.pixelRenderer.clearPixel(e,t)}fillRotatedRect(t,e,r,n,i,s,a,o,l,h,c){const f=Math.cos(i),d=Math.sin(i),u=r/2,x=n/2,M=[{x:t+u*f-x*d,y:e+u*d+x*f},{x:t+u*f+x*d,y:e+u*d-x*f},{x:t-u*f+x*d,y:e-u*d-x*f},{x:t-u*f-x*d,y:e-u*d+x*f}],m=[];for(let t=0;t<4;t++){const e=M[t],r=M[(t+1)%4],n=r.y-e.y,i=e.x-r.x,s=r.x*e.y-e.x*r.y;m.push({a:n,b:i,c:s})}const p=Math.floor(Math.min(...M.map((t=>t.x)))),g=Math.ceil(Math.max(...M.map((t=>t.x)))),w=Math.floor(Math.min(...M.map((t=>t.y)))),R=Math.ceil(Math.max(...M.map((t=>t.y)))),y=this.pixelRenderer.context.globalAlpha;if(s)for(let t=w;t<=R;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clipPixel(e,t)}else if(a)for(let t=w;t<=R;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clearPixel(e,t)}else{const t=255===c&&y>=1;let e=0;t&&(e=255<<24|h<<16|l<<8|o);for(let r=w;r<=R;r++)for(let n=p;n<=g;n++){if(m.every((t=>t.a*n+t.b*r+t.c>=0))){if(n<0||n>=this.width||r<0||r>=this.height)continue;const i=r*this.width+n;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=i>>3,r=7&i;if(0===t[e])continue;if(!(t[e]&1<<7-r))continue}t?this.frameBufferUint32View[i]=e:this.pixelRenderer.setPixel(n,r,o,l,h,c)}}}}}class SWRendererArc{constructor(t){this.pixelRenderer=t}drawArc(t){const{center:e,radius:r,startAngle:n,endAngle:i,strokeWidth:s,strokeColor:{r:a,g:o,b:l,a:h},fillColor:{r:c,g:f,b:d,a:u}}=t;u>0&&this.drawArcHelper(e.x,e.y,r,n,i,c,f,d,u,!0),h>0&&s>0&&this.drawArcHelper(e.x,e.y,r,n,i,a,o,l,h,!1,s)}drawArcHelper(t,e,r,n,i,s,a,o,l,h=!1,c=1){function f(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<n&&(r+=2*Math.PI),r>=n&&r<=i}if(n=n%360*Math.PI/180,(i=i%360*Math.PI/180)<n&&(i+=2*Math.PI),c>1&&(c*=.75),t-=1,e-=1,h){const n=(r-.5)*(r-.5);for(let i=-r;i<=r;i++)for(let h=-r;h<=r;h++)h*h+i*i<=n&&f(h,i)&&this.pixelRenderer.setPixel(Math.round(t+h),Math.round(e+i),Math.round(s),a,o,l)}if(!h||c>0){const h=new Set;let d=0,u=r,x=3-2*r;for(;u>=d;){[[d,u],[-d,u],[d,-u],[-d,-u],[u,d],[-u,d],[u,-d],[-u,-d]].forEach((([r,s])=>{f(r,s)&&this.addThickArcPoint(h,t,e,t+r,e+s,c,n,i)})),d++,x>0?(u--,x=x+4*(d-u)+10):x=x+4*d+6}for(let t of h){const[e,r]=t.split(",").map(Number);this.pixelRenderer.setPixel(e,r,s,a,o,l)}}}drawArcHQ(t){const{center:e,radius:r,startAngle:n,endAngle:i,strokeWidth:s,strokeColor:{r:a,g:o,b:l,a:h},fillColor:{r:c,g:f,b:d,a:u}}=t;e.x-=.5,e.y-=.5,u>0&&this.drawArcHQHelper(e.x,e.y,r,n,i,c,f,d,u,!0),h>0&&s>0&&this.drawArcHQHelper(e.x,e.y,r,n,i,a,o,l,h,!1,s)}drawArcHQHelper(t,e,r,n,i,s,a,o,l,h=!1,c=1){n=n%360*Math.PI/180,(i=i%360*Math.PI/180)<n&&(i+=2*Math.PI),c*=.5,t-=.5,e-=.5,r=Math.floor(r)+.5,t=Math.round(t),e=Math.round(e);const f=Math.floor(t-r-c),d=Math.ceil(t+r+c),u=Math.floor(e-r-c),x=Math.ceil(e+r+c);function M(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<n&&(r+=2*Math.PI),r>=n&&r<=i}const m=r*r;if(h)for(let r=u;r<=x;r++)for(let n=f;n<=d;n++){const i=n-t,h=r-e;i*i+h*h<=m&&M(i,h)&&this.pixelRenderer.setPixel(n,r,s,a,o,l)}if(c>0)for(let n=u;n<=x;n++)for(let i=f;i<=d;i++){const h=i-t,f=n-e,d=h*h+f*f;Math.abs(Math.sqrt(d)-r)<=c&&M(h,f)&&this.pixelRenderer.setPixel(i,n,s,a,o,l)}}addStrokePixel(t,e,r){t.add(`${e},${r}`)}addThickPoint(t,e,r,n){const i=Math.floor(n/2);for(let s=-i;s<n-i;s++)for(let a=-i;a<n-i;a++)this.addStrokePixel(t,Math.round(e+a),Math.round(r+s))}addThickArcPoint(t,e,r,n,i,s,a,o){const l=Math.floor(s/2);for(let h=-l;h<s-l;h++)for(let c=-l;c<s-l;c++){const s=n+c,l=i+h;let f=Math.atan2(l-r,s-e);f<0&&(f+=2*Math.PI),f<a&&(f+=2*Math.PI),f>=a&&f<=o&&t.add(`${Math.round(s)},${Math.round(l)}`)}}}class SWRendererCircle{constructor(t){this.pixelRenderer=t}drawCircle(t){const{center:e,radius:r,strokeWidth:n,strokeColor:{r:i,g:s,b:a,a:o},fillColor:{r:l,g:h,b:c,a:f}}=t,d=f>0;if(!d&&(1===n&&o>0)){return void(255===o&&this.pixelRenderer.context.globalAlpha>=1?this.draw1PxStrokeFullCircleBresenhamOpaque(e.x,e.y,r,i,s,a):this.draw1PxStrokeFullCircleBresenhamAlpha(e.x,e.y,r,i,s,a,o))}const u=n>0&&o>0,x=255===f&&this.pixelRenderer.context.globalAlpha>=1;if(d&&!u&&x)return void this.drawOpaqueFillFullCircleBresenham(e.x,e.y,r,l,h,c);if(d&&!u&&!x)return void this.drawSemiTransparentFillFullCircleBresenham(e.x,e.y,r,l,h,c,f);const M=n>0?r-n/2:r,m=r+n/2;this.drawFullCircleFast(e.x,e.y,M,m,l,h,c,f,i,s,a,o)}drawFullCircleSlow(t,e,r,n,i,s,a,o,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-n-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+n+1)),m=Math.max(0,Math.floor(d-n-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+n+1)),g=(r+n)/2,w=g*g,R=o>0,y=f>0&&n>r;if(R&&!y)for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const n=Math.sqrt(r),l=Math.max(m,Math.ceil(d-n+1e-4)),h=Math.min(p,Math.floor(d+n-1e-4));for(let e=l;e<=h;e++)this.pixelRenderer.setPixel(e,t,i,s,a,o)}else if(y&&!R){const t=n*n,e=r*r;for(let n=x;n<=M;n++){const i=n-u,s=i*i;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),x=Math.min(p,Math.floor(d+a));if(r<=0||s>e)for(let t=o;t<=x;t++)this.pixelRenderer.setPixel(t,n,l,h,c,f);else{const t=Math.sqrt(e-s),r=Math.min(x,Math.floor(d-t)),i=Math.max(o,Math.ceil(d+t));for(let t=o;t<=r;t++)this.pixelRenderer.setPixel(t,n,l,h,c,f);for(let t=i;t<=x;t++)this.pixelRenderer.setPixel(t,n,l,h,c,f)}}}else if(R&&y){const t=n*n,e=r*r;for(let n=x;n<=M;n++){const x=n-u,M=x*x;if(M>t)continue;const g=Math.sqrt(t-M),R=Math.max(m,Math.ceil(d-g)),y=Math.min(p,Math.floor(d+g));let S=-1,C=-1;if(r>0&&M<=e){const t=Math.sqrt(e-M);S=Math.min(y,Math.floor(d-t)),C=Math.max(R,Math.ceil(d+t))}const P=w-M;let k=-1,b=-1;if(P>=0){const t=Math.sqrt(P);k=Math.max(m,Math.ceil(d-t+1e-4)),b=Math.min(p,Math.floor(d+t-1e-4))}if(k>=0)for(let t=k;t<=b;t++)this.pixelRenderer.setPixel(t,n,i,s,a,o);if(r<=0||M>e)for(let t=R;t<=y;t++)this.pixelRenderer.setPixel(t,n,l,h,c,f);else{for(let t=R;t<=S;t++)this.pixelRenderer.setPixel(t,n,l,h,c,f);for(let t=C;t<=y;t++)this.pixelRenderer.setPixel(t,n,l,h,c,f)}}}}drawFullCircleFast(t,e,r,n,i,s,a,o,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-n-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+n+1)),m=Math.max(0,Math.floor(d-n-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+n+1)),g=(r+n)/2,w=g*g,R=o>0,y=f>0&&n>r,S=[],C=[];if(R&&!y){for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const n=Math.sqrt(r),i=Math.max(m,Math.ceil(d-n+1e-4)),s=Math.min(p,Math.floor(d+n-1e-4))-i+1;s>0&&S.push(i,t,s)}S.length>0&&this.pixelRenderer.setPixelRuns(S,i,s,a,o)}else if(y&&!R){const t=n*n,e=r*r;for(let n=x;n<=M;n++){const i=n-u,s=i*i;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));if(r<=0||s>e){const t=l-o+1;t>0&&C.push(o,n,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),i=Math.max(o,Math.ceil(d+t)),a=r-o+1;a>0&&C.push(o,n,a);const h=l-i+1;h>0&&C.push(i,n,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(R&&y){const t=n*n,e=r*r;for(let n=x;n<=M;n++){const i=n-u,s=i*i;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=w-s;let x=-1,M=-1;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4))}if(x>=0){const t=M-x+1;t>0&&S.push(x,n,t)}if(r<=0||s>e){const t=l-o+1;t>0&&C.push(o,n,t)}else{const t=h-o+1;t>0&&C.push(o,n,t);const e=l-c+1;e>0&&C.push(c,n,e)}}S.length>0&&this.pixelRenderer.setPixelRuns(S,i,s,a,o),C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}}drawFullCircleFastest(t,e,r,n,i,s,a,o,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-n-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+n+1)),m=Math.max(0,Math.floor(d-n-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+n+1)),g=(r+n)/2,w=g*g,R=o>0,y=f>0&&n>r,S=[],C=[],P=[];if(R&&!y){for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const n=Math.sqrt(r),i=Math.max(m,Math.ceil(d-n+1e-4)),s=Math.min(p,Math.floor(d+n-1e-4))-i+1;s>0&&S.push(i,t,s)}S.length>0&&this.pixelRenderer.setPixelRuns(S,i,s,a,o)}else if(y&&!R){const t=n*n,e=r*r;for(let n=x;n<=M;n++){const i=n-u,s=i*i;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));if(r<=0||s>e){const t=l-o+1;t>0&&C.push(o,n,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),i=Math.max(o,Math.ceil(d+t)),a=r-o+1;a>0&&C.push(o,n,a);const h=l-i+1;h>0&&C.push(i,n,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(R&&y){const t=n*n,e=r*r;for(let n=x;n<=M;n++){const i=n-u,s=i*i;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=w-s;let x=-1,M=-1,g=0;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4)),g=M-x+1}let R=-1,y=0,S=-1,C=0;r<0||s>e?(R=o,y=l-o+1):(R=o,y=h-o+1,S=c,C=l-c+1),P.push(g>0?x:-1,g>0?g:-1,y>0?R:-1,y>0?y:-1,C>0?S:-1,C>0?C:-1)}P.length>0&&this.pixelRenderer.setPixelFillAndStrokeRuns(x,P,i,s,a,o,l,h,c,f)}}draw1PxStrokeFullCircleBresenhamOpaque(t,e,r,n,i,s){const a=this.pixelRenderer;if(!a)return void console.error("Pixel renderer not found!");const o=a.width,l=a.height,h=(a.frameBufferUint8ClampedView,a.frameBufferUint32View),c=a.context,f=c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|i<<8|n,u=r,x=Math.floor(t),M=Math.floor(e),m=Math.floor(u);if(m<0)return;if(0===m){if(u>=0){const r=Math.round(t),o=Math.round(e);a.setPixel(r,o,n,i,s,255)}return}let p=0,g=0;u>0&&2*u%2==1&&(p=1,g=1);if(x+m<0||x-m-p>=o||M+m<0||M-m-g>=l)return;let w=0,R=m,y=3-2*m;for(;w<=R;){const t=x+w,e=M+R,r=x+R,n=M+w,i=x+R,s=M-w-g,a=x+w,c=M-R-g,u=x-w-p,m=M-R-g,S=x-R-p,C=M-w-g,P=x-R-p,k=M+w,b=x-w-p,A=M+R;if(t>=0&&t<o&&e>=0&&e<l){const r=e*o+t;(!f||0!==f[r>>3]&&f[r>>3]&1<<7-(7&r))&&(h[r]=d)}if(r>=0&&r<o&&n>=0&&n<l&&w!==R){const t=n*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(i>=0&&i<o&&s>=0&&s<l){const t=s*o+i;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(a>=0&&a<o&&c>=0&&c<l){const t=c*o+a;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(u>=0&&u<o&&m>=0&&m<l){const t=m*o+u;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(S>=0&&S<o&&C>=0&&C<l&&w!==R){const t=C*o+S;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(P>=0&&P<o&&k>=0&&k<l){const t=k*o+P;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(b>=0&&b<o&&A>=0&&A<l){const t=A*o+b;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}y<0?y=y+4*w+6:(y=y+4*(w-R)+10,R--),w++}}draw1PxStrokeFullCircleBresenhamAlpha(t,e,r,n,i,s,a){const o=this.pixelRenderer;if(!o)return void console.error("Pixel renderer not found!");const l=o.context.globalAlpha;if(0===a||l<=0)return;const h=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d.currentState?d.currentState.clippingMask:null,x=a/255*l,M=1-x;if(x<=0)return;const m=r,p=Math.floor(t),g=Math.floor(e),w=Math.floor(m);if(w<0)return;if(0===w){if(m>=0){const r=Math.round(t),l=Math.round(e);o.setPixel(r,l,n,i,s,a)}return}let R=0,y=0;m>0&&2*m%2==1&&(R=1,y=1);if(p+w<0||p-w-R>=h||g+w<0||g-w-y>=c)return;let S=0,C=w,P=3-2*w;const k=new Set;for(;S<=C;){const t=p+S,e=g+C,r=p+C,n=g+S,i=p+C,s=g-S-y,a=p+S,o=g-C-y,l=p-S-R,f=g-C-y,d=p-C-R,u=g-S-y,x=p-C-R,M=g+S,m=p-S-R,w=g+C;t>=0&&t<h&&e>=0&&e<c&&k.add(e*h+t),r>=0&&r<h&&n>=0&&n<c&&k.add(n*h+r),i>=0&&i<h&&s>=0&&s<c&&k.add(s*h+i),a>=0&&a<h&&o>=0&&o<c&&k.add(o*h+a),l>=0&&l<h&&f>=0&&f<c&&k.add(f*h+l),d>=0&&d<h&&u>=0&&u<c&&k.add(u*h+d),x>=0&&x<h&&M>=0&&M<c&&k.add(M*h+x),m>=0&&m<h&&w>=0&&w<c&&k.add(w*h+m),P<0?P=P+4*S+6:(P=P+4*(S-C)+10,C--),S++}if(k.size>0)for(const t of k){const e=4*t;let r=!1;if(u){const e=t>>3,n=7&t;0!==u[e]&&u[e]&1<<7-n||(r=!0)}if(!r){const t=f[e+3]/255*M,r=x+t;if(r>0){const a=1/r;f[e]=(n*x+f[e]*t)*a,f[e+1]=(i*x+f[e+1]*t)*a,f[e+2]=(s*x+f[e+2]*t)*a,f[e+3]=255*r}}}}_generateRelativeHorizontalExtentsBresenham(t){const e=t,r=Math.floor(e);if(r<0)return null;let n=0,i=0;if(e>0&&2*e%2==1&&(n=1,i=1),0===r)return{relativeExtents:[0],intRadius:0,xOffset:n,yOffset:i};const s=new Array(r+1).fill(0);let a=0,o=r,l=3-2*r;for(;a<=o;)s[o]=Math.max(s[o],a),s[a]=Math.max(s[a],o),l<0?l=l+4*a+6:(l=l+4*(a-o)+10,o--),a++;return{relativeExtents:s,intRadius:r,xOffset:n,yOffset:i}}drawOpaqueFillFullCircleBresenham(t,e,r,n,i,s){const a=this.pixelRenderer;if(!a)return void console.error("Pixel renderer not found!");const o=a.width,l=a.height,h=(a.frameBufferUint8ClampedView,a.frameBufferUint32View),c=a.context,f=c&&c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|i<<8|n,u=this._generateRelativeHorizontalExtentsBresenham(r);if(!u)return;const{relativeExtents:x,intRadius:M,xOffset:m,yOffset:p}=u;if(0===M&&r>=0){const r=Math.round(t),n=Math.round(e);if(r>=0&&r<o&&n>=0&&n<l){const t=n*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}return}const g=Math.floor(t-.5),w=Math.floor(e-.5),R=x[0];if(!(g+R<0||g-R-m>=o||w+M<0||w-M-p>=l))if(f)for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,n=g+e,i=w+t,s=w-t-p+1;if(i>=0&&i<l){const t=Math.max(0,r),e=i*o+Math.min(o-1,n);let s=i*o+t;for(;s<=e;){const t=s>>3,r=7&s;if(0===r&&s+7<=e){const e=f[t];if(255===e){const t=s+7;for(;s<=t;)h[s]=d,s++;continue}if(0===e){s+=8;continue}}const n=1<<7-r;0!==(f[t]&n)&&(h[s]=d),s++}}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){const t=Math.max(0,r),e=s*o+Math.min(o-1,n);let i=s*o+t;for(;i<=e;){const t=i>>3,r=7&i;if(0===r&&i+7<=e){const e=f[t];if(255===e){const t=i+7;for(;i<=t;)h[i]=d,i++;continue}if(0===e){i+=8;continue}}const n=1<<7-r;0!==(f[t]&n)&&(h[i]=d),i++}}}else for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,n=g+e,i=w+t,s=w-t-p+1;if(i>=0&&i<l){let t=i*o+Math.max(0,r);const e=i*o+Math.min(o-1,n);for(;t<=e;)h[t]=d,t++}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){let t=s*o+Math.max(0,r);const e=s*o+Math.min(o-1,n);for(;t<=e;)h[t]=d,t++}}}drawSemiTransparentFillFullCircleBresenham(t,e,r,n,i,s,a){const o=this.pixelRenderer;if(!o)return void console.error("Pixel renderer not found!");const l=o.context.globalAlpha;if(0===a||l<=0)return;const h=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d&&d.currentState?d.currentState.clippingMask:null,x=a/255*l,M=1-x;if(x<=0)return;const m=this._generateRelativeHorizontalExtentsBresenham(r);if(!m)return;const{relativeExtents:p,intRadius:g,xOffset:w,yOffset:R}=m;if(0===g&&r>=0){const r=Math.round(t),l=Math.round(e);return void o.setPixel(r,l,n,i,s,a)}const y=Math.floor(t-.5),S=Math.floor(e-.5),C=p[0];if(y+C<0||y-C-w>=h||S+g<0||S-g-R>=c)return;const P=t=>{const e=4*t,r=f[e+3]/255*M,a=x+r;if(a>0){const t=1/a;f[e]=(n*x+f[e]*r)*t,f[e+1]=(i*x+f[e+1]*r)*t,f[e+2]=(s*x+f[e+2]*r)*t,f[e+3]=255*a}};if(u)for(let t=0;t<=g;t++){const e=p[t],r=y-e-w+1,n=y+e,i=S+t,s=S-t-R+1;if(i>=0&&i<c){const t=Math.max(0,r),e=i*h+Math.min(h-1,n);let s=i*h+t;for(;s<=e;){const t=s>>3,r=7&s,n=1<<7-r;if(0===r&&s+7<=e){if(0===u[t]){s+=8;continue}}0!==(u[t]&n)&&P(s),s++}}if(t>0&&!(1===t&&0===R)&&s>=0&&s<c){const t=Math.max(0,r),e=s*h+Math.min(h-1,n);let i=s*h+t;for(;i<=e;){const t=i>>3,r=7&i,n=1<<7-r;if(0===r&&i+7<=e){if(0===u[t]){i+=8;continue}}0!==(u[t]&n)&&P(i),i++}}}else for(let t=0;t<=g;t++){const e=p[t],r=y-e-w+1,n=y+e,i=S+t,s=S-t-R+1;if(i>=0&&i<c){let t=i*h+Math.max(0,r);const e=i*h+Math.min(h-1,n);for(;t<=e;)P(t),t++}if(t>0&&!(1===t&&0===R)&&s>=0&&s<c){let t=s*h+Math.max(0,r);const e=s*h+Math.min(h-1,n);for(;t<=e;)P(t),t++}}}}class SWRendererRoundedRect{constructor(t,e,r,n,i,s,a){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=n,this.lineRenderer=i,this.pixelRenderer=s,this.swRectRenderer=a}drawRoundedRect(t){const{center:e,width:r,height:n,radius:i,rotation:s,strokeWidth:a,strokeColor:{r:o,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:x}}=t;if(isNearMultipleOf90Degrees(s)){const{adjustedWidth:t,adjustedHeight:M}=getRotatedDimensionsIfTheCase(r,n,s),m=i>2?i-1:i;0==a||255===c||a<5&&255===c?this.drawCrispAxisAlignedRoundedRectThinOpaqueStroke(e.x,e.y,t,M,m,a,o,l,h,c,f,d,u,x):this.drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(e.x,e.y,t,M,m,a,o,l,h,c,f,d,u,x)}else this.drawRotatedRoundedRect(e.x,e.y,r,n,i,s,a,o,l,h,c,f,d,u,x)}drawCrispAxisAlignedRoundedRectThinOpaqueStroke(t,e,r,n,i,s,a,o,l,h,c,f,d,u){if(r%1!=0||n%1!=0)throw new Error("Width and height must be integers");if(u>0&&this.drawRoundedRectFill(t,e,r,n,i,s,c,f,d,u,255==h&&s>0),h>0&&s>0)if(1===s){let s=getRectangularStrokeGeometry(t,e,r,n),c=Math.round(Math.min(i,Math.min(s.w,s.h)/2));for(let t=Math.floor(s.x+c);t<s.x+s.w-c;t++)this.pixelRenderer.setPixel(t,s.y-.5,a,o,l,h),this.pixelRenderer.setPixel(t,s.y+s.h-.5,a,o,l,h);for(let t=Math.floor(s.y+c);t<s.y+s.h-c;t++)this.pixelRenderer.setPixel(s.x-.5,t,a,o,l,h),this.pixelRenderer.setPixel(s.x+s.w-.5,t,a,o,l,h);const f=(t,e,r,n)=>{for(let i=r;i<=n;i+=Math.PI/180){const r=c-.5,n=t+r*Math.cos(i),s=e+r*Math.sin(i);this.pixelRenderer.setPixel(Math.floor(n),Math.floor(s),a,o,l,h)}};f(s.x+c,s.y+c,Math.PI,3*Math.PI/2),f(s.x+s.w-c,s.y+c,3*Math.PI/2,2*Math.PI),f(s.x+s.w-c,s.y+s.h-c,0,Math.PI/2),f(s.x+c,s.y+s.h-c,Math.PI/2,Math.PI)}else this.drawRoundedRectStroke(t,e,r,n,i,s,a,o,l,h)}drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(t,e,r,n,i,s,a,o,l,h,c,f,d,u){if(r%1!=0||n%1!=0)throw new Error("Width and height must be integers");u>0&&this.drawRoundedRectFill(t,e,r,n,i,s,c,f,d,u,255==h&&s>0),h>0&&s>0&&this.drawRoundedRectStroke(t,e,r,n,i,s,a,o,l,h)}drawRoundedRectFill(t,e,r,n,i,s,a,o,l,h,c=!1){let f=null;f=c?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,n)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,n));let d=Math.round(Math.min(i,Math.min(f.w,f.h)/2));function u(t,e){if(t>=f.x+d&&t<f.x+f.w-d&&e>=f.y&&e<f.y+f.h)return!0;if(t>=f.x&&t<f.x+f.w&&e>=f.y+d&&e<f.y+f.h-d)return!0;const r=[{x:f.x+d,y:f.y+d},{x:f.x+f.w-d,y:f.y+d},{x:f.x+f.w-d,y:f.y+f.h-d},{x:f.x+d,y:f.y+f.h-d}];for(const n of r){const r=t-n.x+1,i=e-n.y+1;if(r*r+i*i<d*d)return!0}return!1}const x=this.pixelRenderer.context.globalAlpha,M=255===h&&x>=1;let m=0;M&&(m=255<<24|l<<16|o<<8|a);for(let t=Math.floor(f.y);t<=Math.ceil(f.y+f.h);t++)for(let e=Math.floor(f.x);e<=Math.ceil(f.x+f.w);e++)if(u(Math.ceil(e),Math.ceil(t))){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,n=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-n))continue}M?this.frameBufferUint32View[r]=m:this.pixelRenderer.setPixel(e,t,a,o,l,h)}}drawRoundedRectStroke(t,e,r,n,i,s,a,o,l,h){const c=s/2;let f=getRectangularStrokeGeometry(t,e,r,n),d=Math.round(Math.min(i,Math.min(f.w,f.h)/2));const u=new PixelSet(this.pixelRenderer),x=new ScanlineSpans;for(let t=f.y-c;t<f.y+c;t++)x.addSpan(t,f.x+d,f.x+f.w-d);for(let t=f.y+f.h-c;t<f.y+f.h+c;t++)x.addSpan(t,f.x+d,f.x+f.w-d);x.addToPixelSet(u,a,o,l,h);const M=new ScanlineSpans,m=new ScanlineSpans;for(let t=f.y+d;t<f.y+f.h-d;t++){for(let e=f.x-c;e<f.x+c;e++)M.addPixel(e,t);for(let e=f.x+f.w-c;e<f.x+f.w+c;e++)m.addPixel(e,t)}M.addToPixelSet(u,a,o,l,h),m.addToPixelSet(u,a,o,l,h);const p=(t,e,r,n)=>{const i=new ScanlineSpans,s=Math.PI/180;for(let a=r;a<=n;a+=s)for(let r=-c;r<c;r++){const n=d+r,s=t+n*Math.cos(a),o=e+n*Math.sin(a);i.addPixel(Math.floor(s),Math.floor(o))}i.addToPixelSet(u,a,o,l,h)};p(f.x+d,f.y+d,Math.PI,3*Math.PI/2),p(f.x+f.w-d,f.y+d,3*Math.PI/2,2*Math.PI),p(f.x+f.w-d,f.y+f.h-d,0,Math.PI/2),p(f.x+d,f.y+f.h-d,Math.PI/2,Math.PI),u.paint()}drawRotatedRoundedRect(t,e,r,n,i,s,a,o,l,h,c,f,d,u,x){const M=Math.cos(s),m=Math.sin(s),p=r/2,g=n/2,w=[[-p+i,-g+i],[p-i,-g+i],[p-i,g-i],[-p+i,g-i]].map((([r,n])=>({x:t+r*M-n*m,y:e+r*m+n*M}))),R=w.map(((t,e)=>{const r=w[(e+1)%4],n=r.x-t.x,i=r.y-t.y,s=Math.sqrt(n*n+i*i);return{dx:n/s,dy:i/s}})),y=w.map(((t,e)=>{const r=R[(e+3)%4],n=R[e],s=-r.dy,a=r.dx,o=-n.dy,l=n.dx;return{start:{x:t.x-i*s,y:t.y-i*a},end:{x:t.x-i*o,y:t.y-i*l}}}));if(x>0){this.swRectRenderer.fillRotatedRect(t,e,r-2*i,n-2*i,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+-i*m,e+(-n/2+i/2)*M,r-2*i,i,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+(r/2-i/2)*M,e+(r/2-i/2)*m,i,n-2*i,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+i*m,e+(n/2-i/2)*M,r-2*i,i,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+(-r/2+i/2)*M,e+(-r/2+i/2)*m,i,n-2*i,s,!1,!1,f,d,u,x);const a=180*s/Math.PI;w.forEach(((t,e)=>{const r=[[180,270],[270,360],[0,90],[90,180]][e],n=(r[0]+a)%360,s=(r[1]+a)%360;drawArcSWHelper(t.x,t.y,i,n,s,f,d,u,x,!0)}))}if(c>0){for(let t=0;t<4;t++){const e=y[t],r=y[(t+1)%4];this.lineRenderer.drawLineThick(e.end.x,e.end.y,r.start.x,r.start.y,a,o,l,h,c)}const t=180*s/Math.PI;w.forEach(((e,r)=>{const n=[[180,270],[270,360],[0,90],[90,180]][r],s=(n[0]+t)%360,f=(n[1]+t)%360;drawArcSWHelper(e.x,e.y,i,s,f,o,l,h,c,!1,a)}))}}}class CrispSwCanvas{static version="1.0.2";constructor(t,e){if("object"==typeof t){const e=t;this.width=e.width,this.height=e.height,this.title=e.title||""}else this.width=t,this.height=e,this.title="";this._context=new CrispSwContext(this)}getContext(t){if("2d"!==t)throw new Error("Only '2d' context is supported");return this._context}}const isNode="undefined"==typeof window&&"undefined"!=typeof process;class CrispSwContext{constructor(t){this.canvas=t,t.title||(t.title=""),this.displayCanvas={width:t.width,height:t.height,title:t.title},this.title=t.title,this.stateStack=[new ContextState(t.width,t.height)],this.frameBufferUint8ClampedView=new Uint8ClampedArray(t.width*t.height*4).fill(0),this.frameBufferUint32View=new Uint32Array(this.frameBufferUint8ClampedView.buffer),this.tempClippingMask=new Uint8Array(Math.ceil(t.width*t.height/8)).fill(0),this.pixelRenderer=new SWRendererPixel(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this),this.lineRenderer=new SWRendererLine(this.pixelRenderer),this.rectRenderer=new SWRendererRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer),this.roundedRectRenderer=new SWRendererRoundedRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer,this.rectRenderer),this.circleRenderer=new SWRendererCircle(this.pixelRenderer),this.arcRenderer=new SWRendererArc(this.pixelRenderer)}get currentState(){return this.stateStack[this.stateStack.length-1]}save(){this.stateStack.push(this.currentState.clone())}restore(){if(this.stateStack.length<=1)throw new Error("Cannot restore() - stack is empty");this.stateStack.pop()}scale(t,e){this.currentState.transform=this.currentState.transform.scale(t,e)}rotate(t){this.currentState.transform=this.currentState.transform.rotate(t)}translate(t,e){this.currentState.transform=this.currentState.transform.translate(t,e)}resetTransform(){this.currentState.transform.reset()}set fillStyle(t){this.currentState.fillColor=parseColor(t)}set strokeStyle(t){this.currentState.strokeColor=parseColor(t)}set lineWidth(t){this.currentState.lineWidth=t}set globalAlpha(t){this.currentState.globalAlpha=Math.max(0,Math.min(1,t))}get globalAlpha(){return this.currentState.globalAlpha}beginPath(){this.tempClippingMask.fill(0)}fill(){throw new Error("fill() is not supported - use fillRect() instead")}stroke(){throw new Error("stroke() is not supported - use strokeRect() instead")}strokeLine(t,e,r,n){const i=this.currentState,s=getScaledLineWidth(i.transform.elements,i.lineWidth),a=transformPoint(t,e,i.transform.elements),o=transformPoint(r,n,i.transform.elements);this.lineRenderer.drawLine({start:{x:a.tx,y:a.ty},end:{x:o.tx,y:o.ty},thickness:s,color:i.strokeColor})}clearRect(t,e,r,n){const i=this.currentState,s=transformPoint(t+r/2,e+n/2,i.transform.elements),a=getRotationAngle(i.transform.elements);this.rectRenderer.clearRect({center:{x:s.tx,y:s.ty},width:r,height:n,rotation:a})}rect(t,e,r,n){const i=this.currentState,s=transformPoint(t+r/2,e+n/2,i.transform.elements),a=getRotationAngle(i.transform.elements),{scaleX:o,scaleY:l}=getScaleFactors(i.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*o,height:n*l,rotation:a,clippingOnly:!0})}clip(){for(let t=0;t<this.currentState.clippingMask.length;t++)this.currentState.clippingMask[t]=this.currentState.clippingMask[t]&this.tempClippingMask[t]}fillRect(t,e,r,n){const i=this.currentState,s=transformPoint(t+r/2,e+n/2,i.transform.elements),a=getRotationAngle(i.transform.elements),{scaleX:o,scaleY:l}=getScaleFactors(i.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*o,height:n*l,rotation:a,clippingOnly:!1,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:i.fillColor})}strokeRect(t,e,r,n){const i=this.currentState,s=getScaledLineWidth(i.transform.elements,i.lineWidth),a=transformPoint(t+r/2,e+n/2,i.transform.elements),o=getRotationAngle(i.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(i.transform.elements);this.rectRenderer.drawRect({center:{x:a.tx,y:a.ty},width:r*l,height:n*h,rotation:o,clippingOnly:!1,strokeWidth:s,strokeColor:i.strokeColor,fillColor:{r:0,g:0,b:0,a:0}})}blitToCanvas(t){if(isNode)return;const e=new ImageData(this.frameBufferUint8ClampedView,this.canvas.width,this.canvas.height);t.getContext("2d").putImageData(e,0,0)}fillCircle(t,e,r,n,i,s,a){const o=this.currentState,l=transformPoint(t,e,o.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(o.transform.elements),f=r*Math.max(h,c),d={center:{x:l.tx,y:l.ty},radius:f,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:{r:n,g:i,b:s,a:a}};this.circleRenderer.drawCircle(d)}strokeCircle(t,e,r,n,i,s,a,o){const l=this.currentState,h=transformPoint(t,e,l.transform.elements),{scaleX:c,scaleY:f}=getScaleFactors(l.transform.elements),d=r*Math.max(c,f),u=getScaledLineWidth(l.transform.elements,n),x={center:{x:h.tx,y:h.ty},radius:d,strokeWidth:u,strokeColor:{r:i,g:s,b:a,a:o},fillColor:{r:0,g:0,b:0,a:0}};this.circleRenderer.drawCircle(x)}fillAndStrokeCircle(t,e,r,n,i,s,a,o,l,h,c,f){const d=this.currentState,u=transformPoint(t,e,d.transform.elements),{scaleX:x,scaleY:M}=getScaleFactors(d.transform.elements),m=r*Math.max(x,M),p=getScaledLineWidth(d.transform.elements,o),g={center:{x:u.tx,y:u.ty},radius:m,strokeWidth:p,strokeColor:{r:l,g:h,b:c,a:f},fillColor:{r:n,g:i,b:s,a:a}};this.circleRenderer.drawCircle(g)}getImageData(t,e,r,n){const i=this.canvas.width,s=this.canvas.height;t=Math.max(0,Math.min(Math.floor(t),i)),e=Math.max(0,Math.min(Math.floor(e),s)),r=Math.max(0,Math.min(Math.floor(r),i-t)),n=Math.max(0,Math.min(Math.floor(n),s-e));const a=new Uint8ClampedArray(r*n*4);if(0===t&&0===e&&r===i&&n===s)a.set(this.frameBufferUint8ClampedView);else for(let s=0;s<n;s++)for(let n=0;n<r;n++){const o=4*((e+s)*i+(t+n)),l=4*(s*r+n);a[l]=this.frameBufferUint8ClampedView[o],a[l+1]=this.frameBufferUint8ClampedView[o+1],a[l+2]=this.frameBufferUint8ClampedView[o+2],a[l+3]=this.frameBufferUint8ClampedView[o+3]}const o=new ImageData(a,r,n);return void 0===o.canvasTitle&&Object.defineProperty(o,"canvasTitle",{get:()=>this.canvas.title||this.title||"",configurable:!0}),o}roundRect(t,e,r,n,i){const s=this.currentState,{scaleX:a,scaleY:o}=(transformPoint(t+r/2,e+n/2,s.transform.elements),getRotationAngle(s.transform.elements),getScaleFactors(s.transform.elements));throw new Error("CrispSwContext.roundRect() for path definition / clipping is not yet implemented.")}fillRoundRect(t,e,r,n,i){const s=this.currentState,a=transformPoint(t+r/2,e+n/2,s.transform.elements),o=getRotationAngle(s.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(s.transform.elements),c=i*Math.min(Math.abs(l),Math.abs(h));this.roundedRectRenderer.drawRoundedRect({center:{x:a.tx,y:a.ty},width:r*l,height:n*h,radius:c,rotation:o,fillColor:s.fillColor,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0}})}strokeRoundRect(t,e,r,n,i){const s=this.currentState,a=getScaledLineWidth(s.transform.elements,s.lineWidth),o=transformPoint(t+r/2,e+n/2,s.transform.elements),l=getRotationAngle(s.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(s.transform.elements),f=i*Math.min(Math.abs(h),Math.abs(c));this.roundedRectRenderer.drawRoundedRect({center:{x:o.tx,y:o.ty},width:r*h,height:n*c,radius:f,rotation:l,fillColor:{r:0,g:0,b:0,a:0},strokeWidth:a,strokeColor:s.strokeColor})}arc(t,e,r,n,i,s=!1){throw new Error("CrispSwContext.arc() for path definition/clipping is not yet implemented. Use fillArc/strokeArc for drawing.")}fillArc(t,e,r,n,i,s=!1){const a=this.currentState,o=transformPoint(t,e,a.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(a.transform.elements),c=r*Math.min(Math.abs(l),Math.abs(h)),f=180*n/Math.PI,d=180*i/Math.PI;this.arcRenderer.drawArc({center:{x:o.tx,y:o.ty},radius:c,startAngle:f,endAngle:d,fillColor:a.fillColor,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0}})}strokeArc(t,e,r,n,i,s=!1){const a=this.currentState,o=getScaledLineWidth(a.transform.elements,a.lineWidth),l=transformPoint(t,e,a.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(a.transform.elements),f=r*Math.min(Math.abs(h),Math.abs(c)),d=180*n/Math.PI,u=180*i/Math.PI;this.arcRenderer.drawArc({center:{x:l.tx,y:l.ty},radius:f,startAngle:d,endAngle:u,fillColor:{r:0,g:0,b:0,a:0},strokeWidth:o,strokeColor:a.strokeColor})}fillAndStrokeArc(t,e,r,n,i,s=!1){const a=this.currentState,o=getScaledLineWidth(a.transform.elements,a.lineWidth),l=transformPoint(t,e,a.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(a.transform.elements),f=r*Math.min(Math.abs(h),Math.abs(c)),d=180*n/Math.PI,u=180*i/Math.PI;this.arcRenderer.drawArc({center:{x:l.tx,y:l.ty},radius:f,startAngle:d,endAngle:u,fillColor:a.fillColor,strokeWidth:o,strokeColor:a.strokeColor})}}