/* CrispSwCanvas v1.0.2 */
class TransformationMatrix{constructor(){this.elements=new Float64Array([1,0,0,0,1,0,0,0,1])}clone(){const t=new TransformationMatrix;return t.elements.set(this.elements),t}reset(){return this.elements.set([1,0,0,0,1,0,0,0,1]),this}get(t,e){return this.elements[3*e+t]}set(t,e,r){this.elements[3*e+t]=r}multiply(t){const e=new TransformationMatrix;for(let r=0;r<3;r++)for(let i=0;i<3;i++){let n=0;for(let e=0;e<3;e++)n+=this.get(i,e)*t.get(e,r);e.set(i,r,n)}return e}translate(t,e){const r=new TransformationMatrix;return r.elements.set([1,0,0,0,1,0,t,e,1]),this.multiply(r)}scale(t,e){const r=new TransformationMatrix;return r.elements.set([t,0,0,0,e,0,0,0,1]),this.multiply(r)}rotate(t){const e=new TransformationMatrix,r=Math.cos(t),i=Math.sin(t);return e.elements.set([r,i,0,-i,r,0,0,0,1]),this.multiply(e)}}function getScaledLineWidth(t,e){const r=Math.sqrt(t[0]*t[0]+t[1]*t[1]),i=Math.sqrt(t[3]*t[3]+t[4]*t[4]);return e*Math.max(Math.sqrt(r*i),1e-4)}function transformPoint(t,e,r){return{tx:r[0]*t+r[3]*e+r[6],ty:r[1]*t+r[4]*e+r[7]}}function getRotationAngle(t){return Math.atan2(-t[3],t[0])}function getScaleFactors(t){return{scaleX:Math.sqrt(t[0]*t[0]+t[1]*t[1]),scaleY:Math.sqrt(t[3]*t[3]+t[4]*t[4])}}function parseColor(t){if(!t||"string"!=typeof t)throw new Error("Invalid color format: must be a string");if((t=t.trim().replace(/\s+/g,"")).startsWith("#")){let e,r,i;if(4===t.length)return e=parseInt(t[1]+t[1],16),r=parseInt(t[2]+t[2],16),i=parseInt(t[3]+t[3],16),normalizeColor(e,r,i,1);if(7===t.length)return e=parseInt(t.substring(1,3),16),r=parseInt(t.substring(3,5),16),i=parseInt(t.substring(5,7),16),normalizeColor(e,r,i,1)}const e=t.match(/^rgb\((\d+),(\d+),(\d+)\)$/i),r=t.match(/^rgba\((\d+),(\d+),(\d+),([0-9]*\.?[0-9]+)\)$/i);if(e){const[t,r,i,n]=e;if(r>255||i>255||n>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+r,+i,+n,1)}if(r){const[t,e,i,n,s]=r;if(e>255||i>255||n>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+e,+i,+n,+s)}throw new Error(`Invalid color format: ${t}`)}function normalizeColor(t,e,r,i){return{r:Math.round(Math.max(0,Math.min(255,t))),g:Math.round(Math.max(0,Math.min(255,e))),b:Math.round(Math.max(0,Math.min(255,r))),a:Math.max(0,Math.min(255,255*i))}}function colorToString(t,e,r,i){return"object"==typeof t?`rgba(${t.r}, ${t.g}, ${t.b}, ${(t.a/255).toFixed(3).replace(/\.?0+$/,"")})`:`rgba(${t}, ${e}, ${r}, ${(i/255).toFixed(3).replace(/\.?0+$/,"")})`}class ContextState{constructor(t,e,r,i,n,s,a,o){this.canvasWidth=t,this.canvasHeight=e,this.lineWidth=r||1,this.transform=i||new TransformationMatrix,this.strokeColor=n||{r:0,g:0,b:0,a:1},this.fillColor=s||{r:0,g:0,b:0,a:1},this.globalAlpha=a||1,this.clippingMask=o||new Uint8Array(Math.ceil(t*e/8)).fill(255)}clone(){const t=new Uint8Array(this.clippingMask);return new ContextState(this.canvasWidth,this.canvasHeight,this.lineWidth,this.transform.clone(),{...this.strokeColor},{...this.fillColor},this.globalAlpha,t)}}function pointInPolygon(t,e,r){let i=!1;for(let n=0,s=r.length-1;n<r.length;s=n++){const a=r[n].x,o=r[n].y,l=r[s].x,h=r[s].y;o>e!=h>e&&t<(l-a)*(e-o)/(h-o)+a&&(i=!i)}return i}function extendLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const a=i/s,o=n/s;return{start:{x:t.x-a*r,y:t.y-o*r},end:{x:e.x+a*r,y:e.y+o*r}}}function shortenLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const a=i/s,o=n/s;return{start:{x:t.x+a*r,y:t.y+o*r},end:{x:e.x-a*r,y:e.y-o*r}}}function alignToPixelBoundary(t){return{x:Math.round(t.x)+.5,y:Math.round(t.y)+.5}}function toIntegerPoint(t){return{x:Math.round(t.x),y:Math.round(t.y)}}function roundCornerOfRectangularGeometry(t){const{x:e,y:r,w:i,h:n}=t;return{x:Math.round(e),y:Math.round(r),w:i,h:n}}function roundCornerOfRectangularGeometryWithWarning(t){const e=roundCornerOfRectangularGeometry(t);return e.x===t.x&&e.y===t.y||console.warn("Rectangular geometry is not at a grid point, rounding to nearest grid point. When this happens, HTML5 Canvas would do a non-crisp fill, while the SW renderer will do a crisp fill."),e}function getRectangularFillGeometry(t,e,r,i){return{x:t-r/2,y:e-i/2,w:r,h:i}}var getRectangularStrokeGeometry=getRectangularFillGeometry;function checkBasicConditionsForCrispRendering(t,e,r,i,n){Number.isInteger(r)&&Number.isInteger(i)||console.warn("Width and height must be integers for crisp rendering"),Number.isInteger(n)||console.warn("Stroke width must be an integer for crisp rendering"),Number.isInteger(t)||t%1==.5||console.warn("Center X must be an integer or *.5 for crisp rendering"),Number.isInteger(e)||e%1==.5||console.warn("Center Y must be an integer or *.5 for crisp rendering ")}class PixelSet{constructor(t){this.pixels=new Map,this.pixelRenderer=t}addPixel(t,e,r,i,n,s){const a=`${Math.round(t)},${Math.round(e)}`;this.pixels.set(a,{x:Math.round(t),y:Math.round(e),r:r,g:i,b:n,a:s})}paint(){for(const t of this.pixels.values())this.pixelRenderer.setPixel(t.x,t.y,t.r,t.g,t.b,t.a)}}class ScanlineSpans{constructor(){this.spans=new Map}addSpan(t,e,r){if(e>r&&([e,r]=[r,e]),this.spans.has(t)){const i=this.spans.get(t);i[0]=Math.min(i[0],e),i[1]=Math.max(i[1],r)}else this.spans.set(t,[e,r])}addPixel(t,e){if(e=Math.round(e),t=Math.round(t),this.spans.has(e)){const r=this.spans.get(e);r[0]=Math.min(r[0],t),r[1]=Math.max(r[1],t)}else this.spans.set(e,[t,t])}addToPixelSet(t,e,r,i,n){for(const[s,[a,o]]of this.spans)for(let l=a;l<=o;l++)t.addPixel(l,s,e,r,i,n)}}const ANGLE_TOLERANCE=.001;function isNearMultipleOf90Degrees(t){const e=(t%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(e)<.001||Math.abs(e-Math.PI/2)<.001||Math.abs(e-Math.PI)<.001||Math.abs(e-3*Math.PI/2)<.001||Math.abs(e-2*Math.PI)<.001}function getRotatedDimensionsIfTheCase(t,e,r){const i=(r%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(i-Math.PI/2)<.001||Math.abs(i-3*Math.PI/2)<.001?{adjustedWidth:e,adjustedHeight:t}:{adjustedWidth:t,adjustedHeight:e}}class SWRendererPixel{constructor(t,e,r,i,n){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,n?(this.context=n,this.tempClippingMask=n.tempClippingMask):this.context={globalAlpha:1}}clipPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=e*r+t,n=i>>3,s=7&i;this.tempClippingMask[n]|=1<<7-s}setPixel(t,e,r,i,n,s){t|=0,e|=0;const a=this.width,o=this.context.globalAlpha;if(t<0||t>=a||e<0||e>=this.height)return;const l=e*a+t,h=4*l;if(this.context.currentState){const t=this.context.currentState.clippingMask,e=l>>3,r=7&l;if(0===t[e])return;if(!(t[e]&1<<7-r))return}let c=0;if(255===s&&o>=1)return c=255<<24|n<<16|i<<8|r,void(this.frameBufferUint32View[l]=c);const f=s/255*o,d=this.frameBufferUint8ClampedView[h+3]/255*(1-f),u=f+d;if(u<=0)return;const x=1/u;this.frameBufferUint8ClampedView[h]=(r*f+this.frameBufferUint8ClampedView[h]*d)*x,this.frameBufferUint8ClampedView[h+1]=(i*f+this.frameBufferUint8ClampedView[h+1]*d)*x,this.frameBufferUint8ClampedView[h+2]=(n*f+this.frameBufferUint8ClampedView[h+2]*d)*x,this.frameBufferUint8ClampedView[h+3]=255*u}clearPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=4*(e*r+t);this.frameBufferUint8ClampedView[i]=0,this.frameBufferUint8ClampedView[i+1]=0,this.frameBufferUint8ClampedView[i+2]=0,this.frameBufferUint8ClampedView[i+3]=0}setPixelRuns(t,e,r,i,n){const s=this.width,a=this.height,o=this.frameBufferUint8ClampedView,l=this.frameBufferUint32View,h=this.context.globalAlpha,c=this.context.currentState,f=c?this.context.currentState.clippingMask:null,d=255===n&&h>=1;let u=0;d&&(u=255<<24|i<<16|r<<8|e);const x=d?1:n/255*h,M=d?0:1-x;if(!(x<=0))for(let n=0;n<t.length;n+=3){let h=0|t[n];const m=0|t[n+1];let p=0|t[n+2];if(m<0||m>=a)continue;if(h<0&&(p+=h,h=0,p<=0))continue;if(h+p>s&&(p=s-h,p<=0))continue;let g=m*s+h,w=4*g;if(d)for(let t=0;t<p;t++,g++,w+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,w+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}l[g]=u}else for(let t=0;t<p;t++,g++,w+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,w+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}const n=o[w+3]/255*M,s=x+n;if(s<=0)continue;const a=1/s;o[w]=(e*x+o[w]*n)*a,o[w+1]=(r*x+o[w+1]*n)*a,o[w+2]=(i*x+o[w+2]*n)*a,o[w+3]=255*s}}}setPixelFillAndStrokeRuns(t,e,r,i,n,s,a,o,l,h){t+=2;const c=this.width,f=this.height,d=this.frameBufferUint8ClampedView,u=this.frameBufferUint32View,x=this.context.globalAlpha,M=this.context.currentState,m=M?this.context.currentState.clippingMask:null,p=s/255*x,g=1-p,w=p>=1;let R=0;w&&(R=255<<24|n<<16|i<<8|r);const y=h/255*x,S=1-y,C=y>=1;let P=0;if(C&&(P=255<<24|l<<16|o<<8|a),p<=0&&y<=0)return;let k=t;for(let t=0;t<e.length;t+=6){if(k<0||k>=f){k++;continue}let s=-1!==e[t]?0|e[t]:-1,h=-1!==e[t+1]?0|e[t+1]:-1,x=-1!==e[t+2]?0|e[t+2]:-1,b=-1!==e[t+3]?0|e[t+3]:-1,A=-1!==e[t+4]?0|e[t+4]:-1,B=-1!==e[t+5]?0|e[t+5]:-1;const I=-1!==s&&h>0&&p>0,W=-1!==x&&b>0&&y>0,U=-1!==A&&B>0&&y>0;if(I||W||U){I&&(s<0&&(h+=s,s=0),s+h>c&&(h=c-s),h<=0&&(s=-1,h=0)),W&&(x<0&&(b+=x,x=0),x+b>c&&(b=c-x),b<=0&&(x=-1,b=0)),U&&(A<0&&(B+=A,A=0),A+B>c&&(B=c-A),B<=0&&(A=-1,B=0));for(let t=0;t<3;t++){let e,f,_,v,V,F,L,O,T=0;if(0===t){if(!I||-1===s||h<=0)continue;e=s,f=h,_=r,v=i,V=n,F=p,L=g,O=w,O&&(T=R)}else if(1===t){if(!W||-1===x||b<=0)continue;e=x,f=b,_=a,v=o,V=l,F=y,L=S,O=C,O&&(T=P)}else{if(!U||-1===A||B<=0)continue;e=A,f=B,_=a,v=o,V=l,F=y,L=S,O=C,O&&(T=P)}let q=k*c+e,E=4*q;for(let t=0;t<f;t++,q++,E+=4){if(M){const e=q>>3;if(e>=m.length)continue;if(0===m[e]){const e=8-(7&q),r=Math.min(e,f-t);t+=r-1,q+=r-1,E+=4*(r-1);continue}const r=7&q;if(!(m[e]&1<<7-r))continue}if(O)u[q]=T;else{const t=d[E+3]/255*L,e=F+t;if(e<=1e-5)continue;const r=1/e;d[E]=(_*F+d[E]*t)*r,d[E+1]=(v*F+d[E+1]*t)*r,d[E+2]=(V*F+d[E+2]*t)*r,d[E+3]=255*e}}}k++}else k++}}}class SWRendererLine{constructor(t){this.pixelRenderer=t,this._corners=[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],this._edges=[{p1:this._corners[0],p2:this._corners[1],invDeltaY:0,deltaX:0},{p1:this._corners[1],p2:this._corners[2],invDeltaY:0,deltaX:0},{p1:this._corners[2],p2:this._corners[3],invDeltaY:0,deltaX:0},{p1:this._corners[3],p2:this._corners[0],invDeltaY:0,deltaX:0}],this._intersections=new Array(8),this._pixelRuns=[]}drawLine(t){const{start:{x:e,y:r},end:{x:i,y:n},thickness:s,color:{r:a,g:o,b:l,a:h}}=t;if(1!==s)return void this.drawLineThick(e,r,i,n,s,a,o,l,h);let c=Math.floor(e),f=Math.floor(r),d=Math.floor(i),u=Math.floor(n);c===d&&(u>f?u--:f--),f===u&&(d>c?d--:c--);const x=this.pixelRenderer.context.globalAlpha;if(0===h||x<=0)return;const M=Math.abs(d-c),m=Math.abs(u-f);return 0===M?this._drawLine1px_vertical(c,f,u,a,o,l,h):0===m?this._drawLine1px_horizontal(c,d,f,a,o,l,h):M===m?this._drawLine1px_45degrees(c,f,d,u,a,o,l,h):this._drawLine1px_genericOrientations(c,f,d,u,M,m,a,o,l,h)}drawLine1px(t,e,r,i,n,s,a,o){t=Math.floor(t),e=Math.floor(e),r=Math.floor(r),i=Math.floor(i);const l=Math.abs(r-t),h=Math.abs(i-e);return 0===l?this._drawLine1px_vertical(t,e,i,n,s,a,o):0===h?this._drawLine1px_horizontal(t,r,e,n,s,a,o):l===h?this._drawLine1px_45degrees(t,e,r,i,n,s,a,o):this._drawLine1px_genericOrientations(t,e,r,i,l,h,n,s,a,o)}_drawLine1px_horizontal(t,e,r,i,n,s,a){const o=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(r<0||r>=c)return;const x=255===a&&u>=1;let M=0;x&&(M=255<<24|s<<16|n<<8|i);const m=x?1:a/255*u,p=x?0:1-m;if(t>e){let r=t;t=e,e=r}if(t<0&&(t=0),e>=h&&(e=h-1),t>e)return;const g=4*(r*h+t);for(let a=t;a<=e;a++){const e=g+4*(a-t),c=r*h+a;if(f){const t=c>>3,e=7&c;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[c]=M;else{const t=o[e+3]/255*p,r=m+t;if(r<=0)continue;const a=1/r;o[e]=(i*m+o[e]*t)*a,o[e+1]=(n*m+o[e+1]*t)*a,o[e+2]=(s*m+o[e+2]*t)*a,o[e+3]=255*r}}}_drawLine1px_vertical(t,e,r,i,n,s,a){const o=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(t<0||t>=h)return;const x=255===a&&u>=1;let M=0;x&&(M=255<<24|s<<16|n<<8|i);const m=x?1:a/255*u,p=x?0:1-m;if(e>r){let t=e;e=r,r=t}if(e<0&&(e=0),r>=c&&(r=c-1),!(e>r))for(let a=e;a<=r;a++){const e=4*(a*h+t),r=a*h+t;if(f){const t=r>>3,e=7&r;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[r]=M;else{const t=o[e+3]/255*p,r=m+t;if(r<=0)continue;const a=1/r;o[e]=(i*m+o[e]*t)*a,o[e+1]=(n*m+o[e+1]*t)*a,o[e+2]=(s*m+o[e+2]*t)*a,o[e+3]=255*r}}}_drawLine1px_45degrees(t,e,r,i,n,s,a,o){const l=this.pixelRenderer.frameBufferUint8ClampedView,h=this.pixelRenderer.frameBufferUint32View,c=this.pixelRenderer.width,f=this.pixelRenderer.height,d=this.pixelRenderer.context.currentState,u=d?this.pixelRenderer.context.currentState.clippingMask:null,x=this.pixelRenderer.context.globalAlpha,M=255===o&&x>=1;let m=0;M&&(m=255<<24|a<<16|s<<8|n);const p=M?1:o/255*x,g=M?0:1-p,w=t<r?1:-1,R=e<i?1:-1;let y=t,S=e;for(;!(y<0&&w<0||y>=c&&w>0||S<0&&R<0||S>=f&&R>0);){if(y>=0&&y<c&&S>=0&&S<f){const t=4*(S*c+y),e=S*c+y;let r=!0;if(d){const t=e>>3,i=7&e;!(t>=u.length||0===u[t])&&u[t]&1<<7-i||(r=!1)}if(r)if(M)h[e]=m;else{const e=l[t+3]/255*g,r=p+e;if(r>0){const i=1/r;l[t]=(n*p+l[t]*e)*i,l[t+1]=(s*p+l[t+1]*e)*i,l[t+2]=(a*p+l[t+2]*e)*i,l[t+3]=255*r}}}if(y===r&&S===i)break;y+=w,S+=R}}_drawLine1px_genericOrientations(t,e,r,i,n,s,a,o,l,h){const c=this.pixelRenderer.frameBufferUint8ClampedView,f=this.pixelRenderer.frameBufferUint32View,d=this.pixelRenderer.width,u=this.pixelRenderer.height,x=this.pixelRenderer.context.currentState,M=x?this.pixelRenderer.context.currentState.clippingMask:null,m=this.pixelRenderer.context.globalAlpha,p=255===h&&m>=1;let g=0;p&&(g=255<<24|l<<16|o<<8|a);const w=p?1:h/255*m,R=p?0:1-w,y=t<r?1:-1,S=e<i?1:-1;let C=n-s;for(;;){if(t>=0&&t<d&&e>=0&&e<u){const r=4*(e*d+t),i=e*d+t;let n=!0;if(x){const t=i>>3,e=7&i;!(t>=M.length||0===M[t])&&M[t]&1<<7-e||(n=!1)}if(n)if(p)f[i]=g;else{const t=c[r+3]/255*R,e=w+t;if(e>0){const i=1/e;c[r]=(a*w+c[r]*t)*i,c[r+1]=(o*w+c[r+1]*t)*i,c[r+2]=(l*w+c[r+2]*t)*i,c[r+3]=255*e}}}if(t===r&&e===i)break;const h=2*C;h>-s&&(C-=s,t+=y),h<n&&(C+=n,e+=S)}}drawLineThick(t,e,r,i,n,s,a,o,l){this._drawLineThickPolygonScan(t,e,r,i,n,s,a,o,l)}_drawLineThickBoundingBox(t,e,r,i,n,s,a,o,l){const h=(r-=.5)-(t-=.5),c=(i-=.5)-(e-=.5),f=Math.sqrt(h*h+c*c);if(0===f)return;const d=-c/f,u=h/f,x=n/2,M=[[t+d*x,e+u*x],[t-d*x,e-u*x],[r+d*x,i+u*x],[r-d*x,i-u*x]],m=Math.floor(Math.min(...M.map((t=>t[0])))),p=Math.ceil(Math.max(...M.map((t=>t[0])))),g=Math.floor(Math.min(...M.map((t=>t[1])))),w=Math.ceil(Math.max(...M.map((t=>t[1]))));for(let r=g;r<=w;r++)for(let i=m;i<=p;i++){const n=i-t,d=r-e,u=(n*h+d*c)/f,M=n-h/f*u,m=d-c/f*u,p=Math.sqrt(M*M+m*m);u>=0&&u<=f&&p<=x&&this.pixelRenderer.setPixel(i,r,s,a,o,l)}}_drawLineThickModifiedBresenham(t,e,r,i,n,s,a,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1;let u,x;const M=Math.sqrt(h*h+c*c);if(0===M){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,a,o,l);return}u=-c/M,x=h/M;const m=n/2;let p=h-c,g=t,w=e;for(;this._drawPerpendicularSegment(g,w,u,x,m,s,a,o,l),g!==r||w!==i;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,w+=d)}const R=(r-t)/M,y=(i-e)/M;this._drawSquareCap(t,e,u,x,m,-R,-y,s,a,o,l),this._drawSquareCap(r,i,u,x,m,R,y,s,a,o,l)}_drawPerpendicularSegment(t,e,r,i,n,s,a,o,l){const h=Math.ceil(n);this.pixelRenderer.setPixel(t,e,s,a,o,l);for(let c=1;c<=h;c++){const f=c/h*n,d=Math.round(t+r*f),u=Math.round(e+i*f),x=Math.round(t-r*f),M=Math.round(e-i*f);this.pixelRenderer.setPixel(d,u,s,a,o,l),this.pixelRenderer.setPixel(x,M,s,a,o,l)}}_drawSquareCap(t,e,r,i,n,s,a,o,l,h,c){const f=Math.ceil(n);for(let d=1;d<=f;d++){const u=d/f*n,x=Math.round(t+s*u),M=Math.round(e+a*u);this._drawPerpendicularSegment(x,M,r,i,n,o,l,h,c)}}_drawLineThickDistanceOptimized(t,e,r,i,n,s,a,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1,u=Math.sqrt((r-t)**2+(i-e)**2);if(0===u){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,a,o,l);return}const x=-(i-e)/u,M=(r-t)/u,m=Math.floor(n/2);let p=h-c,g=t,w=e;const R=[];for(;R.push({x:g,y:w}),g!==r||w!==i;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,w+=d)}for(const t of R)for(let e=-m;e<=m;e++){const r=Math.round(t.x+x*e),i=Math.round(t.y+M*e);this.pixelRenderer.setPixel(r,i,s,a,o,l)}const y=-(r-t)/u,S=-(i-e)/u;for(let r=1;r<=m;r++){const i=Math.round(t+y*r),n=Math.round(e+S*r);for(let t=-m;t<=m;t++){const e=Math.round(i+x*t),r=Math.round(n+M*t);this.pixelRenderer.setPixel(e,r,s,a,o,l)}}const C=(r-t)/u,P=(i-e)/u;for(let t=1;t<=m;t++){const e=Math.round(r+C*t),n=Math.round(i+P*t);for(let t=-m;t<=m;t++){const r=Math.round(e+x*t),i=Math.round(n+M*t);this.pixelRenderer.setPixel(r,i,s,a,o,l)}}}_drawLineThickParallelOffset(t,e,r,i,n,s,a,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.sqrt((r-t)**2+(i-e)**2);if(0===h){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,a,o,l);return}const c=-(i-e)/h,f=(r-t)/h,d=(r-t)/h,u=(i-e)/h,x=n/2,M=Math.ceil(x);for(let n=-M;n<=M;n++){const h=n/M*x,d=t+c*h,u=e+f*h,m=r+c*h,p=i+f*h;this._drawBresenhamLine(Math.round(d),Math.round(u),Math.round(m),Math.round(p),s,a,o,l)}for(let r=-M;r<=M;r++){const i=r/M*x;for(let r=1;r<=x;r++){const n=Math.round(t-d*r+c*i),h=Math.round(e-u*r+f*i);this.pixelRenderer.setPixel(n,h,s,a,o,l)}}for(let t=-M;t<=M;t++){const e=t/M*x;for(let t=1;t<=x;t++){const n=Math.round(r+d*t+c*e),h=Math.round(i+u*t+f*e);this.pixelRenderer.setPixel(n,h,s,a,o,l)}}}_drawBresenhamLine(t,e,r,i,n,s,a,o){const l=Math.abs(r-t),h=Math.abs(i-e),c=t<r?1:-1,f=e<i?1:-1;let d=l-h;for(;this.pixelRenderer.setPixel(t,e,n,s,a,o),t!==r||e!==i;){const r=2*d;r>-h&&(d-=h,t+=c),r<l&&(d+=l,e+=f)}}_drawLineThickPolygonScan(t,e,r,i,n,s,a,o,l){const h=r-t,c=i-e,f=Math.sqrt(h*h+c*c),d=this._pixelRuns;if(d.length=0,0===f){const r=n>>1,i=0|t,h=0|e;for(let t=-r;t<=r;t++)d.push(i-r,h+t,1+(r<<1));return void this.pixelRenderer.setPixelRuns(d,s,a,o,l)}const u=1/f,x=-c*u,M=h*u,m=.5*n,p=this._corners,g=x*m,w=M*m;p[0].x=t+g,p[0].y=e+w,p[1].x=t-g,p[1].y=e-w,p[2].x=r-g,p[2].y=i-w,p[3].x=r+g,p[3].y=i+w;const R=0|Math.min(p[0].y,p[1].y,p[2].y,p[3].y),y=Math.max(p[0].y,p[1].y,p[2].y,p[3].y)+.999|0,S=this._edges;for(let t=0;t<4;t++){const e=S[t],r=p[t],i=p[t+1&3];e.p1=r,e.p2=i,r.y!==i.y&&(e.invDeltaY=1/(i.y-r.y),e.deltaX=i.x-r.x)}const C=this._intersections;for(let t=R;t<=y;t++){let e=0;for(let r=0;r<4;r++){const i=S[r],n=i.p1,s=i.p2;if(n.y!==s.y&&(t>=n.y&&t<s.y||t>=s.y&&t<n.y)){const r=(t-n.y)*i.invDeltaY;C[e++]=n.x+r*i.deltaX}}if(1===e){const e=0|C[0];d.push(e,t,1)}else if(2===e){const e=C[0],r=C[1],i=e<r?0|e:0|r,n=(e>r?e+.999|0:r+.999|0)-i;n>0&&d.push(i,t,n)}}d.length>0&&this.pixelRenderer.setPixelRuns(d,s,a,o,l)}}class SWRendererRect{constructor(t,e,r,i,n,s){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=s}drawRect(t){if(t.clippingOnly){if(isNearMultipleOf90Degrees(t.rotation)){const{adjustedWidth:e,adjustedHeight:r}=getRotatedDimensionsIfTheCase(t.width,t.height,t.rotation);this.drawAxisAlignedRect(t.center.x,t.center.y,e,r,!0)}else this.drawRotatedRect(t.center.x,t.center.y,t.width,t.height,t.rotation,!0);return}const{center:e,width:r,height:i,rotation:n,clippingOnly:s,strokeWidth:a,strokeColor:{r:o,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:x}}=t;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:M}=getRotatedDimensionsIfTheCase(r,i,n);this.drawAxisAlignedRect(e.x,e.y,t,M,s,a,o,l,h,c,f,d,u,x)}else this.drawRotatedRect(e.x,e.y,r,i,n,s,a,o,l,h,c,f,d,u,x)}clearRect(t){const e=t.center,r=t.width,i=t.height,n=t.rotation;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:s}=getRotatedDimensionsIfTheCase(r,i,n);if(t===this.width&&s===this.height&&e.x===t/2&&e.y===s/2)return void this.frameBufferUint8ClampedView.fill(0);this.clearAxisAlignedRect(e.x,e.y,t,s)}else this.fillRotatedRect(e.x,e.y,r,i,n,!1,!0)}drawRotatedRect(t,e,r,i,n,s,a,o,l,h,c,f,d,u,x){const M=Math.cos(n),m=Math.sin(n);if((s||x>0)&&this.fillRotatedRect(t,e,r,i,n,s,!1,f,d,u,x),!s&&c>0){const n=r/2,s=i/2,f=[[-n,-s],[n,-s],[n,s],[-n,s]].map((([r,i])=>({x:t+r*M-i*m,y:e+r*m+i*M})));if(1===a)for(let t=0;t<4;t++){const e=f[t],r=f[(t+1)%4];this.lineRenderer.drawLine1px(e.x,e.y,r.x,r.y,o,l,h,c)}else{const t=a/2;for(let e=0;e<4;e+=2){const r=extendLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,a,o,l,h,c)}for(let e=1;e<4;e+=2){const r=shortenLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,a,o,l,h,c)}}}}drawAxisAlignedRect(t,e,r,i,n,s,a,o,l,h,c,f,d,u){if(n&&(s=0),n||u>0){let a=null;if(a=255==h&&s>0?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i)),n){for(let t=Math.floor(a.y);t<Math.ceil(a.y+a.h);t++)for(let e=Math.floor(a.x);e<Math.ceil(a.x+a.w);e++)this.pixelRenderer.clipPixel(e,t);return}const o=this.pixelRenderer.context.globalAlpha,l=255===u&&o>=1;let x=0;l&&(x=255<<24|d<<16|f<<8|c);for(let t=Math.floor(a.y);t<Math.ceil(a.y+a.h);t++)for(let e=Math.floor(a.x);e<Math.ceil(a.x+a.w);e++){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}l?this.frameBufferUint32View[r]=x:this.pixelRenderer.setPixel(e,t,c,f,d,u)}}if(h>0&&s>0){let n=getRectangularStrokeGeometry(t,e,r,i);const c=s/2;for(let t=Math.floor(n.x-c);t<n.x+n.w+c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(t,n.y+e,a,o,l,h),this.pixelRenderer.setPixel(t,n.y+n.h+e,a,o,l,h);for(let t=Math.floor(n.y+c);t<n.y+n.h-c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(n.x+e,t,a,o,l,h),this.pixelRenderer.setPixel(n.x+n.w+e,t,a,o,l,h)}}clearAxisAlignedRect(t,e,r,i){t=Math.round(t),e=Math.round(e),r=Math.round(r),i=Math.round(i);const n=t-Math.floor(r/2),s=e-Math.floor(i/2),a=n+r,o=s+i;for(let t=s;t<o;t++)for(let e=n;e<a;e++)this.pixelRenderer.clearPixel(e,t)}fillRotatedRect(t,e,r,i,n,s,a,o,l,h,c){const f=Math.cos(n),d=Math.sin(n),u=r/2,x=i/2,M=[{x:t+u*f-x*d,y:e+u*d+x*f},{x:t+u*f+x*d,y:e+u*d-x*f},{x:t-u*f+x*d,y:e-u*d-x*f},{x:t-u*f-x*d,y:e-u*d+x*f}],m=[];for(let t=0;t<4;t++){const e=M[t],r=M[(t+1)%4],i=r.y-e.y,n=e.x-r.x,s=r.x*e.y-e.x*r.y;m.push({a:i,b:n,c:s})}const p=Math.floor(Math.min(...M.map((t=>t.x)))),g=Math.ceil(Math.max(...M.map((t=>t.x)))),w=Math.floor(Math.min(...M.map((t=>t.y)))),R=Math.ceil(Math.max(...M.map((t=>t.y)))),y=this.pixelRenderer.context.globalAlpha;if(s)for(let t=w;t<=R;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clipPixel(e,t)}else if(a)for(let t=w;t<=R;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clearPixel(e,t)}else{const t=255===c&&y>=1;let e=0;t&&(e=255<<24|h<<16|l<<8|o);for(let r=w;r<=R;r++)for(let i=p;i<=g;i++){if(m.every((t=>t.a*i+t.b*r+t.c>=0))){if(i<0||i>=this.width||r<0||r>=this.height)continue;const n=r*this.width+i;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=n>>3,r=7&n;if(0===t[e])continue;if(!(t[e]&1<<7-r))continue}t?this.frameBufferUint32View[n]=e:this.pixelRenderer.setPixel(i,r,o,l,h,c)}}}}}class SWRendererArc{constructor(t){this.pixelRenderer=t}drawArc(t){const{center:e,radius:r,startAngle:i,endAngle:n,strokeWidth:s,strokeColor:{r:a,g:o,b:l,a:h},fillColor:{r:c,g:f,b:d,a:u}}=t;u>0&&this.drawArcHelper(e.x,e.y,r,i,n,c,f,d,u,!0),h>0&&s>0&&this.drawArcHelper(e.x,e.y,r,i,n,a,o,l,h,!1,s)}drawArcHelper(t,e,r,i,n,s,a,o,l,h=!1,c=1){function f(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<i&&(r+=2*Math.PI),r>=i&&r<=n}if(i=i%360*Math.PI/180,(n=n%360*Math.PI/180)<i&&(n+=2*Math.PI),c>1&&(c*=.75),t-=1,e-=1,h){const i=(r-.5)*(r-.5);for(let n=-r;n<=r;n++)for(let h=-r;h<=r;h++)h*h+n*n<=i&&f(h,n)&&this.pixelRenderer.setPixel(Math.round(t+h),Math.round(e+n),Math.round(s),a,o,l)}if(!h||c>0){const h=new Set;let d=0,u=r,x=3-2*r;for(;u>=d;){[[d,u],[-d,u],[d,-u],[-d,-u],[u,d],[-u,d],[u,-d],[-u,-d]].forEach((([r,s])=>{f(r,s)&&this.addThickArcPoint(h,t,e,t+r,e+s,c,i,n)})),d++,x>0?(u--,x=x+4*(d-u)+10):x=x+4*d+6}for(let t of h){const[e,r]=t.split(",").map(Number);this.pixelRenderer.setPixel(e,r,s,a,o,l)}}}drawArcHQ(t){const{center:e,radius:r,startAngle:i,endAngle:n,strokeWidth:s,strokeColor:{r:a,g:o,b:l,a:h},fillColor:{r:c,g:f,b:d,a:u}}=t;e.x-=.5,e.y-=.5,u>0&&this.drawArcHQHelper(e.x,e.y,r,i,n,c,f,d,u,!0),h>0&&s>0&&this.drawArcHQHelper(e.x,e.y,r,i,n,a,o,l,h,!1,s)}drawArcHQHelper(t,e,r,i,n,s,a,o,l,h=!1,c=1){i=i%360*Math.PI/180,(n=n%360*Math.PI/180)<i&&(n+=2*Math.PI),c*=.5,t-=.5,e-=.5,r=Math.floor(r)+.5,t=Math.round(t),e=Math.round(e);const f=Math.floor(t-r-c),d=Math.ceil(t+r+c),u=Math.floor(e-r-c),x=Math.ceil(e+r+c);function M(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<i&&(r+=2*Math.PI),r>=i&&r<=n}const m=r*r;if(h)for(let r=u;r<=x;r++)for(let i=f;i<=d;i++){const n=i-t,h=r-e;n*n+h*h<=m&&M(n,h)&&this.pixelRenderer.setPixel(i,r,s,a,o,l)}if(c>0)for(let i=u;i<=x;i++)for(let n=f;n<=d;n++){const h=n-t,f=i-e,d=h*h+f*f;Math.abs(Math.sqrt(d)-r)<=c&&M(h,f)&&this.pixelRenderer.setPixel(n,i,s,a,o,l)}}addStrokePixel(t,e,r){t.add(`${e},${r}`)}addThickPoint(t,e,r,i){const n=Math.floor(i/2);for(let s=-n;s<i-n;s++)for(let a=-n;a<i-n;a++)this.addStrokePixel(t,Math.round(e+a),Math.round(r+s))}addThickArcPoint(t,e,r,i,n,s,a,o){const l=Math.floor(s/2);for(let h=-l;h<s-l;h++)for(let c=-l;c<s-l;c++){const s=i+c,l=n+h;let f=Math.atan2(l-r,s-e);f<0&&(f+=2*Math.PI),f<a&&(f+=2*Math.PI),f>=a&&f<=o&&t.add(`${Math.round(s)},${Math.round(l)}`)}}}class SWRendererCircle{constructor(t){this.pixelRenderer=t}drawCircle(t){const{center:e,radius:r,strokeWidth:i,strokeColor:{r:n,g:s,b:a,a:o},fillColor:{r:l,g:h,b:c,a:f},clippingOnly:d}=t;if(!0===d)return void this._clipCircleShape(t);const u=f>0;if(!u&&(1===i&&o>0)){return void(255===o&&this.pixelRenderer.context.globalAlpha>=1?this.draw1PxStrokeFullCircleBresenhamOpaque(e.x,e.y,r,n,s,a):this.draw1PxStrokeFullCircleBresenhamAlpha(e.x,e.y,r,n,s,a,o))}const x=i>0&&o>0,M=255===f&&this.pixelRenderer.context.globalAlpha>=1;if(u&&!x&&M)return void this.drawOpaqueFillFullCircleBresenham(e.x,e.y,r,l,h,c);if(u&&!x&&!M)return void this.drawSemiTransparentFillFullCircleBresenham(e.x,e.y,r,l,h,c,f);const m=i>0?r-i/2:r,p=r+i/2;this.drawFullCircleFast(e.x,e.y,m,p,l,h,c,f,n,s,a,o)}drawFullCircleSlow(t,e,r,i,n,s,a,o,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,w=g*g,R=o>0,y=f>0&&i>r;if(R&&!y)for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),l=Math.max(m,Math.ceil(d-i+1e-4)),h=Math.min(p,Math.floor(d+i-1e-4));for(let e=l;e<=h;e++)this.pixelRenderer.setPixel(e,t,n,s,a,o)}else if(y&&!R){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),x=Math.min(p,Math.floor(d+a));if(r<=0||s>e)for(let t=o;t<=x;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{const t=Math.sqrt(e-s),r=Math.min(x,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t));for(let t=o;t<=r;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=n;t<=x;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}else if(R&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const x=i-u,M=x*x;if(M>t)continue;const g=Math.sqrt(t-M),R=Math.max(m,Math.ceil(d-g)),y=Math.min(p,Math.floor(d+g));let S=-1,C=-1;if(r>0&&M<=e){const t=Math.sqrt(e-M);S=Math.min(y,Math.floor(d-t)),C=Math.max(R,Math.ceil(d+t))}const P=w-M;let k=-1,b=-1;if(P>=0){const t=Math.sqrt(P);k=Math.max(m,Math.ceil(d-t+1e-4)),b=Math.min(p,Math.floor(d+t-1e-4))}if(k>=0)for(let t=k;t<=b;t++)this.pixelRenderer.setPixel(t,i,n,s,a,o);if(r<=0||M>e)for(let t=R;t<=y;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{for(let t=R;t<=S;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=C;t<=y;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}}drawFullCircleFast(t,e,r,i,n,s,a,o,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,w=g*g,R=o>0,y=f>0&&i>r,S=[],C=[];if(R&&!y){for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(m,Math.ceil(d-i+1e-4)),s=Math.min(p,Math.floor(d+i-1e-4))-n+1;s>0&&S.push(n,t,s)}S.length>0&&this.pixelRenderer.setPixelRuns(S,n,s,a,o)}else if(y&&!R){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));if(r<=0||s>e){const t=l-o+1;t>0&&C.push(o,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t)),a=r-o+1;a>0&&C.push(o,i,a);const h=l-n+1;h>0&&C.push(n,i,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(R&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=w-s;let x=-1,M=-1;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4))}if(x>=0){const t=M-x+1;t>0&&S.push(x,i,t)}if(r<=0||s>e){const t=l-o+1;t>0&&C.push(o,i,t)}else{const t=h-o+1;t>0&&C.push(o,i,t);const e=l-c+1;e>0&&C.push(c,i,e)}}S.length>0&&this.pixelRenderer.setPixelRuns(S,n,s,a,o),C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}}drawFullCircleFastest(t,e,r,i,n,s,a,o,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,w=g*g,R=o>0,y=f>0&&i>r,S=[],C=[],P=[];if(R&&!y){for(let t=x;t<=M;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(m,Math.ceil(d-i+1e-4)),s=Math.min(p,Math.floor(d+i-1e-4))-n+1;s>0&&S.push(n,t,s)}S.length>0&&this.pixelRenderer.setPixelRuns(S,n,s,a,o)}else if(y&&!R){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));if(r<=0||s>e){const t=l-o+1;t>0&&C.push(o,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t)),a=r-o+1;a>0&&C.push(o,i,a);const h=l-n+1;h>0&&C.push(n,i,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(R&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const a=Math.sqrt(t-s),o=Math.max(m,Math.ceil(d-a)),l=Math.min(p,Math.floor(d+a));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=w-s;let x=-1,M=-1,g=0;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4)),g=M-x+1}let R=-1,y=0,S=-1,C=0;r<0||s>e?(R=o,y=l-o+1):(R=o,y=h-o+1,S=c,C=l-c+1),P.push(g>0?x:-1,g>0?g:-1,y>0?R:-1,y>0?y:-1,C>0?S:-1,C>0?C:-1)}P.length>0&&this.pixelRenderer.setPixelFillAndStrokeRuns(x,P,n,s,a,o,l,h,c,f)}}draw1PxStrokeFullCircleBresenhamOpaque(t,e,r,i,n,s){const a=this.pixelRenderer,o=a.width,l=a.height,h=(a.frameBufferUint8ClampedView,a.frameBufferUint32View),c=a.context,f=c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=r,x=Math.floor(t),M=Math.floor(e),m=Math.floor(u);if(m<0)return;if(0===m){if(u>=0){const r=Math.round(t),o=Math.round(e);a.setPixel(r,o,i,n,s,255)}return}let p=0,g=0;u>0&&2*u%2==1&&(p=1,g=1);if(x+m<0||x-m-p>=o||M+m<0||M-m-g>=l)return;let w=0,R=m,y=3-2*m;for(;w<=R;){const t=x+w,e=M+R,r=x+R,i=M+w,n=x+R,s=M-w-g,a=x+w,c=M-R-g,u=x-w-p,m=M-R-g,S=x-R-p,C=M-w-g,P=x-R-p,k=M+w,b=x-w-p,A=M+R;if(t>=0&&t<o&&e>=0&&e<l){const r=e*o+t;(!f||0!==f[r>>3]&&f[r>>3]&1<<7-(7&r))&&(h[r]=d)}if(r>=0&&r<o&&i>=0&&i<l&&w!==R){const t=i*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(n>=0&&n<o&&s>=0&&s<l){const t=s*o+n;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(a>=0&&a<o&&c>=0&&c<l){const t=c*o+a;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(u>=0&&u<o&&m>=0&&m<l){const t=m*o+u;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(S>=0&&S<o&&C>=0&&C<l&&w!==R){const t=C*o+S;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(P>=0&&P<o&&k>=0&&k<l){const t=k*o+P;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(b>=0&&b<o&&A>=0&&A<l){const t=A*o+b;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}y<0?y=y+4*w+6:(y=y+4*(w-R)+10,R--),w++}}draw1PxStrokeFullCircleBresenhamAlpha(t,e,r,i,n,s,a){const o=this.pixelRenderer,l=o.context.globalAlpha;if(0===a||l<=0)return;const h=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d.currentState?d.currentState.clippingMask:null,x=a/255*l,M=1-x;if(x<=0)return;const m=r,p=Math.floor(t),g=Math.floor(e),w=Math.floor(m);if(w<0)return;if(0===w){if(m>=0){const r=Math.round(t),l=Math.round(e);o.setPixel(r,l,i,n,s,a)}return}let R=0,y=0;m>0&&2*m%2==1&&(R=1,y=1);if(p+w<0||p-w-R>=h||g+w<0||g-w-y>=c)return;let S=0,C=w,P=3-2*w;const k=new Set;for(;S<=C;){const t=p+S,e=g+C,r=p+C,i=g+S,n=p+C,s=g-S-y,a=p+S,o=g-C-y,l=p-S-R,f=g-C-y,d=p-C-R,u=g-S-y,x=p-C-R,M=g+S,m=p-S-R,w=g+C;t>=0&&t<h&&e>=0&&e<c&&k.add(e*h+t),r>=0&&r<h&&i>=0&&i<c&&k.add(i*h+r),n>=0&&n<h&&s>=0&&s<c&&k.add(s*h+n),a>=0&&a<h&&o>=0&&o<c&&k.add(o*h+a),l>=0&&l<h&&f>=0&&f<c&&k.add(f*h+l),d>=0&&d<h&&u>=0&&u<c&&k.add(u*h+d),x>=0&&x<h&&M>=0&&M<c&&k.add(M*h+x),m>=0&&m<h&&w>=0&&w<c&&k.add(w*h+m),P<0?P=P+4*S+6:(P=P+4*(S-C)+10,C--),S++}if(k.size>0)for(const t of k){const e=4*t;let r=!1;if(u){const e=t>>3,i=7&t;0!==u[e]&&u[e]&1<<7-i||(r=!0)}if(!r){const t=f[e+3]/255*M,r=x+t;if(r>0){const a=1/r;f[e]=(i*x+f[e]*t)*a,f[e+1]=(n*x+f[e+1]*t)*a,f[e+2]=(s*x+f[e+2]*t)*a,f[e+3]=255*r}}}}_generateRelativeHorizontalExtentsBresenham(t){const e=t,r=Math.floor(e);if(r<0)return null;let i=0,n=0;if(e>0&&2*e%2==1&&(i=1,n=1),0===r)return{relativeExtents:[0],intRadius:0,xOffset:i,yOffset:n};const s=new Array(r+1).fill(0);let a=0,o=r,l=3-2*r;for(;a<=o;)s[o]=Math.max(s[o],a),s[a]=Math.max(s[a],o),l<0?l=l+4*a+6:(l=l+4*(a-o)+10,o--),a++;return{relativeExtents:s,intRadius:r,xOffset:i,yOffset:n}}drawOpaqueFillFullCircleBresenham(t,e,r,i,n,s){const a=this.pixelRenderer,o=a.width,l=a.height,h=(a.frameBufferUint8ClampedView,a.frameBufferUint32View),c=a.context,f=c&&c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=this._generateRelativeHorizontalExtentsBresenham(r);if(!u)return;const{relativeExtents:x,intRadius:M,xOffset:m,yOffset:p}=u;if(0===M&&r>=0){const r=Math.round(t),i=Math.round(e);if(r>=0&&r<o&&i>=0&&i<l){const t=i*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}return}const g=Math.floor(t-.5),w=Math.floor(e-.5),R=x[0];if(!(g+R<0||g-R-m>=o||w+M<0||w-M-p>=l))if(f)for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,i=g+e,n=w+t,s=w-t-p+1;if(n>=0&&n<l){const t=Math.max(0,r),e=n*o+Math.min(o-1,i);let s=n*o+t;for(;s<=e;){const t=s>>3,r=7&s;if(0===r&&s+7<=e){const e=f[t];if(255===e){const t=s+7;for(;s<=t;)h[s]=d,s++;continue}if(0===e){s+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[s]=d),s++}}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){const t=Math.max(0,r),e=s*o+Math.min(o-1,i);let n=s*o+t;for(;n<=e;){const t=n>>3,r=7&n;if(0===r&&n+7<=e){const e=f[t];if(255===e){const t=n+7;for(;n<=t;)h[n]=d,n++;continue}if(0===e){n+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[n]=d),n++}}}else for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,i=g+e,n=w+t,s=w-t-p+1;if(n>=0&&n<l){let t=n*o+Math.max(0,r);const e=n*o+Math.min(o-1,i);for(;t<=e;)h[t]=d,t++}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){let t=s*o+Math.max(0,r);const e=s*o+Math.min(o-1,i);for(;t<=e;)h[t]=d,t++}}}drawSemiTransparentFillFullCircleBresenham(t,e,r,i,n,s,a){const o=this.pixelRenderer,l=o.context.globalAlpha;if(0===a||l<=0)return;const h=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d&&d.currentState?d.currentState.clippingMask:null,x=a/255*l,M=1-x;if(x<=0)return;const m=this._generateRelativeHorizontalExtentsBresenham(r);if(!m)return;const{relativeExtents:p,intRadius:g,xOffset:w,yOffset:R}=m;if(0===g&&r>=0){const r=Math.round(t),l=Math.round(e);return void o.setPixel(r,l,i,n,s,a)}const y=Math.floor(t-.5),S=Math.floor(e-.5),C=p[0];if(y+C<0||y-C-w>=h||S+g<0||S-g-R>=c)return;const P=t=>{const e=4*t,r=f[e+3]/255*M,a=x+r;if(a>0){const t=1/a;f[e]=(i*x+f[e]*r)*t,f[e+1]=(n*x+f[e+1]*r)*t,f[e+2]=(s*x+f[e+2]*r)*t,f[e+3]=255*a}};if(u)for(let t=0;t<=g;t++){const e=p[t],r=y-e-w+1,i=y+e,n=S+t,s=S-t-R+1;if(n>=0&&n<c){const t=Math.max(0,r),e=n*h+Math.min(h-1,i);let s=n*h+t;for(;s<=e;){const t=s>>3,r=7&s,i=1<<7-r;if(0===r&&s+7<=e){if(0===u[t]){s+=8;continue}}0!==(u[t]&i)&&P(s),s++}}if(t>0&&!(1===t&&0===R)&&s>=0&&s<c){const t=Math.max(0,r),e=s*h+Math.min(h-1,i);let n=s*h+t;for(;n<=e;){const t=n>>3,r=7&n,i=1<<7-r;if(0===r&&n+7<=e){if(0===u[t]){n+=8;continue}}0!==(u[t]&i)&&P(n),n++}}}else for(let t=0;t<=g;t++){const e=p[t],r=y-e-w+1,i=y+e,n=S+t,s=S-t-R+1;if(n>=0&&n<c){let t=n*h+Math.max(0,r);const e=n*h+Math.min(h-1,i);for(;t<=e;)P(t),t++}if(t>0&&!(1===t&&0===R)&&s>=0&&s<c){let t=s*h+Math.max(0,r);const e=s*h+Math.min(h-1,i);for(;t<=e;)P(t),t++}}}_clipCircleShape(t){const{center:e,radius:r}=t,i=this.pixelRenderer,n=this._generateRelativeHorizontalExtentsBresenham(r);if(!n)return;const{relativeExtents:s,intRadius:a,xOffset:o,yOffset:l}=n;if(0===a&&r>=0){const t=Math.round(e.x),r=Math.round(e.y);return void i.clipPixel(t,r)}const h=Math.floor(e.x-.5),c=Math.floor(e.y-.5);for(let t=0;t<=a;t++){const e=s[t],r=h-e-o+1,n=h+e,a=c+t,f=c-t-l+1;if(a>=0&&a<i.height){const t=Math.max(0,r),e=Math.min(i.width-1,n);for(let r=t;r<=e;r++)i.clipPixel(r,a)}if(t>0&&!(1===t&&0===l)&&f>=0&&f<i.height){const t=Math.max(0,r),e=Math.min(i.width-1,n);for(let r=t;r<=e;r++)i.clipPixel(r,f)}}}}class SWRendererRoundedRect{constructor(t,e,r,i,n,s,a){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=s,this.swRectRenderer=a}drawRoundedRect(t){const{center:e,width:r,height:i,radius:n,rotation:s,strokeWidth:a,strokeColor:{r:o,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:x}}=t;if(isNearMultipleOf90Degrees(s)){const{adjustedWidth:t,adjustedHeight:M}=getRotatedDimensionsIfTheCase(r,i,s),m=n>2?n-1:n;0==a||255===c||a<5&&255===c?this.drawCrispAxisAlignedRoundedRectThinOpaqueStroke(e.x,e.y,t,M,m,a,o,l,h,c,f,d,u,x):this.drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(e.x,e.y,t,M,m,a,o,l,h,c,f,d,u,x)}else this.drawRotatedRoundedRect(e.x,e.y,r,i,n,s,a,o,l,h,c,f,d,u,x)}drawCrispAxisAlignedRoundedRectThinOpaqueStroke(t,e,r,i,n,s,a,o,l,h,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");if(u>0&&this.drawRoundedRectFill(t,e,r,i,n,s,c,f,d,u,255==h&&s>0),h>0&&s>0)if(1===s){let s=getRectangularStrokeGeometry(t,e,r,i),c=Math.round(Math.min(n,Math.min(s.w,s.h)/2));for(let t=Math.floor(s.x+c);t<s.x+s.w-c;t++)this.pixelRenderer.setPixel(t,s.y-.5,a,o,l,h),this.pixelRenderer.setPixel(t,s.y+s.h-.5,a,o,l,h);for(let t=Math.floor(s.y+c);t<s.y+s.h-c;t++)this.pixelRenderer.setPixel(s.x-.5,t,a,o,l,h),this.pixelRenderer.setPixel(s.x+s.w-.5,t,a,o,l,h);const f=(t,e,r,i)=>{for(let n=r;n<=i;n+=Math.PI/180){const r=c-.5,i=t+r*Math.cos(n),s=e+r*Math.sin(n);this.pixelRenderer.setPixel(Math.floor(i),Math.floor(s),a,o,l,h)}};f(s.x+c,s.y+c,Math.PI,3*Math.PI/2),f(s.x+s.w-c,s.y+c,3*Math.PI/2,2*Math.PI),f(s.x+s.w-c,s.y+s.h-c,0,Math.PI/2),f(s.x+c,s.y+s.h-c,Math.PI/2,Math.PI)}else this.drawRoundedRectStroke(t,e,r,i,n,s,a,o,l,h)}drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(t,e,r,i,n,s,a,o,l,h,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");u>0&&this.drawRoundedRectFill(t,e,r,i,n,s,c,f,d,u,255==h&&s>0),h>0&&s>0&&this.drawRoundedRectStroke(t,e,r,i,n,s,a,o,l,h)}drawRoundedRectFill(t,e,r,i,n,s,a,o,l,h,c=!1){let f=null;f=c?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i));let d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));function u(t,e){if(t>=f.x+d&&t<f.x+f.w-d&&e>=f.y&&e<f.y+f.h)return!0;if(t>=f.x&&t<f.x+f.w&&e>=f.y+d&&e<f.y+f.h-d)return!0;const r=[{x:f.x+d,y:f.y+d},{x:f.x+f.w-d,y:f.y+d},{x:f.x+f.w-d,y:f.y+f.h-d},{x:f.x+d,y:f.y+f.h-d}];for(const i of r){const r=t-i.x+1,n=e-i.y+1;if(r*r+n*n<d*d)return!0}return!1}const x=this.pixelRenderer.context.globalAlpha,M=255===h&&x>=1;let m=0;M&&(m=255<<24|l<<16|o<<8|a);for(let t=Math.floor(f.y);t<=Math.ceil(f.y+f.h);t++)for(let e=Math.floor(f.x);e<=Math.ceil(f.x+f.w);e++)if(u(Math.ceil(e),Math.ceil(t))){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}M?this.frameBufferUint32View[r]=m:this.pixelRenderer.setPixel(e,t,a,o,l,h)}}drawRoundedRectStroke(t,e,r,i,n,s,a,o,l,h){const c=s/2;let f=getRectangularStrokeGeometry(t,e,r,i),d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));const u=new PixelSet(this.pixelRenderer),x=new ScanlineSpans;for(let t=f.y-c;t<f.y+c;t++)x.addSpan(t,f.x+d,f.x+f.w-d);for(let t=f.y+f.h-c;t<f.y+f.h+c;t++)x.addSpan(t,f.x+d,f.x+f.w-d);x.addToPixelSet(u,a,o,l,h);const M=new ScanlineSpans,m=new ScanlineSpans;for(let t=f.y+d;t<f.y+f.h-d;t++){for(let e=f.x-c;e<f.x+c;e++)M.addPixel(e,t);for(let e=f.x+f.w-c;e<f.x+f.w+c;e++)m.addPixel(e,t)}M.addToPixelSet(u,a,o,l,h),m.addToPixelSet(u,a,o,l,h);const p=(t,e,r,i)=>{const n=new ScanlineSpans,s=Math.PI/180;for(let a=r;a<=i;a+=s)for(let r=-c;r<c;r++){const i=d+r,s=t+i*Math.cos(a),o=e+i*Math.sin(a);n.addPixel(Math.floor(s),Math.floor(o))}n.addToPixelSet(u,a,o,l,h)};p(f.x+d,f.y+d,Math.PI,3*Math.PI/2),p(f.x+f.w-d,f.y+d,3*Math.PI/2,2*Math.PI),p(f.x+f.w-d,f.y+f.h-d,0,Math.PI/2),p(f.x+d,f.y+f.h-d,Math.PI/2,Math.PI),u.paint()}drawRotatedRoundedRect(t,e,r,i,n,s,a,o,l,h,c,f,d,u,x){const M=Math.cos(s),m=Math.sin(s),p=r/2,g=i/2,w=[[-p+n,-g+n],[p-n,-g+n],[p-n,g-n],[-p+n,g-n]].map((([r,i])=>({x:t+r*M-i*m,y:e+r*m+i*M}))),R=w.map(((t,e)=>{const r=w[(e+1)%4],i=r.x-t.x,n=r.y-t.y,s=Math.sqrt(i*i+n*n);return{dx:i/s,dy:n/s}})),y=w.map(((t,e)=>{const r=R[(e+3)%4],i=R[e],s=-r.dy,a=r.dx,o=-i.dy,l=i.dx;return{start:{x:t.x-n*s,y:t.y-n*a},end:{x:t.x-n*o,y:t.y-n*l}}}));if(x>0){this.swRectRenderer.fillRotatedRect(t,e,r-2*n,i-2*n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+-n*m,e+(-i/2+n/2)*M,r-2*n,n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+(r/2-n/2)*M,e+(r/2-n/2)*m,n,i-2*n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+n*m,e+(i/2-n/2)*M,r-2*n,n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+(-r/2+n/2)*M,e+(-r/2+n/2)*m,n,i-2*n,s,!1,!1,f,d,u,x);const a=180*s/Math.PI;w.forEach(((t,e)=>{const r=[[180,270],[270,360],[0,90],[90,180]][e],i=(r[0]+a)%360,s=(r[1]+a)%360;drawArcSWHelper(t.x,t.y,n,i,s,f,d,u,x,!0)}))}if(c>0){for(let t=0;t<4;t++){const e=y[t],r=y[(t+1)%4];this.lineRenderer.drawLineThick(e.end.x,e.end.y,r.start.x,r.start.y,a,o,l,h,c)}const t=180*s/Math.PI;w.forEach(((e,r)=>{const i=[[180,270],[270,360],[0,90],[90,180]][r],s=(i[0]+t)%360,f=(i[1]+t)%360;drawArcSWHelper(e.x,e.y,n,s,f,o,l,h,c,!1,a)}))}}}class CrispSwCanvas{static version="1.0.2";constructor(t,e){if("object"==typeof t){const e=t;this.width=e.width,this.height=e.height,this.title=e.title||""}else this.width=t,this.height=e,this.title="";this._context=new CrispSwContext(this)}getContext(t){if("2d"!==t)throw new Error("Only '2d' context is supported");return this._context}}const isNode="undefined"==typeof window&&"undefined"!=typeof process;class CrispSwContext{constructor(t){this.canvas=t,t.title||(t.title=""),this.displayCanvas={width:t.width,height:t.height,title:t.title},this.title=t.title,this.stateStack=[new ContextState(t.width,t.height)],this.frameBufferUint8ClampedView=new Uint8ClampedArray(t.width*t.height*4).fill(0),this.frameBufferUint32View=new Uint32Array(this.frameBufferUint8ClampedView.buffer),this.tempClippingMask=new Uint8Array(Math.ceil(t.width*t.height/8)).fill(0),this.pixelRenderer=new SWRendererPixel(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this),this.lineRenderer=new SWRendererLine(this.pixelRenderer),this.rectRenderer=new SWRendererRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer),this.roundedRectRenderer=new SWRendererRoundedRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer,this.rectRenderer),this.circleRenderer=new SWRendererCircle(this.pixelRenderer),this.arcRenderer=new SWRendererArc(this.pixelRenderer)}get currentState(){return this.stateStack[this.stateStack.length-1]}save(){this.stateStack.push(this.currentState.clone())}restore(){if(this.stateStack.length<=1)throw new Error("Cannot restore() - stack is empty");this.stateStack.pop()}scale(t,e){this.currentState.transform=this.currentState.transform.scale(t,e)}rotate(t){this.currentState.transform=this.currentState.transform.rotate(t)}translate(t,e){this.currentState.transform=this.currentState.transform.translate(t,e)}resetTransform(){this.currentState.transform.reset()}set fillStyle(t){this.currentState.fillColor=parseColor(t)}set strokeStyle(t){this.currentState.strokeColor=parseColor(t)}set lineWidth(t){this.currentState.lineWidth=t}set globalAlpha(t){this.currentState.globalAlpha=Math.max(0,Math.min(1,t))}get globalAlpha(){return this.currentState.globalAlpha}beginPath(){this.tempClippingMask.fill(0)}fill(){throw new Error("fill() is not supported - use fillRect() instead")}stroke(){throw new Error("stroke() is not supported - use strokeRect() instead")}strokeLine(t,e,r,i){const n=this.currentState,s=getScaledLineWidth(n.transform.elements,n.lineWidth),a=transformPoint(t,e,n.transform.elements),o=transformPoint(r,i,n.transform.elements);this.lineRenderer.drawLine({start:{x:a.tx,y:a.ty},end:{x:o.tx,y:o.ty},thickness:s,color:n.strokeColor})}clearRect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),a=getRotationAngle(n.transform.elements);this.rectRenderer.clearRect({center:{x:s.tx,y:s.ty},width:r,height:i,rotation:a})}rect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),a=getRotationAngle(n.transform.elements),{scaleX:o,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*o,height:i*l,rotation:a,clippingOnly:!0})}clip(){for(let t=0;t<this.currentState.clippingMask.length;t++)this.currentState.clippingMask[t]=this.currentState.clippingMask[t]&this.tempClippingMask[t]}fillRect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),a=getRotationAngle(n.transform.elements),{scaleX:o,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*o,height:i*l,rotation:a,clippingOnly:!1,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:n.fillColor})}strokeRect(t,e,r,i){const n=this.currentState,s=getScaledLineWidth(n.transform.elements,n.lineWidth),a=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:a.tx,y:a.ty},width:r*l,height:i*h,rotation:o,clippingOnly:!1,strokeWidth:s,strokeColor:n.strokeColor,fillColor:{r:0,g:0,b:0,a:0}})}blitToCanvas(t){if(isNode)return;const e=new ImageData(this.frameBufferUint8ClampedView,this.canvas.width,this.canvas.height);t.getContext("2d").putImageData(e,0,0)}fillCircle(t,e,r,i,n,s,a){const o=this.currentState,l=transformPoint(t,e,o.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(o.transform.elements),f=r*Math.max(h,c),d={center:{x:l.tx,y:l.ty},radius:f,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:{r:i,g:n,b:s,a:a}};this.circleRenderer.drawCircle(d)}strokeCircle(t,e,r,i,n,s,a,o){const l=this.currentState,h=transformPoint(t,e,l.transform.elements),{scaleX:c,scaleY:f}=getScaleFactors(l.transform.elements),d=r*Math.max(c,f),u=getScaledLineWidth(l.transform.elements,i),x={center:{x:h.tx,y:h.ty},radius:d,strokeWidth:u,strokeColor:{r:n,g:s,b:a,a:o},fillColor:{r:0,g:0,b:0,a:0}};this.circleRenderer.drawCircle(x)}fillAndStrokeCircle(t,e,r,i,n,s,a,o,l,h,c,f){const d=this.currentState,u=transformPoint(t,e,d.transform.elements),{scaleX:x,scaleY:M}=getScaleFactors(d.transform.elements),m=r*Math.max(x,M),p=getScaledLineWidth(d.transform.elements,o),g={center:{x:u.tx,y:u.ty},radius:m,strokeWidth:p,strokeColor:{r:l,g:h,b:c,a:f},fillColor:{r:i,g:n,b:s,a:a}};this.circleRenderer.drawCircle(g)}getImageData(t,e,r,i){const n=this.canvas.width,s=this.canvas.height;t=Math.max(0,Math.min(Math.floor(t),n)),e=Math.max(0,Math.min(Math.floor(e),s)),r=Math.max(0,Math.min(Math.floor(r),n-t)),i=Math.max(0,Math.min(Math.floor(i),s-e));const a=new Uint8ClampedArray(r*i*4);if(0===t&&0===e&&r===n&&i===s)a.set(this.frameBufferUint8ClampedView);else for(let s=0;s<i;s++)for(let i=0;i<r;i++){const o=4*((e+s)*n+(t+i)),l=4*(s*r+i);a[l]=this.frameBufferUint8ClampedView[o],a[l+1]=this.frameBufferUint8ClampedView[o+1],a[l+2]=this.frameBufferUint8ClampedView[o+2],a[l+3]=this.frameBufferUint8ClampedView[o+3]}const o=new ImageData(a,r,i);return void 0===o.canvasTitle&&Object.defineProperty(o,"canvasTitle",{get:()=>this.canvas.title||this.title||"",configurable:!0}),o}roundRect(t,e,r,i,n){const s=this.currentState,{scaleX:a,scaleY:o}=(transformPoint(t+r/2,e+i/2,s.transform.elements),getRotationAngle(s.transform.elements),getScaleFactors(s.transform.elements));throw new Error("CrispSwContext.roundRect() for path definition / clipping is not yet implemented.")}fillRoundRect(t,e,r,i,n){const s=this.currentState,a=transformPoint(t+r/2,e+i/2,s.transform.elements),o=getRotationAngle(s.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(s.transform.elements),c=n*Math.min(Math.abs(l),Math.abs(h));this.roundedRectRenderer.drawRoundedRect({center:{x:a.tx,y:a.ty},width:r*l,height:i*h,radius:c,rotation:o,fillColor:s.fillColor,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0}})}strokeRoundRect(t,e,r,i,n){const s=this.currentState,a=getScaledLineWidth(s.transform.elements,s.lineWidth),o=transformPoint(t+r/2,e+i/2,s.transform.elements),l=getRotationAngle(s.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(s.transform.elements),f=n*Math.min(Math.abs(h),Math.abs(c));this.roundedRectRenderer.drawRoundedRect({center:{x:o.tx,y:o.ty},width:r*h,height:i*c,radius:f,rotation:l,fillColor:{r:0,g:0,b:0,a:0},strokeWidth:a,strokeColor:s.strokeColor})}arc(t,e,r,i,n,s=!1){if(!(Math.abs(Math.abs(n-i)-2*Math.PI)<1e-9))throw new Error("CrispSwContext.arc() for path definition/clipping is only implemented for full circles. Use fillArc/strokeArc for drawing partial arcs.");{const i=this.currentState,n=transformPoint(t,e,i.transform.elements),{scaleX:s,scaleY:a}=getScaleFactors(i.transform.elements),o=r*Math.max(Math.abs(s),Math.abs(a));this.circleRenderer.drawCircle({center:{x:n.tx,y:n.ty},radius:o,clippingOnly:!0,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:{r:0,g:0,b:0,a:0}})}}fillArc(t,e,r,i,n,s=!1){const a=this.currentState,o=transformPoint(t,e,a.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(a.transform.elements),c=r*Math.min(Math.abs(l),Math.abs(h)),f=180*i/Math.PI,d=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:o.tx,y:o.ty},radius:c,startAngle:f,endAngle:d,anticlockwise:s,fillColor:a.fillColor,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0}})}strokeArc(t,e,r,i,n,s=!1){const a=this.currentState,o=getScaledLineWidth(a.transform.elements,a.lineWidth),l=transformPoint(t,e,a.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(a.transform.elements),f=r*Math.min(Math.abs(h),Math.abs(c)),d=180*i/Math.PI,u=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:l.tx,y:l.ty},radius:f,startAngle:d,endAngle:u,anticlockwise:s,fillColor:{r:0,g:0,b:0,a:0},strokeWidth:o,strokeColor:a.strokeColor})}fillAndStrokeArc(t,e,r,i,n,s=!1){const a=this.currentState,o=getScaledLineWidth(a.transform.elements,a.lineWidth),l=transformPoint(t,e,a.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(a.transform.elements),f=r*Math.min(Math.abs(h),Math.abs(c)),d=180*i/Math.PI,u=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:l.tx,y:l.ty},radius:f,startAngle:d,endAngle:u,anticlockwise:s,fillColor:a.fillColor,strokeWidth:o,strokeColor:a.strokeColor})}}