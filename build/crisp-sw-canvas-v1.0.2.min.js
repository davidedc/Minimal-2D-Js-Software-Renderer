/* CrispSwCanvas v1.0.2 */
class TransformationMatrix{constructor(){this.elements=new Float64Array([1,0,0,0,1,0,0,0,1])}clone(){const t=new TransformationMatrix;return t.elements.set(this.elements),t}reset(){return this.elements.set([1,0,0,0,1,0,0,0,1]),this}get(t,e){return this.elements[3*e+t]}set(t,e,r){this.elements[3*e+t]=r}multiply(t){const e=new TransformationMatrix;for(let r=0;r<3;r++)for(let i=0;i<3;i++){let n=0;for(let e=0;e<3;e++)n+=this.get(i,e)*t.get(e,r);e.set(i,r,n)}return e}translate(t,e){const r=new TransformationMatrix;return r.elements.set([1,0,0,0,1,0,t,e,1]),this.multiply(r)}scale(t,e){const r=new TransformationMatrix;return r.elements.set([t,0,0,0,e,0,0,0,1]),this.multiply(r)}rotate(t){const e=new TransformationMatrix,r=Math.cos(t),i=Math.sin(t);return e.elements.set([r,i,0,-i,r,0,0,0,1]),this.multiply(e)}}function getScaledLineWidth(t,e){const r=Math.sqrt(t[0]*t[0]+t[1]*t[1]),i=Math.sqrt(t[3]*t[3]+t[4]*t[4]);return e*Math.max(Math.sqrt(r*i),1e-4)}function transformPoint(t,e,r){return{tx:r[0]*t+r[3]*e+r[6],ty:r[1]*t+r[4]*e+r[7]}}function getRotationAngle(t){return Math.atan2(-t[3],t[0])}function getScaleFactors(t){return{scaleX:Math.sqrt(t[0]*t[0]+t[1]*t[1]),scaleY:Math.sqrt(t[3]*t[3]+t[4]*t[4])}}class Color{constructor(t,e,r,i=255,n=!1){if(t<0||t>255||e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("Color components must be in range 0-255");if(n)this._r=Math.round(t),this._g=Math.round(e),this._b=Math.round(r),this._a=Math.round(i);else{const n=i/255;this._r=Math.round(t*n),this._g=Math.round(e*n),this._b=Math.round(r*n),this._a=Math.round(i)}}get premultipliedR(){return this._r}get premultipliedG(){return this._g}get premultipliedB(){return this._b}get premultipliedA(){return this._a}get r(){return 0===this._a?0:255===this._a?this._r:Math.round(255*this._r/this._a)}get g(){return 0===this._a?0:255===this._a?this._g:Math.round(255*this._g/this._a)}get b(){return 0===this._a?0:255===this._a?this._b:Math.round(255*this._b/this._a)}get a(){return this._a}toRGBA(){return[this.r,this.g,this.b,this.a]}toPremultipliedRGBA(){return[this._r,this._g,this._b,this._a]}get normalizedAlpha(){return this._a/255}get isTransparent(){return 0===this._a}get isOpaque(){return 255===this._a}withGlobalAlpha(t){if(t<0||t>1)throw new Error("Global alpha must be in range 0-1");const e=this.r,r=this.g,i=this.b,n=this.a,a=Math.round(n*t);return new Color(e,r,i,a,!1)}blendOver(t){if(255===this._a)return this;if(0===this._a)return t;const e=1-this.normalizedAlpha,r=Math.round(this._r+t._r*e),i=Math.round(this._g+t._g*e),n=Math.round(this._b+t._b*e),a=Math.round(this._a+t._a*e);return new Color(r,i,n,a,!0)}toBMP(){return{r:this.r,g:this.g,b:this.b}}toCSS(){const t=(this.a/255).toFixed(3).replace(/\.?0+$/,"");return`rgba(${this.r}, ${this.g}, ${this.b}, ${t})`}toString(){return`Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`}equals(t){return t instanceof Color&&this._r===t._r&&this._g===t._g&&this._b===t._b&&this._a===t._a}}Color.transparent=new Color(0,0,0,0),Color.black=new Color(0,0,0,255),Color.fromCSS=function(t,e){if(!t||"string"!=typeof t)throw new Error("Invalid color format: must be a string");const r=e.parse(t);return new Color(r.r,r.g,r.b,r.a,!1)};class ColorParser{constructor(){this._cache=new Map,this._namedColors={black:{r:0,g:0,b:0},silver:{r:192,g:192,b:192},gray:{r:128,g:128,b:128},white:{r:255,g:255,b:255},maroon:{r:128,g:0,b:0},red:{r:255,g:0,b:0},purple:{r:128,g:0,b:128},fuchsia:{r:255,g:0,b:255},green:{r:0,g:128,b:0},lime:{r:0,g:255,b:0},olive:{r:128,g:128,b:0},yellow:{r:255,g:255,b:0},navy:{r:0,g:0,b:128},blue:{r:0,g:0,b:255},teal:{r:0,g:128,b:128},aqua:{r:0,g:255,b:255},aliceblue:{r:240,g:248,b:255},antiquewhite:{r:250,g:235,b:215},aquamarine:{r:127,g:255,b:212},azure:{r:240,g:255,b:255},beige:{r:245,g:245,b:220},bisque:{r:255,g:228,b:196},blanchedalmond:{r:255,g:235,b:205},blueviolet:{r:138,g:43,b:226},brown:{r:165,g:42,b:42},burlywood:{r:222,g:184,b:135},cadetblue:{r:95,g:158,b:160},chartreuse:{r:127,g:255,b:0},chocolate:{r:210,g:105,b:30},coral:{r:255,g:127,b:80},cornflowerblue:{r:100,g:149,b:237},cornsilk:{r:255,g:248,b:220},crimson:{r:220,g:20,b:60},cyan:{r:0,g:255,b:255},darkblue:{r:0,g:0,b:139},darkcyan:{r:0,g:139,b:139},darkgoldenrod:{r:184,g:134,b:11},darkgray:{r:169,g:169,b:169},darkgreen:{r:0,g:100,b:0},darkgrey:{r:169,g:169,b:169},darkkhaki:{r:189,g:183,b:107},darkmagenta:{r:139,g:0,b:139},darkolivegreen:{r:85,g:107,b:47},darkorange:{r:255,g:140,b:0},darkorchid:{r:153,g:50,b:204},darkred:{r:139,g:0,b:0},darksalmon:{r:233,g:150,b:122},darkseagreen:{r:143,g:188,b:143},darkslateblue:{r:72,g:61,b:139},darkslategray:{r:47,g:79,b:79},darkslategrey:{r:47,g:79,b:79},darkturquoise:{r:0,g:206,b:209},darkviolet:{r:148,g:0,b:211},deeppink:{r:255,g:20,b:147},deepskyblue:{r:0,g:191,b:255},dimgray:{r:105,g:105,b:105},dimgrey:{r:105,g:105,b:105},dodgerblue:{r:30,g:144,b:255},firebrick:{r:178,g:34,b:34},floralwhite:{r:255,g:250,b:240},forestgreen:{r:34,g:139,b:34},gainsboro:{r:220,g:220,b:220},ghostwhite:{r:248,g:248,b:255},gold:{r:255,g:215,b:0},goldenrod:{r:218,g:165,b:32},grey:{r:128,g:128,b:128},greenyellow:{r:173,g:255,b:47},honeydew:{r:240,g:255,b:240},hotpink:{r:255,g:105,b:180},indianred:{r:205,g:92,b:92},indigo:{r:75,g:0,b:130},ivory:{r:255,g:255,b:240},khaki:{r:240,g:230,b:140},lavender:{r:230,g:230,b:250},lavenderblush:{r:255,g:240,b:245},lawngreen:{r:124,g:252,b:0},lemonchiffon:{r:255,g:250,b:205},lightblue:{r:173,g:216,b:230},lightcoral:{r:240,g:128,b:128},lightcyan:{r:224,g:255,b:255},lightgoldenrodyellow:{r:250,g:250,b:210},lightgray:{r:211,g:211,b:211},lightgreen:{r:144,g:238,b:144},lightgrey:{r:211,g:211,b:211},lightpink:{r:255,g:182,b:193},lightsalmon:{r:255,g:160,b:122},lightseagreen:{r:32,g:178,b:170},lightskyblue:{r:135,g:206,b:250},lightslategray:{r:119,g:136,b:153},lightslategrey:{r:119,g:136,b:153},lightsteelblue:{r:176,g:196,b:222},lightyellow:{r:255,g:255,b:224},limegreen:{r:50,g:205,b:50},linen:{r:250,g:240,b:230},magenta:{r:255,g:0,b:255},mediumaquamarine:{r:102,g:205,b:170},mediumblue:{r:0,g:0,b:205},mediumorchid:{r:186,g:85,b:211},mediumpurple:{r:147,g:112,b:219},mediumseagreen:{r:60,g:179,b:113},mediumslateblue:{r:123,g:104,b:238},mediumspringgreen:{r:0,g:250,b:154},mediumturquoise:{r:72,g:209,b:204},mediumvioletred:{r:199,g:21,b:133},midnightblue:{r:25,g:25,b:112},mintcream:{r:245,g:255,b:250},mistyrose:{r:255,g:228,b:225},moccasin:{r:255,g:228,b:181},navajowhite:{r:255,g:222,b:173},oldlace:{r:253,g:245,b:230},olivedrab:{r:107,g:142,b:35},orange:{r:255,g:165,b:0},orangered:{r:255,g:69,b:0},orchid:{r:218,g:112,b:214},palegoldenrod:{r:238,g:232,b:170},palegreen:{r:152,g:251,b:152},paleturquoise:{r:175,g:238,b:238},palevioletred:{r:219,g:112,b:147},papayawhip:{r:255,g:239,b:213},peachpuff:{r:255,g:218,b:185},peru:{r:205,g:133,b:63},pink:{r:255,g:192,b:203},plum:{r:221,g:160,b:221},powderblue:{r:176,g:224,b:230},rebeccapurple:{r:102,g:51,b:153},rosybrown:{r:188,g:143,b:143},royalblue:{r:65,g:105,b:225},saddlebrown:{r:139,g:69,b:19},salmon:{r:250,g:128,b:114},sandybrown:{r:244,g:164,b:96},seagreen:{r:46,g:139,b:87},seashell:{r:255,g:245,b:238},sienna:{r:160,g:82,b:45},skyblue:{r:135,g:206,b:235},slateblue:{r:106,g:90,b:205},slategray:{r:112,g:128,b:144},slategrey:{r:112,g:128,b:144},snow:{r:255,g:250,b:250},springgreen:{r:0,g:255,b:127},steelblue:{r:70,g:130,b:180},tan:{r:210,g:180,b:140},thistle:{r:216,g:191,b:216},tomato:{r:255,g:99,b:71},turquoise:{r:64,g:224,b:208},violet:{r:238,g:130,b:238},wheat:{r:245,g:222,b:179},whitesmoke:{r:245,g:245,b:245},yellowgreen:{r:154,g:205,b:50}}}parse(t){if(this._cache.has(t))return this._cache.get(t);let e;if("string"!=typeof t)e={r:0,g:0,b:0,a:255};else{const r=t.trim().toLowerCase();if(r.startsWith("#"))e=this._parseHex(r);else if(r.startsWith("rgb"))e=this._parseRGB(r);else if(this._namedColors[r]){const t=this._namedColors[r];e={r:t.r,g:t.g,b:t.b,a:255}}else e={r:0,g:0,b:0,a:255}}return this._cache.set(t,e),e}_parseHex(t){if(3===(t=t.substring(1)).length&&(t=t.split("").map((t=>t+t)).join("")),6===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:255}}if(8===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:parseInt(t.substring(6,8),16)}}return{r:0,g:0,b:0,a:255}}_parseRGB(t){const e=t.match(/rgba?\s*\(\s*([^)]+)\s*\)/);if(!e)return{r:0,g:0,b:0,a:255};const r=e[1].split(",").map((t=>t.trim()));if(r.length<3)return{r:0,g:0,b:0,a:255};const i=Math.max(0,Math.min(255,parseInt(r[0])||0)),n=Math.max(0,Math.min(255,parseInt(r[1])||0)),a=Math.max(0,Math.min(255,parseInt(r[2])||0));let s=255;if(r.length>=4){const t=parseFloat(r[3]);isNaN(t)||(s=Math.max(0,Math.min(255,Math.round(255*t))))}return{r:i,g:n,b:a,a:s}}clearCache(){this._cache.clear()}}class ContextState{constructor(t,e,r,i,n,a,s,o){this.canvasWidth=t,this.canvasHeight=e,this.lineWidth=r||1,this.transform=i||new TransformationMatrix,this.strokeColor=n||Color.black,this.fillColor=a||Color.black,this.globalAlpha=s||1,this.clippingMask=o||new Uint8Array(Math.ceil(t*e/8)).fill(255)}clone(){const t=new Uint8Array(this.clippingMask);return new ContextState(this.canvasWidth,this.canvasHeight,this.lineWidth,this.transform.clone(),this.strokeColor,this.fillColor,this.globalAlpha,t)}}function pointInPolygon(t,e,r){let i=!1;for(let n=0,a=r.length-1;n<r.length;a=n++){const s=r[n].x,o=r[n].y,l=r[a].x,h=r[a].y;o>e!=h>e&&t<(l-s)*(e-o)/(h-o)+s&&(i=!i)}return i}function extendLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,a=Math.sqrt(i*i+n*n);if(0===a)return{start:t,end:e};const s=i/a,o=n/a;return{start:{x:t.x-s*r,y:t.y-o*r},end:{x:e.x+s*r,y:e.y+o*r}}}function shortenLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,a=Math.sqrt(i*i+n*n);if(0===a)return{start:t,end:e};const s=i/a,o=n/a;return{start:{x:t.x+s*r,y:t.y+o*r},end:{x:e.x-s*r,y:e.y-o*r}}}function alignToPixelBoundary(t){return{x:Math.round(t.x)+.5,y:Math.round(t.y)+.5}}function toIntegerPoint(t){return{x:Math.round(t.x),y:Math.round(t.y)}}function roundCornerOfRectangularGeometry(t){const{x:e,y:r,w:i,h:n}=t;return{x:Math.round(e),y:Math.round(r),w:i,h:n}}function roundCornerOfRectangularGeometryWithWarning(t){const e=roundCornerOfRectangularGeometry(t);return e.x===t.x&&e.y===t.y||console.warn("Rectangular geometry is not at a grid point, rounding to nearest grid point. When this happens, HTML5 Canvas would do a non-crisp fill, while the SW renderer will do a crisp fill."),e}function getRectangularFillGeometry(t,e,r,i){return{x:t-r/2,y:e-i/2,w:r,h:i}}var getRectangularStrokeGeometry=getRectangularFillGeometry;function checkBasicConditionsForCrispRendering(t,e,r,i,n){Number.isInteger(r)&&Number.isInteger(i)||console.warn("Width and height must be integers for crisp rendering"),Number.isInteger(n)||console.warn("Stroke width must be an integer for crisp rendering"),Number.isInteger(t)||t%1==.5||console.warn("Center X must be an integer or *.5 for crisp rendering"),Number.isInteger(e)||e%1==.5||console.warn("Center Y must be an integer or *.5 for crisp rendering ")}class PixelSet{constructor(t){this.pixels=new Map,this.pixelRenderer=t}addPixel(t,e,r,i,n,a){const s=`${Math.round(t)},${Math.round(e)}`;this.pixels.set(s,{x:Math.round(t),y:Math.round(e),r:r,g:i,b:n,a:a})}paint(){for(const t of this.pixels.values())this.pixelRenderer.setPixel(t.x,t.y,t.r,t.g,t.b,t.a)}}class ScanlineSpans{constructor(){this.spans=new Map}addSpan(t,e,r){if(e>r&&([e,r]=[r,e]),this.spans.has(t)){const i=this.spans.get(t);i[0]=Math.min(i[0],e),i[1]=Math.max(i[1],r)}else this.spans.set(t,[e,r])}addPixel(t,e){if(e=Math.round(e),t=Math.round(t),this.spans.has(e)){const r=this.spans.get(e);r[0]=Math.min(r[0],t),r[1]=Math.max(r[1],t)}else this.spans.set(e,[t,t])}addToPixelSet(t,e,r,i,n){for(const[a,[s,o]]of this.spans)for(let l=s;l<=o;l++)t.addPixel(l,a,e,r,i,n)}}const ANGLE_TOLERANCE=.001;function isNearMultipleOf90Degrees(t){const e=(t%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(e)<.001||Math.abs(e-Math.PI/2)<.001||Math.abs(e-Math.PI)<.001||Math.abs(e-3*Math.PI/2)<.001||Math.abs(e-2*Math.PI)<.001}function getRotatedDimensionsIfTheCase(t,e,r){const i=(r%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(i-Math.PI/2)<.001||Math.abs(i-3*Math.PI/2)<.001?{adjustedWidth:e,adjustedHeight:t}:{adjustedWidth:t,adjustedHeight:e}}class SWRendererPixel{constructor(t,e,r,i,n){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,n?(this.context=n,this.tempClippingMask=n.tempClippingMask):this.context={globalAlpha:1}}clipPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=e*r+t,n=i>>3,a=7&i;this.tempClippingMask[n]|=1<<7-a}setPixel(t,e,r,i,n,a){t|=0,e|=0;const s=this.width,o=this.context.globalAlpha;if(t<0||t>=s||e<0||e>=this.height)return;const l=e*s+t,h=4*l;if(this.context.currentState){const t=this.context.currentState.clippingMask,e=l>>3,r=7&l;if(0===t[e])return;if(!(t[e]&1<<7-r))return}let c=0;if(255===a&&o>=1)return c=255<<24|n<<16|i<<8|r,void(this.frameBufferUint32View[l]=c);const f=a/255*o,d=this.frameBufferUint8ClampedView[h+3]/255*(1-f),u=f+d;if(u<=0)return;const g=1/u;this.frameBufferUint8ClampedView[h]=(r*f+this.frameBufferUint8ClampedView[h]*d)*g,this.frameBufferUint8ClampedView[h+1]=(i*f+this.frameBufferUint8ClampedView[h+1]*d)*g,this.frameBufferUint8ClampedView[h+2]=(n*f+this.frameBufferUint8ClampedView[h+2]*d)*g,this.frameBufferUint8ClampedView[h+3]=255*u}clearPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=4*(e*r+t);this.frameBufferUint8ClampedView[i]=0,this.frameBufferUint8ClampedView[i+1]=0,this.frameBufferUint8ClampedView[i+2]=0,this.frameBufferUint8ClampedView[i+3]=0}setPixelRuns(t,e,r,i,n){const a=this.width,s=this.height,o=this.frameBufferUint8ClampedView,l=this.frameBufferUint32View,h=this.context.globalAlpha,c=this.context.currentState,f=c?this.context.currentState.clippingMask:null,d=255===n&&h>=1;let u=0;d&&(u=255<<24|i<<16|r<<8|e);const g=d?1:n/255*h,x=d?0:1-g;if(!(g<=0))for(let n=0;n<t.length;n+=3){let h=0|t[n];const M=0|t[n+1];let p=0|t[n+2];if(M<0||M>=s)continue;if(h<0&&(p+=h,h=0,p<=0))continue;if(h+p>a&&(p=a-h,p<=0))continue;let m=M*a+h,w=4*m;if(d)for(let t=0;t<p;t++,m++,w+=4){if(c){const e=m>>3;if(0===f[e]){const e=8-(7&m),r=Math.min(e,p-t);t+=r-1,m+=r-1,w+=4*(r-1);continue}const r=7&m;if(!(f[e]&1<<7-r))continue}l[m]=u}else for(let t=0;t<p;t++,m++,w+=4){if(c){const e=m>>3;if(0===f[e]){const e=8-(7&m),r=Math.min(e,p-t);t+=r-1,m+=r-1,w+=4*(r-1);continue}const r=7&m;if(!(f[e]&1<<7-r))continue}const n=o[w+3]/255*x,a=g+n;if(a<=0)continue;const s=1/a;o[w]=(e*g+o[w]*n)*s,o[w+1]=(r*g+o[w+1]*n)*s,o[w+2]=(i*g+o[w+2]*n)*s,o[w+3]=255*a}}}setPixelFillAndStrokeRuns(t,e,r,i,n,a,s,o,l,h){t+=2;const c=this.width,f=this.height,d=this.frameBufferUint8ClampedView,u=this.frameBufferUint32View,g=this.context.globalAlpha,x=this.context.currentState,M=x?this.context.currentState.clippingMask:null,p=a/255*g,m=1-p,w=p>=1;let b=0;w&&(b=255<<24|n<<16|i<<8|r);const R=h/255*g,y=1-R,C=R>=1;let S=0;if(C&&(S=255<<24|l<<16|o<<8|s),p<=0&&R<=0)return;let P=t;for(let t=0;t<e.length;t+=6){if(P<0||P>=f){P++;continue}let a=-1!==e[t]?0|e[t]:-1,h=-1!==e[t+1]?0|e[t+1]:-1,g=-1!==e[t+2]?0|e[t+2]:-1,k=-1!==e[t+3]?0|e[t+3]:-1,_=-1!==e[t+4]?0|e[t+4]:-1,A=-1!==e[t+5]?0|e[t+5]:-1;const B=-1!==a&&h>0&&p>0,I=-1!==g&&k>0&&R>0,v=-1!==_&&A>0&&R>0;if(B||I||v){B&&(a<0&&(h+=a,a=0),a+h>c&&(h=c-a),h<=0&&(a=-1,h=0)),I&&(g<0&&(k+=g,g=0),g+k>c&&(k=c-g),k<=0&&(g=-1,k=0)),v&&(_<0&&(A+=_,_=0),_+A>c&&(A=c-_),A<=0&&(_=-1,A=0));for(let t=0;t<3;t++){let e,f,W,U,V,q,F,L,O=0;if(0===t){if(!B||-1===a||h<=0)continue;e=a,f=h,W=r,U=i,V=n,q=p,F=m,L=w,L&&(O=b)}else if(1===t){if(!I||-1===g||k<=0)continue;e=g,f=k,W=s,U=o,V=l,q=R,F=y,L=C,L&&(O=S)}else{if(!v||-1===_||A<=0)continue;e=_,f=A,W=s,U=o,V=l,q=R,F=y,L=C,L&&(O=S)}let T=P*c+e,H=4*T;for(let t=0;t<f;t++,T++,H+=4){if(x){const e=T>>3;if(e>=M.length)continue;if(0===M[e]){const e=8-(7&T),r=Math.min(e,f-t);t+=r-1,T+=r-1,H+=4*(r-1);continue}const r=7&T;if(!(M[e]&1<<7-r))continue}if(L)u[T]=O;else{const t=d[H+3]/255*F,e=q+t;if(e<=1e-5)continue;const r=1/e;d[H]=(W*q+d[H]*t)*r,d[H+1]=(U*q+d[H+1]*t)*r,d[H+2]=(V*q+d[H+2]*t)*r,d[H+3]=255*e}}}P++}else P++}}}class SWRendererLine{constructor(t){this.pixelRenderer=t,this._corners=[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],this._edges=[{p1:this._corners[0],p2:this._corners[1],invDeltaY:0,deltaX:0},{p1:this._corners[1],p2:this._corners[2],invDeltaY:0,deltaX:0},{p1:this._corners[2],p2:this._corners[3],invDeltaY:0,deltaX:0},{p1:this._corners[3],p2:this._corners[0],invDeltaY:0,deltaX:0}],this._intersections=new Array(8),this._pixelRuns=[]}drawLine(t){const{start:{x:e,y:r},end:{x:i,y:n},thickness:a,color:{r:s,g:o,b:l,a:h}}=t;if(1!==a)return void this.drawLineThick(e,r,i,n,a,s,o,l,h);let c=Math.floor(e),f=Math.floor(r),d=Math.floor(i),u=Math.floor(n);c===d&&(u>f?u--:f--),f===u&&(d>c?d--:c--);const g=this.pixelRenderer.context.globalAlpha;if(0===h||g<=0)return;const x=Math.abs(d-c),M=Math.abs(u-f);return 0===x?this._drawLine1px_vertical(c,f,u,s,o,l,h):0===M?this._drawLine1px_horizontal(c,d,f,s,o,l,h):x===M?this._drawLine1px_45degrees(c,f,d,u,s,o,l,h):this._drawLine1px_genericOrientations(c,f,d,u,x,M,s,o,l,h)}drawLine1px(t,e,r,i,n,a,s,o){t=Math.floor(t),e=Math.floor(e),r=Math.floor(r),i=Math.floor(i);const l=Math.abs(r-t),h=Math.abs(i-e);return 0===l?this._drawLine1px_vertical(t,e,i,n,a,s,o):0===h?this._drawLine1px_horizontal(t,r,e,n,a,s,o):l===h?this._drawLine1px_45degrees(t,e,r,i,n,a,s,o):this._drawLine1px_genericOrientations(t,e,r,i,l,h,n,a,s,o)}_drawLine1px_horizontal(t,e,r,i,n,a,s){const o=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(r<0||r>=c)return;const g=255===s&&u>=1;let x=0;g&&(x=255<<24|a<<16|n<<8|i);const M=g?1:s/255*u,p=g?0:1-M;if(t>e){let r=t;t=e,e=r}if(t<0&&(t=0),e>=h&&(e=h-1),t>e)return;const m=4*(r*h+t);for(let s=t;s<=e;s++){const e=m+4*(s-t),c=r*h+s;if(f){const t=c>>3,e=7&c;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(g)l[c]=x;else{const t=o[e+3]/255*p,r=M+t;if(r<=0)continue;const s=1/r;o[e]=(i*M+o[e]*t)*s,o[e+1]=(n*M+o[e+1]*t)*s,o[e+2]=(a*M+o[e+2]*t)*s,o[e+3]=255*r}}}_drawLine1px_vertical(t,e,r,i,n,a,s){const o=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(t<0||t>=h)return;const g=255===s&&u>=1;let x=0;g&&(x=255<<24|a<<16|n<<8|i);const M=g?1:s/255*u,p=g?0:1-M;if(e>r){let t=e;e=r,r=t}if(e<0&&(e=0),r>=c&&(r=c-1),!(e>r))for(let s=e;s<=r;s++){const e=4*(s*h+t),r=s*h+t;if(f){const t=r>>3,e=7&r;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(g)l[r]=x;else{const t=o[e+3]/255*p,r=M+t;if(r<=0)continue;const s=1/r;o[e]=(i*M+o[e]*t)*s,o[e+1]=(n*M+o[e+1]*t)*s,o[e+2]=(a*M+o[e+2]*t)*s,o[e+3]=255*r}}}_drawLine1px_45degrees(t,e,r,i,n,a,s,o){const l=this.pixelRenderer.frameBufferUint8ClampedView,h=this.pixelRenderer.frameBufferUint32View,c=this.pixelRenderer.width,f=this.pixelRenderer.height,d=this.pixelRenderer.context.currentState,u=d?this.pixelRenderer.context.currentState.clippingMask:null,g=this.pixelRenderer.context.globalAlpha,x=255===o&&g>=1;let M=0;x&&(M=255<<24|s<<16|a<<8|n);const p=x?1:o/255*g,m=x?0:1-p,w=t<r?1:-1,b=e<i?1:-1;let R=t,y=e;for(;!(R<0&&w<0||R>=c&&w>0||y<0&&b<0||y>=f&&b>0);){if(R>=0&&R<c&&y>=0&&y<f){const t=4*(y*c+R),e=y*c+R;let r=!0;if(d){const t=e>>3,i=7&e;!(t>=u.length||0===u[t])&&u[t]&1<<7-i||(r=!1)}if(r)if(x)h[e]=M;else{const e=l[t+3]/255*m,r=p+e;if(r>0){const i=1/r;l[t]=(n*p+l[t]*e)*i,l[t+1]=(a*p+l[t+1]*e)*i,l[t+2]=(s*p+l[t+2]*e)*i,l[t+3]=255*r}}}if(R===r&&y===i)break;R+=w,y+=b}}_drawLine1px_genericOrientations(t,e,r,i,n,a,s,o,l,h){const c=this.pixelRenderer.frameBufferUint8ClampedView,f=this.pixelRenderer.frameBufferUint32View,d=this.pixelRenderer.width,u=this.pixelRenderer.height,g=this.pixelRenderer.context.currentState,x=g?this.pixelRenderer.context.currentState.clippingMask:null,M=this.pixelRenderer.context.globalAlpha,p=255===h&&M>=1;let m=0;p&&(m=255<<24|l<<16|o<<8|s);const w=p?1:h/255*M,b=p?0:1-w,R=t<r?1:-1,y=e<i?1:-1;let C=n-a;for(;;){if(t>=0&&t<d&&e>=0&&e<u){const r=4*(e*d+t),i=e*d+t;let n=!0;if(g){const t=i>>3,e=7&i;!(t>=x.length||0===x[t])&&x[t]&1<<7-e||(n=!1)}if(n)if(p)f[i]=m;else{const t=c[r+3]/255*b,e=w+t;if(e>0){const i=1/e;c[r]=(s*w+c[r]*t)*i,c[r+1]=(o*w+c[r+1]*t)*i,c[r+2]=(l*w+c[r+2]*t)*i,c[r+3]=255*e}}}if(t===r&&e===i)break;const h=2*C;h>-a&&(C-=a,t+=R),h<n&&(C+=n,e+=y)}}drawLineThick(t,e,r,i,n,a,s,o,l){this._drawLineThickPolygonScan(t,e,r,i,n,a,s,o,l)}_drawLineThickBoundingBox(t,e,r,i,n,a,s,o,l){const h=(r-=.5)-(t-=.5),c=(i-=.5)-(e-=.5),f=Math.sqrt(h*h+c*c);if(0===f)return;const d=-c/f,u=h/f,g=n/2,x=[[t+d*g,e+u*g],[t-d*g,e-u*g],[r+d*g,i+u*g],[r-d*g,i-u*g]],M=Math.floor(Math.min(...x.map((t=>t[0])))),p=Math.ceil(Math.max(...x.map((t=>t[0])))),m=Math.floor(Math.min(...x.map((t=>t[1])))),w=Math.ceil(Math.max(...x.map((t=>t[1]))));for(let r=m;r<=w;r++)for(let i=M;i<=p;i++){const n=i-t,d=r-e,u=(n*h+d*c)/f,x=n-h/f*u,M=d-c/f*u,p=Math.sqrt(x*x+M*M);u>=0&&u<=f&&p<=g&&this.pixelRenderer.setPixel(i,r,a,s,o,l)}}_drawLineThickModifiedBresenham(t,e,r,i,n,a,s,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1;let u,g;const x=Math.sqrt(h*h+c*c);if(0===x){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,a,s,o,l);return}u=-c/x,g=h/x;const M=n/2;let p=h-c,m=t,w=e;for(;this._drawPerpendicularSegment(m,w,u,g,M,a,s,o,l),m!==r||w!==i;){const t=2*p;t>-c&&(p-=c,m+=f),t<h&&(p+=h,w+=d)}const b=(r-t)/x,R=(i-e)/x;this._drawSquareCap(t,e,u,g,M,-b,-R,a,s,o,l),this._drawSquareCap(r,i,u,g,M,b,R,a,s,o,l)}_drawPerpendicularSegment(t,e,r,i,n,a,s,o,l){const h=Math.ceil(n);this.pixelRenderer.setPixel(t,e,a,s,o,l);for(let c=1;c<=h;c++){const f=c/h*n,d=Math.round(t+r*f),u=Math.round(e+i*f),g=Math.round(t-r*f),x=Math.round(e-i*f);this.pixelRenderer.setPixel(d,u,a,s,o,l),this.pixelRenderer.setPixel(g,x,a,s,o,l)}}_drawSquareCap(t,e,r,i,n,a,s,o,l,h,c){const f=Math.ceil(n);for(let d=1;d<=f;d++){const u=d/f*n,g=Math.round(t+a*u),x=Math.round(e+s*u);this._drawPerpendicularSegment(g,x,r,i,n,o,l,h,c)}}_drawLineThickDistanceOptimized(t,e,r,i,n,a,s,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1,u=Math.sqrt((r-t)**2+(i-e)**2);if(0===u){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,a,s,o,l);return}const g=-(i-e)/u,x=(r-t)/u,M=Math.floor(n/2);let p=h-c,m=t,w=e;const b=[];for(;b.push({x:m,y:w}),m!==r||w!==i;){const t=2*p;t>-c&&(p-=c,m+=f),t<h&&(p+=h,w+=d)}for(const t of b)for(let e=-M;e<=M;e++){const r=Math.round(t.x+g*e),i=Math.round(t.y+x*e);this.pixelRenderer.setPixel(r,i,a,s,o,l)}const R=-(r-t)/u,y=-(i-e)/u;for(let r=1;r<=M;r++){const i=Math.round(t+R*r),n=Math.round(e+y*r);for(let t=-M;t<=M;t++){const e=Math.round(i+g*t),r=Math.round(n+x*t);this.pixelRenderer.setPixel(e,r,a,s,o,l)}}const C=(r-t)/u,S=(i-e)/u;for(let t=1;t<=M;t++){const e=Math.round(r+C*t),n=Math.round(i+S*t);for(let t=-M;t<=M;t++){const r=Math.round(e+g*t),i=Math.round(n+x*t);this.pixelRenderer.setPixel(r,i,a,s,o,l)}}}_drawLineThickParallelOffset(t,e,r,i,n,a,s,o,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.sqrt((r-t)**2+(i-e)**2);if(0===h){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,a,s,o,l);return}const c=-(i-e)/h,f=(r-t)/h,d=(r-t)/h,u=(i-e)/h,g=n/2,x=Math.ceil(g);for(let n=-x;n<=x;n++){const h=n/x*g,d=t+c*h,u=e+f*h,M=r+c*h,p=i+f*h;this._drawBresenhamLine(Math.round(d),Math.round(u),Math.round(M),Math.round(p),a,s,o,l)}for(let r=-x;r<=x;r++){const i=r/x*g;for(let r=1;r<=g;r++){const n=Math.round(t-d*r+c*i),h=Math.round(e-u*r+f*i);this.pixelRenderer.setPixel(n,h,a,s,o,l)}}for(let t=-x;t<=x;t++){const e=t/x*g;for(let t=1;t<=g;t++){const n=Math.round(r+d*t+c*e),h=Math.round(i+u*t+f*e);this.pixelRenderer.setPixel(n,h,a,s,o,l)}}}_drawBresenhamLine(t,e,r,i,n,a,s,o){const l=Math.abs(r-t),h=Math.abs(i-e),c=t<r?1:-1,f=e<i?1:-1;let d=l-h;for(;this.pixelRenderer.setPixel(t,e,n,a,s,o),t!==r||e!==i;){const r=2*d;r>-h&&(d-=h,t+=c),r<l&&(d+=l,e+=f)}}_drawLineThickPolygonScan(t,e,r,i,n,a,s,o,l){const h=r-t,c=i-e,f=Math.sqrt(h*h+c*c),d=this._pixelRuns;if(d.length=0,0===f){const r=n>>1,i=0|t,h=0|e;for(let t=-r;t<=r;t++)d.push(i-r,h+t,1+(r<<1));return void this.pixelRenderer.setPixelRuns(d,a,s,o,l)}const u=1/f,g=-c*u,x=h*u,M=.5*n,p=this._corners,m=g*M,w=x*M;p[0].x=t+m,p[0].y=e+w,p[1].x=t-m,p[1].y=e-w,p[2].x=r-m,p[2].y=i-w,p[3].x=r+m,p[3].y=i+w;const b=0|Math.min(p[0].y,p[1].y,p[2].y,p[3].y),R=Math.max(p[0].y,p[1].y,p[2].y,p[3].y)+.999|0,y=this._edges;for(let t=0;t<4;t++){const e=y[t],r=p[t],i=p[t+1&3];e.p1=r,e.p2=i,r.y!==i.y&&(e.invDeltaY=1/(i.y-r.y),e.deltaX=i.x-r.x)}const C=this._intersections;for(let t=b;t<=R;t++){let e=0;for(let r=0;r<4;r++){const i=y[r],n=i.p1,a=i.p2;if(n.y!==a.y&&(t>=n.y&&t<a.y||t>=a.y&&t<n.y)){const r=(t-n.y)*i.invDeltaY;C[e++]=n.x+r*i.deltaX}}if(1===e){const e=0|C[0];d.push(e,t,1)}else if(2===e){const e=C[0],r=C[1],i=e<r?0|e:0|r,n=(e>r?e+.999|0:r+.999|0)-i;n>0&&d.push(i,t,n)}}d.length>0&&this.pixelRenderer.setPixelRuns(d,a,s,o,l)}}class SWRendererRect{constructor(t,e,r,i,n,a){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=a}drawRect(t){if(t.clippingOnly){if(isNearMultipleOf90Degrees(t.rotation)){const{adjustedWidth:e,adjustedHeight:r}=getRotatedDimensionsIfTheCase(t.width,t.height,t.rotation);this.drawAxisAlignedRect(t.center.x,t.center.y,e,r,!0)}else this.drawRotatedRect(t.center.x,t.center.y,t.width,t.height,t.rotation,!0);return}const{center:e,width:r,height:i,rotation:n,clippingOnly:a,strokeWidth:s,strokeColor:{r:o,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:g}}=t;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:x}=getRotatedDimensionsIfTheCase(r,i,n);this.drawAxisAlignedRect(e.x,e.y,t,x,a,s,o,l,h,c,f,d,u,g)}else this.drawRotatedRect(e.x,e.y,r,i,n,a,s,o,l,h,c,f,d,u,g)}clearRect(t){const e=t.center,r=t.width,i=t.height,n=t.rotation;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:a}=getRotatedDimensionsIfTheCase(r,i,n);if(t===this.width&&a===this.height&&e.x===t/2&&e.y===a/2)return void this.frameBufferUint8ClampedView.fill(0);this.clearAxisAlignedRect(e.x,e.y,t,a)}else this.fillRotatedRect(e.x,e.y,r,i,n,!1,!0)}drawRotatedRect(t,e,r,i,n,a,s,o,l,h,c,f,d,u,g){const x=Math.cos(n),M=Math.sin(n);if((a||g>0)&&this.fillRotatedRect(t,e,r,i,n,a,!1,f,d,u,g),!a&&c>0){const n=r/2,a=i/2,f=[[-n,-a],[n,-a],[n,a],[-n,a]].map((([r,i])=>({x:t+r*x-i*M,y:e+r*M+i*x})));if(1===s)for(let t=0;t<4;t++){const e=f[t],r=f[(t+1)%4];this.lineRenderer.drawLine1px(e.x,e.y,r.x,r.y,o,l,h,c)}else{const t=s/2;for(let e=0;e<4;e+=2){const r=extendLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,s,o,l,h,c)}for(let e=1;e<4;e+=2){const r=shortenLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,s,o,l,h,c)}}}}drawAxisAlignedRect(t,e,r,i,n,a,s,o,l,h,c,f,d,u){if(n&&(a=0),n||u>0){let s=null;if(s=255==h&&a>0?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i)),n){for(let t=Math.floor(s.y);t<Math.ceil(s.y+s.h);t++)for(let e=Math.floor(s.x);e<Math.ceil(s.x+s.w);e++)this.pixelRenderer.clipPixel(e,t);return}const o=this.pixelRenderer.context.globalAlpha,l=255===u&&o>=1;let g=0;l&&(g=255<<24|d<<16|f<<8|c);for(let t=Math.floor(s.y);t<Math.ceil(s.y+s.h);t++)for(let e=Math.floor(s.x);e<Math.ceil(s.x+s.w);e++){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}l?this.frameBufferUint32View[r]=g:this.pixelRenderer.setPixel(e,t,c,f,d,u)}}if(h>0&&a>0){let n=getRectangularStrokeGeometry(t,e,r,i);const c=a/2;for(let t=Math.floor(n.x-c);t<n.x+n.w+c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(t,n.y+e,s,o,l,h),this.pixelRenderer.setPixel(t,n.y+n.h+e,s,o,l,h);for(let t=Math.floor(n.y+c);t<n.y+n.h-c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(n.x+e,t,s,o,l,h),this.pixelRenderer.setPixel(n.x+n.w+e,t,s,o,l,h)}}clearAxisAlignedRect(t,e,r,i){t=Math.round(t),e=Math.round(e),r=Math.round(r),i=Math.round(i);const n=t-Math.floor(r/2),a=e-Math.floor(i/2),s=n+r,o=a+i;for(let t=a;t<o;t++)for(let e=n;e<s;e++)this.pixelRenderer.clearPixel(e,t)}fillRotatedRect(t,e,r,i,n,a,s,o,l,h,c){const f=Math.cos(n),d=Math.sin(n),u=r/2,g=i/2,x=[{x:t+u*f-g*d,y:e+u*d+g*f},{x:t+u*f+g*d,y:e+u*d-g*f},{x:t-u*f+g*d,y:e-u*d-g*f},{x:t-u*f-g*d,y:e-u*d+g*f}],M=[];for(let t=0;t<4;t++){const e=x[t],r=x[(t+1)%4],i=r.y-e.y,n=e.x-r.x,a=r.x*e.y-e.x*r.y;M.push({a:i,b:n,c:a})}const p=Math.floor(Math.min(...x.map((t=>t.x)))),m=Math.ceil(Math.max(...x.map((t=>t.x)))),w=Math.floor(Math.min(...x.map((t=>t.y)))),b=Math.ceil(Math.max(...x.map((t=>t.y)))),R=this.pixelRenderer.context.globalAlpha;if(a)for(let t=w;t<=b;t++)for(let e=p;e<=m;e++){M.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clipPixel(e,t)}else if(s)for(let t=w;t<=b;t++)for(let e=p;e<=m;e++){M.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clearPixel(e,t)}else{const t=255===c&&R>=1;let e=0;t&&(e=255<<24|h<<16|l<<8|o);for(let r=w;r<=b;r++)for(let i=p;i<=m;i++){if(M.every((t=>t.a*i+t.b*r+t.c>=0))){if(i<0||i>=this.width||r<0||r>=this.height)continue;const n=r*this.width+i;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=n>>3,r=7&n;if(0===t[e])continue;if(!(t[e]&1<<7-r))continue}t?this.frameBufferUint32View[n]=e:this.pixelRenderer.setPixel(i,r,o,l,h,c)}}}}}class SWRendererArc{constructor(t){this.pixelRenderer=t}drawArc(t){const{center:e,radius:r,startAngle:i,endAngle:n,strokeWidth:a,strokeColor:{r:s,g:o,b:l,a:h},fillColor:{r:c,g:f,b:d,a:u}}=t;u>0&&this.drawArcHelper(e.x,e.y,r,i,n,c,f,d,u,!0),h>0&&a>0&&this.drawArcHelper(e.x,e.y,r,i,n,s,o,l,h,!1,a)}drawArcHelper(t,e,r,i,n,a,s,o,l,h=!1,c=1){function f(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<i&&(r+=2*Math.PI),r>=i&&r<=n}if(i=i%360*Math.PI/180,(n=n%360*Math.PI/180)<i&&(n+=2*Math.PI),c>1&&(c*=.75),t-=1,e-=1,h){const i=(r-.5)*(r-.5);for(let n=-r;n<=r;n++)for(let h=-r;h<=r;h++)h*h+n*n<=i&&f(h,n)&&this.pixelRenderer.setPixel(Math.round(t+h),Math.round(e+n),Math.round(a),s,o,l)}if(!h||c>0){const h=new Set;let d=0,u=r,g=3-2*r;for(;u>=d;){[[d,u],[-d,u],[d,-u],[-d,-u],[u,d],[-u,d],[u,-d],[-u,-d]].forEach((([r,a])=>{f(r,a)&&this.addThickArcPoint(h,t,e,t+r,e+a,c,i,n)})),d++,g>0?(u--,g=g+4*(d-u)+10):g=g+4*d+6}for(let t of h){const[e,r]=t.split(",").map(Number);this.pixelRenderer.setPixel(e,r,a,s,o,l)}}}drawArcHQ(t){const{center:e,radius:r,startAngle:i,endAngle:n,strokeWidth:a,strokeColor:{r:s,g:o,b:l,a:h},fillColor:{r:c,g:f,b:d,a:u}}=t;e.x-=.5,e.y-=.5,u>0&&this.drawArcHQHelper(e.x,e.y,r,i,n,c,f,d,u,!0),h>0&&a>0&&this.drawArcHQHelper(e.x,e.y,r,i,n,s,o,l,h,!1,a)}drawArcHQHelper(t,e,r,i,n,a,s,o,l,h=!1,c=1){i=i%360*Math.PI/180,(n=n%360*Math.PI/180)<i&&(n+=2*Math.PI),c*=.5,t-=.5,e-=.5,r=Math.floor(r)+.5,t=Math.round(t),e=Math.round(e);const f=Math.floor(t-r-c),d=Math.ceil(t+r+c),u=Math.floor(e-r-c),g=Math.ceil(e+r+c);function x(t,e){let r=Math.atan2(e,t);return r<0&&(r+=2*Math.PI),r<i&&(r+=2*Math.PI),r>=i&&r<=n}const M=r*r;if(h)for(let r=u;r<=g;r++)for(let i=f;i<=d;i++){const n=i-t,h=r-e;n*n+h*h<=M&&x(n,h)&&this.pixelRenderer.setPixel(i,r,a,s,o,l)}if(c>0)for(let i=u;i<=g;i++)for(let n=f;n<=d;n++){const h=n-t,f=i-e,d=h*h+f*f;Math.abs(Math.sqrt(d)-r)<=c&&x(h,f)&&this.pixelRenderer.setPixel(n,i,a,s,o,l)}}addStrokePixel(t,e,r){t.add(`${e},${r}`)}addThickPoint(t,e,r,i){const n=Math.floor(i/2);for(let a=-n;a<i-n;a++)for(let s=-n;s<i-n;s++)this.addStrokePixel(t,Math.round(e+s),Math.round(r+a))}addThickArcPoint(t,e,r,i,n,a,s,o){const l=Math.floor(a/2);for(let h=-l;h<a-l;h++)for(let c=-l;c<a-l;c++){const a=i+c,l=n+h;let f=Math.atan2(l-r,a-e);f<0&&(f+=2*Math.PI),f<s&&(f+=2*Math.PI),f>=s&&f<=o&&t.add(`${Math.round(a)},${Math.round(l)}`)}}}class SWRendererCircle{constructor(t){this.pixelRenderer=t}drawCircle(t){const{center:e,radius:r,strokeWidth:i,strokeColor:{r:n,g:a,b:s,a:o},fillColor:{r:l,g:h,b:c,a:f},clippingOnly:d}=t;if(!0===d)return void this._clipCircleShape(t);const u=f>0;if(!u&&(1===i&&o>0)){return void(255===o&&this.pixelRenderer.context.globalAlpha>=1?this.draw1PxStrokeFullCircleBresenhamOpaque(e.x,e.y,r,n,a,s):this.draw1PxStrokeFullCircleBresenhamAlpha(e.x,e.y,r,n,a,s,o))}const g=i>0&&o>0,x=255===f&&this.pixelRenderer.context.globalAlpha>=1;if(u&&!g&&x)return void this.drawOpaqueFillFullCircleBresenham(e.x,e.y,r,l,h,c);if(u&&!g&&!x)return void this.drawSemiTransparentFillFullCircleBresenham(e.x,e.y,r,l,h,c,f);const M=i>0?r-i/2:r,p=r+i/2;this.drawFullCircleFast(e.x,e.y,M,p,l,h,c,f,n,a,s,o)}drawFullCircleSlow(t,e,r,i,n,a,s,o,l,h,c,f){const d=t-.5,u=e-.5,g=Math.max(0,Math.floor(u-i-1)),x=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),M=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),m=(r+i)/2,w=m*m,b=o>0,R=f>0&&i>r;if(b&&!R)for(let t=g;t<=x;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),l=Math.max(M,Math.ceil(d-i+1e-4)),h=Math.min(p,Math.floor(d+i-1e-4));for(let e=l;e<=h;e++)this.pixelRenderer.setPixel(e,t,n,a,s,o)}else if(R&&!b){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,a=n*n;if(a>t)continue;const s=Math.sqrt(t-a),o=Math.max(M,Math.ceil(d-s)),g=Math.min(p,Math.floor(d+s));if(r<=0||a>e)for(let t=o;t<=g;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{const t=Math.sqrt(e-a),r=Math.min(g,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t));for(let t=o;t<=r;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=n;t<=g;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}else if(b&&R){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const g=i-u,x=g*g;if(x>t)continue;const m=Math.sqrt(t-x),b=Math.max(M,Math.ceil(d-m)),R=Math.min(p,Math.floor(d+m));let y=-1,C=-1;if(r>0&&x<=e){const t=Math.sqrt(e-x);y=Math.min(R,Math.floor(d-t)),C=Math.max(b,Math.ceil(d+t))}const S=w-x;let P=-1,k=-1;if(S>=0){const t=Math.sqrt(S);P=Math.max(M,Math.ceil(d-t+1e-4)),k=Math.min(p,Math.floor(d+t-1e-4))}if(P>=0)for(let t=P;t<=k;t++)this.pixelRenderer.setPixel(t,i,n,a,s,o);if(r<=0||x>e)for(let t=b;t<=R;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{for(let t=b;t<=y;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=C;t<=R;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}}drawFullCircleFast(t,e,r,i,n,a,s,o,l,h,c,f){const d=t-.5,u=e-.5,g=Math.max(0,Math.floor(u-i-1)),x=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),M=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),m=(r+i)/2,w=m*m,b=o>0,R=f>0&&i>r,y=[],C=[];if(b&&!R){for(let t=g;t<=x;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(M,Math.ceil(d-i+1e-4)),a=Math.min(p,Math.floor(d+i-1e-4))-n+1;a>0&&y.push(n,t,a)}y.length>0&&this.pixelRenderer.setPixelRuns(y,n,a,s,o)}else if(R&&!b){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,a=n*n;if(a>t)continue;const s=Math.sqrt(t-a),o=Math.max(M,Math.ceil(d-s)),l=Math.min(p,Math.floor(d+s));if(r<=0||a>e){const t=l-o+1;t>0&&C.push(o,i,t)}else{const t=Math.sqrt(e-a),r=Math.min(l,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t)),s=r-o+1;s>0&&C.push(o,i,s);const h=l-n+1;h>0&&C.push(n,i,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(b&&R){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,a=n*n;if(a>t)continue;const s=Math.sqrt(t-a),o=Math.max(M,Math.ceil(d-s)),l=Math.min(p,Math.floor(d+s));let h=-1,c=-1;if(r>0&&a<=e){const t=Math.sqrt(e-a);h=Math.min(l,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=w-a;let g=-1,x=-1;if(f>=0){const t=Math.sqrt(f);g=Math.max(M,Math.ceil(d-t+1e-4)),x=Math.min(p,Math.floor(d+t-1e-4))}if(g>=0){const t=x-g+1;t>0&&y.push(g,i,t)}if(r<=0||a>e){const t=l-o+1;t>0&&C.push(o,i,t)}else{const t=h-o+1;t>0&&C.push(o,i,t);const e=l-c+1;e>0&&C.push(c,i,e)}}y.length>0&&this.pixelRenderer.setPixelRuns(y,n,a,s,o),C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}}drawFullCircleFastest(t,e,r,i,n,a,s,o,l,h,c,f){const d=t-.5,u=e-.5,g=Math.max(0,Math.floor(u-i-1)),x=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),M=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),m=(r+i)/2,w=m*m,b=o>0,R=f>0&&i>r,y=[],C=[],S=[];if(b&&!R){for(let t=g;t<=x;t++){const e=t-u,r=w-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(M,Math.ceil(d-i+1e-4)),a=Math.min(p,Math.floor(d+i-1e-4))-n+1;a>0&&y.push(n,t,a)}y.length>0&&this.pixelRenderer.setPixelRuns(y,n,a,s,o)}else if(R&&!b){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,a=n*n;if(a>t)continue;const s=Math.sqrt(t-a),o=Math.max(M,Math.ceil(d-s)),l=Math.min(p,Math.floor(d+s));if(r<=0||a>e){const t=l-o+1;t>0&&C.push(o,i,t)}else{const t=Math.sqrt(e-a),r=Math.min(l,Math.floor(d-t)),n=Math.max(o,Math.ceil(d+t)),s=r-o+1;s>0&&C.push(o,i,s);const h=l-n+1;h>0&&C.push(n,i,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(b&&R){const t=i*i,e=r*r;for(let i=g;i<=x;i++){const n=i-u,a=n*n;if(a>t)continue;const s=Math.sqrt(t-a),o=Math.max(M,Math.ceil(d-s)),l=Math.min(p,Math.floor(d+s));let h=-1,c=-1;if(r>0&&a<=e){const t=Math.sqrt(e-a);h=Math.min(l,Math.floor(d-t)),c=Math.max(o,Math.ceil(d+t))}const f=w-a;let g=-1,x=-1,m=0;if(f>=0){const t=Math.sqrt(f);g=Math.max(M,Math.ceil(d-t+1e-4)),x=Math.min(p,Math.floor(d+t-1e-4)),m=x-g+1}let b=-1,R=0,y=-1,C=0;r<0||a>e?(b=o,R=l-o+1):(b=o,R=h-o+1,y=c,C=l-c+1),S.push(m>0?g:-1,m>0?m:-1,R>0?b:-1,R>0?R:-1,C>0?y:-1,C>0?C:-1)}S.length>0&&this.pixelRenderer.setPixelFillAndStrokeRuns(g,S,n,a,s,o,l,h,c,f)}}draw1PxStrokeFullCircleBresenhamOpaque(t,e,r,i,n,a){const s=this.pixelRenderer,o=s.width,l=s.height,h=(s.frameBufferUint8ClampedView,s.frameBufferUint32View),c=s.context,f=c.currentState?c.currentState.clippingMask:null,d=255<<24|a<<16|n<<8|i,u=r,g=Math.floor(t),x=Math.floor(e),M=Math.floor(u);if(M<0)return;if(0===M){if(u>=0){const r=Math.round(t),o=Math.round(e);s.setPixel(r,o,i,n,a,255)}return}let p=0,m=0;u>0&&2*u%2==1&&(p=1,m=1);if(g+M<0||g-M-p>=o||x+M<0||x-M-m>=l)return;let w=0,b=M,R=3-2*M;for(;w<=b;){const t=g+w,e=x+b,r=g+b,i=x+w,n=g+b,a=x-w-m,s=g+w,c=x-b-m,u=g-w-p,M=x-b-m,y=g-b-p,C=x-w-m,S=g-b-p,P=x+w,k=g-w-p,_=x+b;if(t>=0&&t<o&&e>=0&&e<l){const r=e*o+t;(!f||0!==f[r>>3]&&f[r>>3]&1<<7-(7&r))&&(h[r]=d)}if(r>=0&&r<o&&i>=0&&i<l&&w!==b){const t=i*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(n>=0&&n<o&&a>=0&&a<l){const t=a*o+n;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(s>=0&&s<o&&c>=0&&c<l){const t=c*o+s;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(u>=0&&u<o&&M>=0&&M<l){const t=M*o+u;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(y>=0&&y<o&&C>=0&&C<l&&w!==b){const t=C*o+y;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(S>=0&&S<o&&P>=0&&P<l){const t=P*o+S;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(k>=0&&k<o&&_>=0&&_<l){const t=_*o+k;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}R<0?R=R+4*w+6:(R=R+4*(w-b)+10,b--),w++}}draw1PxStrokeFullCircleBresenhamAlpha(t,e,r,i,n,a,s){const o=this.pixelRenderer,l=o.context.globalAlpha;if(0===s||l<=0)return;const h=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d.currentState?d.currentState.clippingMask:null,g=s/255*l,x=1-g;if(g<=0)return;const M=r,p=Math.floor(t),m=Math.floor(e),w=Math.floor(M);if(w<0)return;if(0===w){if(M>=0){const r=Math.round(t),l=Math.round(e);o.setPixel(r,l,i,n,a,s)}return}let b=0,R=0;M>0&&2*M%2==1&&(b=1,R=1);if(p+w<0||p-w-b>=h||m+w<0||m-w-R>=c)return;let y=0,C=w,S=3-2*w;const P=new Set;for(;y<=C;){const t=p+y,e=m+C,r=p+C,i=m+y,n=p+C,a=m-y-R,s=p+y,o=m-C-R,l=p-y-b,f=m-C-R,d=p-C-b,u=m-y-R,g=p-C-b,x=m+y,M=p-y-b,w=m+C;t>=0&&t<h&&e>=0&&e<c&&P.add(e*h+t),r>=0&&r<h&&i>=0&&i<c&&P.add(i*h+r),n>=0&&n<h&&a>=0&&a<c&&P.add(a*h+n),s>=0&&s<h&&o>=0&&o<c&&P.add(o*h+s),l>=0&&l<h&&f>=0&&f<c&&P.add(f*h+l),d>=0&&d<h&&u>=0&&u<c&&P.add(u*h+d),g>=0&&g<h&&x>=0&&x<c&&P.add(x*h+g),M>=0&&M<h&&w>=0&&w<c&&P.add(w*h+M),S<0?S=S+4*y+6:(S=S+4*(y-C)+10,C--),y++}if(P.size>0)for(const t of P){const e=4*t;let r=!1;if(u){const e=t>>3,i=7&t;0!==u[e]&&u[e]&1<<7-i||(r=!0)}if(!r){const t=f[e+3]/255*x,r=g+t;if(r>0){const s=1/r;f[e]=(i*g+f[e]*t)*s,f[e+1]=(n*g+f[e+1]*t)*s,f[e+2]=(a*g+f[e+2]*t)*s,f[e+3]=255*r}}}}_generateRelativeHorizontalExtentsBresenham(t){const e=t,r=Math.floor(e);if(r<0)return null;let i=0,n=0;if(e>0&&2*e%2==1&&(i=1,n=1),0===r)return{relativeExtents:[0],intRadius:0,xOffset:i,yOffset:n};const a=new Array(r+1).fill(0);let s=0,o=r,l=3-2*r;for(;s<=o;)a[o]=Math.max(a[o],s),a[s]=Math.max(a[s],o),l<0?l=l+4*s+6:(l=l+4*(s-o)+10,o--),s++;return{relativeExtents:a,intRadius:r,xOffset:i,yOffset:n}}drawOpaqueFillFullCircleBresenham(t,e,r,i,n,a){const s=this.pixelRenderer,o=s.width,l=s.height,h=(s.frameBufferUint8ClampedView,s.frameBufferUint32View),c=s.context,f=c&&c.currentState?c.currentState.clippingMask:null,d=255<<24|a<<16|n<<8|i,u=this._generateRelativeHorizontalExtentsBresenham(r);if(!u)return;const{relativeExtents:g,intRadius:x,xOffset:M,yOffset:p}=u;if(0===x&&r>=0){const r=Math.round(t),i=Math.round(e);if(r>=0&&r<o&&i>=0&&i<l){const t=i*o+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}return}const m=Math.floor(t-.5),w=Math.floor(e-.5),b=g[0];if(!(m+b<0||m-b-M>=o||w+x<0||w-x-p>=l))if(f)for(let t=0;t<=x;t++){const e=g[t],r=m-e-M+1,i=m+e,n=w+t,a=w-t-p+1;if(n>=0&&n<l){const t=Math.max(0,r),e=n*o+Math.min(o-1,i);let a=n*o+t;for(;a<=e;){const t=a>>3,r=7&a;if(0===r&&a+7<=e){const e=f[t];if(255===e){const t=a+7;for(;a<=t;)h[a]=d,a++;continue}if(0===e){a+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[a]=d),a++}}if(t>0&&!(1===t&&0===p)&&a>=0&&a<l){const t=Math.max(0,r),e=a*o+Math.min(o-1,i);let n=a*o+t;for(;n<=e;){const t=n>>3,r=7&n;if(0===r&&n+7<=e){const e=f[t];if(255===e){const t=n+7;for(;n<=t;)h[n]=d,n++;continue}if(0===e){n+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[n]=d),n++}}}else for(let t=0;t<=x;t++){const e=g[t],r=m-e-M+1,i=m+e,n=w+t,a=w-t-p+1;if(n>=0&&n<l){let t=n*o+Math.max(0,r);const e=n*o+Math.min(o-1,i);for(;t<=e;)h[t]=d,t++}if(t>0&&!(1===t&&0===p)&&a>=0&&a<l){let t=a*o+Math.max(0,r);const e=a*o+Math.min(o-1,i);for(;t<=e;)h[t]=d,t++}}}drawSemiTransparentFillFullCircleBresenham(t,e,r,i,n,a,s){const o=this.pixelRenderer,l=o.context.globalAlpha;if(0===s||l<=0)return;const h=o.width,c=o.height,f=o.frameBufferUint8ClampedView,d=o.context,u=d&&d.currentState?d.currentState.clippingMask:null,g=s/255*l,x=1-g;if(g<=0)return;const M=this._generateRelativeHorizontalExtentsBresenham(r);if(!M)return;const{relativeExtents:p,intRadius:m,xOffset:w,yOffset:b}=M;if(0===m&&r>=0){const r=Math.round(t),l=Math.round(e);return void o.setPixel(r,l,i,n,a,s)}const R=Math.floor(t-.5),y=Math.floor(e-.5),C=p[0];if(R+C<0||R-C-w>=h||y+m<0||y-m-b>=c)return;const S=t=>{const e=4*t,r=f[e+3]/255*x,s=g+r;if(s>0){const t=1/s;f[e]=(i*g+f[e]*r)*t,f[e+1]=(n*g+f[e+1]*r)*t,f[e+2]=(a*g+f[e+2]*r)*t,f[e+3]=255*s}};if(u)for(let t=0;t<=m;t++){const e=p[t],r=R-e-w+1,i=R+e,n=y+t,a=y-t-b+1;if(n>=0&&n<c){const t=Math.max(0,r),e=n*h+Math.min(h-1,i);let a=n*h+t;for(;a<=e;){const t=a>>3,r=7&a,i=1<<7-r;if(0===r&&a+7<=e){if(0===u[t]){a+=8;continue}}0!==(u[t]&i)&&S(a),a++}}if(t>0&&!(1===t&&0===b)&&a>=0&&a<c){const t=Math.max(0,r),e=a*h+Math.min(h-1,i);let n=a*h+t;for(;n<=e;){const t=n>>3,r=7&n,i=1<<7-r;if(0===r&&n+7<=e){if(0===u[t]){n+=8;continue}}0!==(u[t]&i)&&S(n),n++}}}else for(let t=0;t<=m;t++){const e=p[t],r=R-e-w+1,i=R+e,n=y+t,a=y-t-b+1;if(n>=0&&n<c){let t=n*h+Math.max(0,r);const e=n*h+Math.min(h-1,i);for(;t<=e;)S(t),t++}if(t>0&&!(1===t&&0===b)&&a>=0&&a<c){let t=a*h+Math.max(0,r);const e=a*h+Math.min(h-1,i);for(;t<=e;)S(t),t++}}}_clipCircleShape(t){const{center:e,radius:r}=t,i=this.pixelRenderer,n=this._generateRelativeHorizontalExtentsBresenham(r);if(!n)return;const{relativeExtents:a,intRadius:s,xOffset:o,yOffset:l}=n;if(0===s&&r>=0){const t=Math.round(e.x),r=Math.round(e.y);return void i.clipPixel(t,r)}const h=Math.floor(e.x-.5),c=Math.floor(e.y-.5);for(let t=0;t<=s;t++){const e=a[t],r=h-e-o+1,n=h+e,s=c+t,f=c-t-l+1;if(s>=0&&s<i.height){const t=Math.max(0,r),e=Math.min(i.width-1,n);for(let r=t;r<=e;r++)i.clipPixel(r,s)}if(t>0&&!(1===t&&0===l)&&f>=0&&f<i.height){const t=Math.max(0,r),e=Math.min(i.width-1,n);for(let r=t;r<=e;r++)i.clipPixel(r,f)}}}}class SWRendererRoundedRect{constructor(t,e,r,i,n,a,s){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=a,this.swRectRenderer=s}drawRoundedRect(t){const{center:e,width:r,height:i,radius:n,rotation:a,strokeWidth:s,strokeColor:{r:o,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:g}}=t;if(isNearMultipleOf90Degrees(a)){const{adjustedWidth:t,adjustedHeight:x}=getRotatedDimensionsIfTheCase(r,i,a),M=n>2?n-1:n;0==s||255===c||s<5&&255===c?this.drawCrispAxisAlignedRoundedRectThinOpaqueStroke(e.x,e.y,t,x,M,s,o,l,h,c,f,d,u,g):this.drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(e.x,e.y,t,x,M,s,o,l,h,c,f,d,u,g)}else this.drawRotatedRoundedRect(e.x,e.y,r,i,n,a,s,o,l,h,c,f,d,u,g)}drawCrispAxisAlignedRoundedRectThinOpaqueStroke(t,e,r,i,n,a,s,o,l,h,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");if(u>0&&this.drawRoundedRectFill(t,e,r,i,n,a,c,f,d,u,255==h&&a>0),h>0&&a>0)if(1===a){let a=getRectangularStrokeGeometry(t,e,r,i),c=Math.round(Math.min(n,Math.min(a.w,a.h)/2));for(let t=Math.floor(a.x+c);t<a.x+a.w-c;t++)this.pixelRenderer.setPixel(t,a.y-.5,s,o,l,h),this.pixelRenderer.setPixel(t,a.y+a.h-.5,s,o,l,h);for(let t=Math.floor(a.y+c);t<a.y+a.h-c;t++)this.pixelRenderer.setPixel(a.x-.5,t,s,o,l,h),this.pixelRenderer.setPixel(a.x+a.w-.5,t,s,o,l,h);const f=(t,e,r,i)=>{for(let n=r;n<=i;n+=Math.PI/180){const r=c-.5,i=t+r*Math.cos(n),a=e+r*Math.sin(n);this.pixelRenderer.setPixel(Math.floor(i),Math.floor(a),s,o,l,h)}};f(a.x+c,a.y+c,Math.PI,3*Math.PI/2),f(a.x+a.w-c,a.y+c,3*Math.PI/2,2*Math.PI),f(a.x+a.w-c,a.y+a.h-c,0,Math.PI/2),f(a.x+c,a.y+a.h-c,Math.PI/2,Math.PI)}else this.drawRoundedRectStroke(t,e,r,i,n,a,s,o,l,h)}drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(t,e,r,i,n,a,s,o,l,h,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");u>0&&this.drawRoundedRectFill(t,e,r,i,n,a,c,f,d,u,255==h&&a>0),h>0&&a>0&&this.drawRoundedRectStroke(t,e,r,i,n,a,s,o,l,h)}drawRoundedRectFill(t,e,r,i,n,a,s,o,l,h,c=!1){let f=null;f=c?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i));let d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));function u(t,e){if(t>=f.x+d&&t<f.x+f.w-d&&e>=f.y&&e<f.y+f.h)return!0;if(t>=f.x&&t<f.x+f.w&&e>=f.y+d&&e<f.y+f.h-d)return!0;const r=[{x:f.x+d,y:f.y+d},{x:f.x+f.w-d,y:f.y+d},{x:f.x+f.w-d,y:f.y+f.h-d},{x:f.x+d,y:f.y+f.h-d}];for(const i of r){const r=t-i.x+1,n=e-i.y+1;if(r*r+n*n<d*d)return!0}return!1}const g=this.pixelRenderer.context.globalAlpha,x=255===h&&g>=1;let M=0;x&&(M=255<<24|l<<16|o<<8|s);for(let t=Math.floor(f.y);t<=Math.ceil(f.y+f.h);t++)for(let e=Math.floor(f.x);e<=Math.ceil(f.x+f.w);e++)if(u(Math.ceil(e),Math.ceil(t))){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}x?this.frameBufferUint32View[r]=M:this.pixelRenderer.setPixel(e,t,s,o,l,h)}}drawRoundedRectStroke(t,e,r,i,n,a,s,o,l,h){const c=a/2;let f=getRectangularStrokeGeometry(t,e,r,i),d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));const u=new PixelSet(this.pixelRenderer),g=new ScanlineSpans;for(let t=f.y-c;t<f.y+c;t++)g.addSpan(t,f.x+d,f.x+f.w-d);for(let t=f.y+f.h-c;t<f.y+f.h+c;t++)g.addSpan(t,f.x+d,f.x+f.w-d);g.addToPixelSet(u,s,o,l,h);const x=new ScanlineSpans,M=new ScanlineSpans;for(let t=f.y+d;t<f.y+f.h-d;t++){for(let e=f.x-c;e<f.x+c;e++)x.addPixel(e,t);for(let e=f.x+f.w-c;e<f.x+f.w+c;e++)M.addPixel(e,t)}x.addToPixelSet(u,s,o,l,h),M.addToPixelSet(u,s,o,l,h);const p=(t,e,r,i)=>{const n=new ScanlineSpans,a=Math.PI/180;for(let s=r;s<=i;s+=a)for(let r=-c;r<c;r++){const i=d+r,a=t+i*Math.cos(s),o=e+i*Math.sin(s);n.addPixel(Math.floor(a),Math.floor(o))}n.addToPixelSet(u,s,o,l,h)};p(f.x+d,f.y+d,Math.PI,3*Math.PI/2),p(f.x+f.w-d,f.y+d,3*Math.PI/2,2*Math.PI),p(f.x+f.w-d,f.y+f.h-d,0,Math.PI/2),p(f.x+d,f.y+f.h-d,Math.PI/2,Math.PI),u.paint()}drawRotatedRoundedRect(t,e,r,i,n,a,s,o,l,h,c,f,d,u,g){const x=Math.cos(a),M=Math.sin(a),p=r/2,m=i/2,w=[[-p+n,-m+n],[p-n,-m+n],[p-n,m-n],[-p+n,m-n]].map((([r,i])=>({x:t+r*x-i*M,y:e+r*M+i*x}))),b=w.map(((t,e)=>{const r=w[(e+1)%4],i=r.x-t.x,n=r.y-t.y,a=Math.sqrt(i*i+n*n);return{dx:i/a,dy:n/a}})),R=w.map(((t,e)=>{const r=b[(e+3)%4],i=b[e],a=-r.dy,s=r.dx,o=-i.dy,l=i.dx;return{start:{x:t.x-n*a,y:t.y-n*s},end:{x:t.x-n*o,y:t.y-n*l}}}));if(g>0){this.swRectRenderer.fillRotatedRect(t,e,r-2*n,i-2*n,a,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+-n*M,e+(-i/2+n/2)*x,r-2*n,n,a,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+(r/2-n/2)*x,e+(r/2-n/2)*M,n,i-2*n,a,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+n*M,e+(i/2-n/2)*x,r-2*n,n,a,!1,!1,f,d,u,g),this.swRectRenderer.fillRotatedRect(t+(-r/2+n/2)*x,e+(-r/2+n/2)*M,n,i-2*n,a,!1,!1,f,d,u,g);const s=180*a/Math.PI;w.forEach(((t,e)=>{const r=[[180,270],[270,360],[0,90],[90,180]][e],i=(r[0]+s)%360,a=(r[1]+s)%360;drawArcSWHelper(t.x,t.y,n,i,a,f,d,u,g,!0)}))}if(c>0){for(let t=0;t<4;t++){const e=R[t],r=R[(t+1)%4];this.lineRenderer.drawLineThick(e.end.x,e.end.y,r.start.x,r.start.y,s,o,l,h,c)}const t=180*a/Math.PI;w.forEach(((e,r)=>{const i=[[180,270],[270,360],[0,90],[90,180]][r],a=(i[0]+t)%360,f=(i[1]+t)%360;drawArcSWHelper(e.x,e.y,n,a,f,o,l,h,c,!1,s)}))}}}class CrispSwCanvas{static version="1.0.2";constructor(t,e){if("object"==typeof t){const e=t;this.width=e.width,this.height=e.height,this.title=e.title||""}else this.width=t,this.height=e,this.title="";this._context=new CrispSwContext(this)}getContext(t){if("2d"!==t)throw new Error("Only '2d' context is supported");return this._context}}const isNode="undefined"==typeof window&&"undefined"!=typeof process,_colorParser=new ColorParser;class CrispSwContext{constructor(t){this.canvas=t,t.title||(t.title=""),this.displayCanvas={width:t.width,height:t.height,title:t.title},this.title=t.title,this.stateStack=[new ContextState(t.width,t.height)],this.frameBufferUint8ClampedView=new Uint8ClampedArray(t.width*t.height*4).fill(0),this.frameBufferUint32View=new Uint32Array(this.frameBufferUint8ClampedView.buffer),this.tempClippingMask=new Uint8Array(Math.ceil(t.width*t.height/8)).fill(0),this.pixelRenderer=new SWRendererPixel(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this),this.lineRenderer=new SWRendererLine(this.pixelRenderer),this.rectRenderer=new SWRendererRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer),this.roundedRectRenderer=new SWRendererRoundedRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer,this.rectRenderer),this.circleRenderer=new SWRendererCircle(this.pixelRenderer),this.arcRenderer=new SWRendererArc(this.pixelRenderer)}get currentState(){return this.stateStack[this.stateStack.length-1]}save(){this.stateStack.push(this.currentState.clone())}restore(){if(this.stateStack.length<=1)throw new Error("Cannot restore() - stack is empty");this.stateStack.pop()}scale(t,e){this.currentState.transform=this.currentState.transform.scale(t,e)}rotate(t){this.currentState.transform=this.currentState.transform.rotate(t)}translate(t,e){this.currentState.transform=this.currentState.transform.translate(t,e)}resetTransform(){this.currentState.transform.reset()}set fillStyle(t){this.currentState.fillColor=Color.fromCSS(t,_colorParser)}get fillStyle(){return this.currentState.fillColor.toCSS()}set strokeStyle(t){this.currentState.strokeColor=Color.fromCSS(t,_colorParser)}get strokeStyle(){return this.currentState.strokeColor.toCSS()}set lineWidth(t){this.currentState.lineWidth=t}set globalAlpha(t){this.currentState.globalAlpha=Math.max(0,Math.min(1,t))}get globalAlpha(){return this.currentState.globalAlpha}beginPath(){this.tempClippingMask.fill(0)}fill(){throw new Error("fill() is not supported - use fillRect() instead")}stroke(){throw new Error("stroke() is not supported - use strokeRect() instead")}strokeLine(t,e,r,i){const n=this.currentState,a=getScaledLineWidth(n.transform.elements,n.lineWidth),s=transformPoint(t,e,n.transform.elements),o=transformPoint(r,i,n.transform.elements);this.lineRenderer.drawLine({start:{x:s.tx,y:s.ty},end:{x:o.tx,y:o.ty},thickness:a,color:n.strokeColor})}clearRect(t,e,r,i){const n=this.currentState,a=transformPoint(t+r/2,e+i/2,n.transform.elements),s=getRotationAngle(n.transform.elements);this.rectRenderer.clearRect({center:{x:a.tx,y:a.ty},width:r,height:i,rotation:s})}rect(t,e,r,i){const n=this.currentState,a=transformPoint(t+r/2,e+i/2,n.transform.elements),s=getRotationAngle(n.transform.elements),{scaleX:o,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:a.tx,y:a.ty},width:r*o,height:i*l,rotation:s,clippingOnly:!0})}clip(){for(let t=0;t<this.currentState.clippingMask.length;t++)this.currentState.clippingMask[t]=this.currentState.clippingMask[t]&this.tempClippingMask[t]}fillRect(t,e,r,i){const n=this.currentState,a=transformPoint(t+r/2,e+i/2,n.transform.elements),s=getRotationAngle(n.transform.elements),{scaleX:o,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:a.tx,y:a.ty},width:r*o,height:i*l,rotation:s,clippingOnly:!1,strokeWidth:0,strokeColor:Color.transparent,fillColor:n.fillColor})}strokeRect(t,e,r,i){const n=this.currentState,a=getScaledLineWidth(n.transform.elements,n.lineWidth),s=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*l,height:i*h,rotation:o,clippingOnly:!1,strokeWidth:a,strokeColor:n.strokeColor,fillColor:Color.transparent})}blitToCanvas(t){if(isNode)return;const e=new ImageData(this.frameBufferUint8ClampedView,this.canvas.width,this.canvas.height);t.getContext("2d").putImageData(e,0,0)}fillCircle(t,e,r,i){const n=this.currentState,a=transformPoint(t,e,n.transform.elements),{scaleX:s,scaleY:o}=getScaleFactors(n.transform.elements),l=r*Math.max(s,o),h={center:{x:a.tx,y:a.ty},radius:l,strokeWidth:0,strokeColor:Color.transparent,fillColor:i};this.circleRenderer.drawCircle(h)}strokeCircle(t,e,r,i,n){const a=this.currentState,s=transformPoint(t,e,a.transform.elements),{scaleX:o,scaleY:l}=getScaleFactors(a.transform.elements),h=r*Math.max(o,l),c=getScaledLineWidth(a.transform.elements,i),f={center:{x:s.tx,y:s.ty},radius:h,strokeWidth:c,strokeColor:n,fillColor:Color.transparent};this.circleRenderer.drawCircle(f)}fillAndStrokeCircle(t,e,r,i,n,a){const s=this.currentState,o=transformPoint(t,e,s.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(s.transform.elements),c=r*Math.max(l,h),f=getScaledLineWidth(s.transform.elements,n),d={center:{x:o.tx,y:o.ty},radius:c,strokeWidth:f,strokeColor:a,fillColor:i};this.circleRenderer.drawCircle(d)}getImageData(t,e,r,i){const n=this.canvas.width,a=this.canvas.height;t=Math.max(0,Math.min(Math.floor(t),n)),e=Math.max(0,Math.min(Math.floor(e),a)),r=Math.max(0,Math.min(Math.floor(r),n-t)),i=Math.max(0,Math.min(Math.floor(i),a-e));const s=new Uint8ClampedArray(r*i*4);if(0===t&&0===e&&r===n&&i===a)s.set(this.frameBufferUint8ClampedView);else for(let a=0;a<i;a++)for(let i=0;i<r;i++){const o=4*((e+a)*n+(t+i)),l=4*(a*r+i);s[l]=this.frameBufferUint8ClampedView[o],s[l+1]=this.frameBufferUint8ClampedView[o+1],s[l+2]=this.frameBufferUint8ClampedView[o+2],s[l+3]=this.frameBufferUint8ClampedView[o+3]}const o=new ImageData(s,r,i);return void 0===o.canvasTitle&&Object.defineProperty(o,"canvasTitle",{get:()=>this.canvas.title||this.title||"",configurable:!0}),o}roundRect(t,e,r,i,n){const a=this.currentState,{scaleX:s,scaleY:o}=(transformPoint(t+r/2,e+i/2,a.transform.elements),getRotationAngle(a.transform.elements),getScaleFactors(a.transform.elements));throw new Error("CrispSwContext.roundRect() for path definition / clipping is not yet implemented.")}fillRoundRect(t,e,r,i,n){const a=this.currentState,s=transformPoint(t+r/2,e+i/2,a.transform.elements),o=getRotationAngle(a.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(a.transform.elements),c=n*Math.min(Math.abs(l),Math.abs(h));this.roundedRectRenderer.drawRoundedRect({center:{x:s.tx,y:s.ty},width:r*l,height:i*h,radius:c,rotation:o,fillColor:a.fillColor,strokeWidth:0,strokeColor:Color.transparent})}strokeRoundRect(t,e,r,i,n){const a=this.currentState,s=getScaledLineWidth(a.transform.elements,a.lineWidth),o=transformPoint(t+r/2,e+i/2,a.transform.elements),l=getRotationAngle(a.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(a.transform.elements),f=n*Math.min(Math.abs(h),Math.abs(c));this.roundedRectRenderer.drawRoundedRect({center:{x:o.tx,y:o.ty},width:r*h,height:i*c,radius:f,rotation:l,fillColor:Color.transparent,strokeWidth:s,strokeColor:a.strokeColor})}arc(t,e,r,i,n,a=!1){if(!(Math.abs(Math.abs(n-i)-2*Math.PI)<1e-9))throw new Error("CrispSwContext.arc() for path definition/clipping is only implemented for full circles. Use fillArc/outerStrokeArc for drawing partial arcs.");{const i=this.currentState,n=transformPoint(t,e,i.transform.elements),{scaleX:a,scaleY:s}=getScaleFactors(i.transform.elements),o=r*Math.max(Math.abs(a),Math.abs(s));this.circleRenderer.drawCircle({center:{x:n.tx,y:n.ty},radius:o,clippingOnly:!0,strokeWidth:0,strokeColor:Color.transparent,fillColor:Color.transparent})}}fillArc(t,e,r,i,n,a=!1){const s=this.currentState,o=transformPoint(t,e,s.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(s.transform.elements),c=r*Math.min(Math.abs(l),Math.abs(h)),f=180*i/Math.PI,d=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:o.tx,y:o.ty},radius:c,startAngle:f,endAngle:d,anticlockwise:a,fillColor:s.fillColor,strokeWidth:0,strokeColor:Color.transparent})}outerStrokeArc(t,e,r,i,n,a=!1){const s=this.currentState,o=getScaledLineWidth(s.transform.elements,s.lineWidth),l=transformPoint(t,e,s.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(s.transform.elements),f=r*Math.min(Math.abs(h),Math.abs(c)),d=180*i/Math.PI,u=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:l.tx,y:l.ty},radius:f,startAngle:d,endAngle:u,anticlockwise:a,fillColor:Color.transparent,strokeWidth:o,strokeColor:s.strokeColor})}fillAndOuterStrokeArc(t,e,r,i,n,a=!1){const s=this.currentState,o=getScaledLineWidth(s.transform.elements,s.lineWidth),l=transformPoint(t,e,s.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(s.transform.elements),f=r*Math.min(Math.abs(h),Math.abs(c)),d=180*i/Math.PI,u=180*n/Math.PI;this.arcRenderer.drawArc({center:{x:l.tx,y:l.ty},radius:f,startAngle:d,endAngle:u,anticlockwise:a,fillColor:s.fillColor,strokeWidth:o,strokeColor:s.strokeColor})}}