/* CrispSwCanvas v1.0.2 */
class TransformationMatrix{constructor(){this.elements=new Float64Array([1,0,0,0,1,0,0,0,1])}clone(){const t=new TransformationMatrix;return t.elements.set(this.elements),t}reset(){return this.elements.set([1,0,0,0,1,0,0,0,1]),this}get(t,e){return this.elements[3*e+t]}set(t,e,r){this.elements[3*e+t]=r}multiply(t){const e=new TransformationMatrix;for(let r=0;r<3;r++)for(let i=0;i<3;i++){let n=0;for(let e=0;e<3;e++)n+=this.get(i,e)*t.get(e,r);e.set(i,r,n)}return e}translate(t,e){const r=new TransformationMatrix;return r.elements.set([1,0,0,0,1,0,t,e,1]),this.multiply(r)}scale(t,e){const r=new TransformationMatrix;return r.elements.set([t,0,0,0,e,0,0,0,1]),this.multiply(r)}rotate(t){const e=new TransformationMatrix,r=Math.cos(t),i=Math.sin(t);return e.elements.set([r,i,0,-i,r,0,0,0,1]),this.multiply(e)}}function getScaledLineWidth(t,e){const r=Math.sqrt(t[0]*t[0]+t[1]*t[1]),i=Math.sqrt(t[3]*t[3]+t[4]*t[4]);return e*Math.max(Math.sqrt(r*i),1e-4)}function transformPoint(t,e,r){return{tx:r[0]*t+r[3]*e+r[6],ty:r[1]*t+r[4]*e+r[7]}}function getRotationAngle(t){return Math.atan2(-t[3],t[0])}function getScaleFactors(t){return{scaleX:Math.sqrt(t[0]*t[0]+t[1]*t[1]),scaleY:Math.sqrt(t[3]*t[3]+t[4]*t[4])}}function parseColor(t){if(!t||"string"!=typeof t)throw new Error("Invalid color format: must be a string");if((t=t.trim().replace(/\s+/g,"")).startsWith("#")){let e,r,i;if(4===t.length)return e=parseInt(t[1]+t[1],16),r=parseInt(t[2]+t[2],16),i=parseInt(t[3]+t[3],16),normalizeColor(e,r,i,1);if(7===t.length)return e=parseInt(t.substring(1,3),16),r=parseInt(t.substring(3,5),16),i=parseInt(t.substring(5,7),16),normalizeColor(e,r,i,1)}const e=t.match(/^rgb\((\d+),(\d+),(\d+)\)$/i),r=t.match(/^rgba\((\d+),(\d+),(\d+),([0-9]*\.?[0-9]+)\)$/i);if(e){const[t,r,i,n]=e;if(r>255||i>255||n>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+r,+i,+n,1)}if(r){const[t,e,i,n,s]=r;if(e>255||i>255||n>255)throw new Error("RGB values must be between 0-255");return normalizeColor(+e,+i,+n,+s)}throw new Error(`Invalid color format: ${t}`)}function normalizeColor(t,e,r,i){return{r:Math.round(Math.max(0,Math.min(255,t))),g:Math.round(Math.max(0,Math.min(255,e))),b:Math.round(Math.max(0,Math.min(255,r))),a:Math.max(0,Math.min(255,255*i))}}function colorToString(t,e,r,i){return"object"==typeof t?`rgba(${t.r}, ${t.g}, ${t.b}, ${(t.a/255).toFixed(3).replace(/\.?0+$/,"")})`:`rgba(${t}, ${e}, ${r}, ${(i/255).toFixed(3).replace(/\.?0+$/,"")})`}class ContextState{constructor(t,e,r,i,n,s,o,a){this.canvasWidth=t,this.canvasHeight=e,this.lineWidth=r||1,this.transform=i||new TransformationMatrix,this.strokeColor=n||{r:0,g:0,b:0,a:1},this.fillColor=s||{r:0,g:0,b:0,a:1},this.globalAlpha=o||1,this.clippingMask=a||new Uint8Array(Math.ceil(t*e/8)).fill(255)}clone(){const t=new Uint8Array(this.clippingMask);return new ContextState(this.canvasWidth,this.canvasHeight,this.lineWidth,this.transform.clone(),{...this.strokeColor},{...this.fillColor},this.globalAlpha,t)}}function pointInPolygon(t,e,r){let i=!1;for(let n=0,s=r.length-1;n<r.length;s=n++){const o=r[n].x,a=r[n].y,l=r[s].x,h=r[s].y;a>e!=h>e&&t<(l-o)*(e-a)/(h-a)+o&&(i=!i)}return i}function extendLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const o=i/s,a=n/s;return{start:{x:t.x-o*r,y:t.y-a*r},end:{x:e.x+o*r,y:e.y+a*r}}}function shortenLine(t,e,r){const i=e.x-t.x,n=e.y-t.y,s=Math.sqrt(i*i+n*n);if(0===s)return{start:t,end:e};const o=i/s,a=n/s;return{start:{x:t.x+o*r,y:t.y+a*r},end:{x:e.x-o*r,y:e.y-a*r}}}function alignToPixelBoundary(t){return{x:Math.round(t.x)+.5,y:Math.round(t.y)+.5}}function toIntegerPoint(t){return{x:Math.round(t.x),y:Math.round(t.y)}}function roundCornerOfRectangularGeometry(t){const{x:e,y:r,w:i,h:n}=t;return{x:Math.round(e),y:Math.round(r),w:i,h:n}}function roundCornerOfRectangularGeometryWithWarning(t){const e=roundCornerOfRectangularGeometry(t);return e.x===t.x&&e.y===t.y||console.warn("Rectangular geometry is not at a grid point, rounding to nearest grid point. When this happens, HTML5 Canvas would do a non-crisp fill, while the SW renderer will do a crisp fill."),e}function getRectangularFillGeometry(t,e,r,i){return{x:t-r/2,y:e-i/2,w:r,h:i}}var getRectangularStrokeGeometry=getRectangularFillGeometry;function checkBasicConditionsForCrispRendering(t,e,r,i,n){Number.isInteger(r)&&Number.isInteger(i)||console.warn("Width and height must be integers for crisp rendering"),Number.isInteger(n)||console.warn("Stroke width must be an integer for crisp rendering"),Number.isInteger(t)||t%1==.5||console.warn("Center X must be an integer or *.5 for crisp rendering"),Number.isInteger(e)||e%1==.5||console.warn("Center Y must be an integer or *.5 for crisp rendering ")}class PixelSet{constructor(t){this.pixels=new Map,this.pixelRenderer=t}addPixel(t,e,r,i,n,s){const o=`${Math.round(t)},${Math.round(e)}`;this.pixels.set(o,{x:Math.round(t),y:Math.round(e),r:r,g:i,b:n,a:s})}paint(){for(const t of this.pixels.values())this.pixelRenderer.setPixel(t.x,t.y,t.r,t.g,t.b,t.a)}}class ScanlineSpans{constructor(){this.spans=new Map}addSpan(t,e,r){if(e>r&&([e,r]=[r,e]),this.spans.has(t)){const i=this.spans.get(t);i[0]=Math.min(i[0],e),i[1]=Math.max(i[1],r)}else this.spans.set(t,[e,r])}addPixel(t,e){if(e=Math.round(e),t=Math.round(t),this.spans.has(e)){const r=this.spans.get(e);r[0]=Math.min(r[0],t),r[1]=Math.max(r[1],t)}else this.spans.set(e,[t,t])}addToPixelSet(t,e,r,i,n){for(const[s,[o,a]]of this.spans)for(let l=o;l<=a;l++)t.addPixel(l,s,e,r,i,n)}}const ANGLE_TOLERANCE=.001;function isNearMultipleOf90Degrees(t){const e=(t%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(e)<.001||Math.abs(e-Math.PI/2)<.001||Math.abs(e-Math.PI)<.001||Math.abs(e-3*Math.PI/2)<.001||Math.abs(e-2*Math.PI)<.001}function getRotatedDimensionsIfTheCase(t,e,r){const i=(r%(2*Math.PI)+2*Math.PI)%(2*Math.PI);return Math.abs(i-Math.PI/2)<.001||Math.abs(i-3*Math.PI/2)<.001?{adjustedWidth:e,adjustedHeight:t}:{adjustedWidth:t,adjustedHeight:e}}class SWRendererPixel{constructor(t,e,r,i,n){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,n?(this.context=n,this.tempClippingMask=n.tempClippingMask):this.context={globalAlpha:1}}clipPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=e*r+t,n=i>>3,s=7&i;this.tempClippingMask[n]|=1<<7-s}setPixel(t,e,r,i,n,s){t|=0,e|=0;const o=this.width,a=this.context.globalAlpha;if(t<0||t>=o||e<0||e>=this.height)return;const l=e*o+t,h=4*l;if(this.context.currentState){const t=this.context.currentState.clippingMask,e=l>>3,r=7&l;if(0===t[e])return;if(!(t[e]&1<<7-r))return}let c=0;if(255===s&&a>=1)return c=255<<24|n<<16|i<<8|r,void(this.frameBufferUint32View[l]=c);const f=s/255*a,d=this.frameBufferUint8ClampedView[h+3]/255*(1-f),u=f+d;if(u<=0)return;const x=1/u;this.frameBufferUint8ClampedView[h]=(r*f+this.frameBufferUint8ClampedView[h]*d)*x,this.frameBufferUint8ClampedView[h+1]=(i*f+this.frameBufferUint8ClampedView[h+1]*d)*x,this.frameBufferUint8ClampedView[h+2]=(n*f+this.frameBufferUint8ClampedView[h+2]*d)*x,this.frameBufferUint8ClampedView[h+3]=255*u}clearPixel(t,e){t|=0,e|=0;const r=this.width;if(t<0||t>=r||e<0||e>=this.height)return;const i=4*(e*r+t);this.frameBufferUint8ClampedView[i]=0,this.frameBufferUint8ClampedView[i+1]=0,this.frameBufferUint8ClampedView[i+2]=0,this.frameBufferUint8ClampedView[i+3]=0}setPixelRuns(t,e,r,i,n){const s=this.width,o=this.height,a=this.frameBufferUint8ClampedView,l=this.frameBufferUint32View,h=this.context.globalAlpha,c=this.context.currentState,f=c?this.context.currentState.clippingMask:null,d=255===n&&h>=1;let u=0;d&&(u=255<<24|i<<16|r<<8|e);const x=d?1:n/255*h,M=d?0:1-x;if(!(x<=0))for(let n=0;n<t.length;n+=3){let h=0|t[n];const m=0|t[n+1];let p=0|t[n+2];if(m<0||m>=o)continue;if(h<0&&(p+=h,h=0,p<=0))continue;if(h+p>s&&(p=s-h,p<=0))continue;let g=m*s+h,R=4*g;if(d)for(let t=0;t<p;t++,g++,R+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,R+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}l[g]=u}else for(let t=0;t<p;t++,g++,R+=4){if(c){const e=g>>3;if(0===f[e]){const e=8-(7&g),r=Math.min(e,p-t);t+=r-1,g+=r-1,R+=4*(r-1);continue}const r=7&g;if(!(f[e]&1<<7-r))continue}const n=a[R+3]/255*M,s=x+n;if(s<=0)continue;const o=1/s;a[R]=(e*x+a[R]*n)*o,a[R+1]=(r*x+a[R+1]*n)*o,a[R+2]=(i*x+a[R+2]*n)*o,a[R+3]=255*s}}}setPixelFillAndStrokeRuns(t,e,r,i,n,s,o,a,l,h){t+=2;const c=this.width,f=this.height,d=this.frameBufferUint8ClampedView,u=this.frameBufferUint32View,x=this.context.globalAlpha,M=this.context.currentState,m=M?this.context.currentState.clippingMask:null,p=s/255*x,g=1-p,R=p>=1;let w=0;R&&(w=255<<24|n<<16|i<<8|r);const y=h/255*x,S=1-y,C=y>=1;let P=0;if(C&&(P=255<<24|l<<16|a<<8|o),p<=0&&y<=0)return;let k=t;for(let t=0;t<e.length;t+=6){if(k<0||k>=f){k++;continue}let s=-1!==e[t]?0|e[t]:-1,h=-1!==e[t+1]?0|e[t+1]:-1,x=-1!==e[t+2]?0|e[t+2]:-1,b=-1!==e[t+3]?0|e[t+3]:-1,B=-1!==e[t+4]?0|e[t+4]:-1,A=-1!==e[t+5]?0|e[t+5]:-1;const U=-1!==s&&h>0&&p>0,_=-1!==x&&b>0&&y>0,v=-1!==B&&A>0&&y>0;if(U||_||v){U&&(s<0&&(h+=s,s=0),s+h>c&&(h=c-s),h<=0&&(s=-1,h=0)),_&&(x<0&&(b+=x,x=0),x+b>c&&(b=c-x),b<=0&&(x=-1,b=0)),v&&(B<0&&(A+=B,B=0),B+A>c&&(A=c-B),A<=0&&(B=-1,A=0));for(let t=0;t<3;t++){let e,f,V,W,I,L,F,T,q=0;if(0===t){if(!U||-1===s||h<=0)continue;e=s,f=h,V=r,W=i,I=n,L=p,F=g,T=R,T&&(q=w)}else if(1===t){if(!_||-1===x||b<=0)continue;e=x,f=b,V=o,W=a,I=l,L=y,F=S,T=C,T&&(q=P)}else{if(!v||-1===B||A<=0)continue;e=B,f=A,V=o,W=a,I=l,L=y,F=S,T=C,T&&(q=P)}let O=k*c+e,E=4*O;for(let t=0;t<f;t++,O++,E+=4){if(M){const e=O>>3;if(e>=m.length)continue;if(0===m[e]){const e=8-(7&O),r=Math.min(e,f-t);t+=r-1,O+=r-1,E+=4*(r-1);continue}const r=7&O;if(!(m[e]&1<<7-r))continue}if(T)u[O]=q;else{const t=d[E+3]/255*F,e=L+t;if(e<=1e-5)continue;const r=1/e;d[E]=(V*L+d[E]*t)*r,d[E+1]=(W*L+d[E+1]*t)*r,d[E+2]=(I*L+d[E+2]*t)*r,d[E+3]=255*e}}}k++}else k++}}}class SWRendererLine{constructor(t){this.pixelRenderer=t,this._corners=[{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}],this._edges=[{p1:this._corners[0],p2:this._corners[1],invDeltaY:0,deltaX:0},{p1:this._corners[1],p2:this._corners[2],invDeltaY:0,deltaX:0},{p1:this._corners[2],p2:this._corners[3],invDeltaY:0,deltaX:0},{p1:this._corners[3],p2:this._corners[0],invDeltaY:0,deltaX:0}],this._intersections=new Array(8),this._pixelRuns=[]}drawLine(t){const{start:{x:e,y:r},end:{x:i,y:n},thickness:s,color:{r:o,g:a,b:l,a:h}}=t;if(1!==s)return void this.drawLineThick(e,r,i,n,s,o,a,l,h);let c=Math.floor(e),f=Math.floor(r),d=Math.floor(i),u=Math.floor(n);c===d&&(u>f?u--:f--),f===u&&(d>c?d--:c--);const x=this.pixelRenderer.context.globalAlpha;if(0===h||x<=0)return;const M=Math.abs(d-c),m=Math.abs(u-f);return 0===M?this._drawLine1px_vertical(c,f,u,o,a,l,h):0===m?this._drawLine1px_horizontal(c,d,f,o,a,l,h):M===m?this._drawLine1px_45degrees(c,f,d,u,o,a,l,h):this._drawLine1px_genericOrientations(c,f,d,u,M,m,o,a,l,h)}drawLine1px(t,e,r,i,n,s,o,a){t=Math.floor(t),e=Math.floor(e),r=Math.floor(r),i=Math.floor(i);const l=Math.abs(r-t),h=Math.abs(i-e);return 0===l?this._drawLine1px_vertical(t,e,i,n,s,o,a):0===h?this._drawLine1px_horizontal(t,r,e,n,s,o,a):l===h?this._drawLine1px_45degrees(t,e,r,i,n,s,o,a):this._drawLine1px_genericOrientations(t,e,r,i,l,h,n,s,o,a)}_drawLine1px_horizontal(t,e,r,i,n,s,o){const a=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(r<0||r>=c)return;const x=255===o&&u>=1;let M=0;x&&(M=255<<24|s<<16|n<<8|i);const m=x?1:o/255*u,p=x?0:1-m;if(t>e){let r=t;t=e,e=r}if(t<0&&(t=0),e>=h&&(e=h-1),t>e)return;const g=4*(r*h+t);for(let o=t;o<=e;o++){const e=g+4*(o-t),c=r*h+o;if(f){const t=c>>3,e=7&c;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[c]=M;else{const t=a[e+3]/255*p,r=m+t;if(r<=0)continue;const o=1/r;a[e]=(i*m+a[e]*t)*o,a[e+1]=(n*m+a[e+1]*t)*o,a[e+2]=(s*m+a[e+2]*t)*o,a[e+3]=255*r}}}_drawLine1px_vertical(t,e,r,i,n,s,o){const a=this.pixelRenderer.frameBufferUint8ClampedView,l=this.pixelRenderer.frameBufferUint32View,h=this.pixelRenderer.width,c=this.pixelRenderer.height,f=this.pixelRenderer.context.currentState,d=f?this.pixelRenderer.context.currentState.clippingMask:null,u=this.pixelRenderer.context.globalAlpha;if(t<0||t>=h)return;const x=255===o&&u>=1;let M=0;x&&(M=255<<24|s<<16|n<<8|i);const m=x?1:o/255*u,p=x?0:1-m;if(e>r){let t=e;e=r,r=t}if(e<0&&(e=0),r>=c&&(r=c-1),!(e>r))for(let o=e;o<=r;o++){const e=4*(o*h+t),r=o*h+t;if(f){const t=r>>3,e=7&r;if(0===d[t])continue;if(!(d[t]&1<<7-e))continue}if(x)l[r]=M;else{const t=a[e+3]/255*p,r=m+t;if(r<=0)continue;const o=1/r;a[e]=(i*m+a[e]*t)*o,a[e+1]=(n*m+a[e+1]*t)*o,a[e+2]=(s*m+a[e+2]*t)*o,a[e+3]=255*r}}}_drawLine1px_45degrees(t,e,r,i,n,s,o,a){const l=this.pixelRenderer.frameBufferUint8ClampedView,h=this.pixelRenderer.frameBufferUint32View,c=this.pixelRenderer.width,f=this.pixelRenderer.height,d=this.pixelRenderer.context.currentState,u=d?this.pixelRenderer.context.currentState.clippingMask:null,x=this.pixelRenderer.context.globalAlpha,M=255===a&&x>=1;let m=0;M&&(m=255<<24|o<<16|s<<8|n);const p=M?1:a/255*x,g=M?0:1-p,R=t<r?1:-1,w=e<i?1:-1;let y=t,S=e;for(;!(y<0&&R<0||y>=c&&R>0||S<0&&w<0||S>=f&&w>0);){if(y>=0&&y<c&&S>=0&&S<f){const t=4*(S*c+y),e=S*c+y;let r=!0;if(d){const t=e>>3,i=7&e;!(t>=u.length||0===u[t])&&u[t]&1<<7-i||(r=!1)}if(r)if(M)h[e]=m;else{const e=l[t+3]/255*g,r=p+e;if(r>0){const i=1/r;l[t]=(n*p+l[t]*e)*i,l[t+1]=(s*p+l[t+1]*e)*i,l[t+2]=(o*p+l[t+2]*e)*i,l[t+3]=255*r}}}if(y===r&&S===i)break;y+=R,S+=w}}_drawLine1px_genericOrientations(t,e,r,i,n,s,o,a,l,h){const c=this.pixelRenderer.frameBufferUint8ClampedView,f=this.pixelRenderer.frameBufferUint32View,d=this.pixelRenderer.width,u=this.pixelRenderer.height,x=this.pixelRenderer.context.currentState,M=x?this.pixelRenderer.context.currentState.clippingMask:null,m=this.pixelRenderer.context.globalAlpha,p=255===h&&m>=1;let g=0;p&&(g=255<<24|l<<16|a<<8|o);const R=p?1:h/255*m,w=p?0:1-R,y=t<r?1:-1,S=e<i?1:-1;let C=n-s;for(;;){if(t>=0&&t<d&&e>=0&&e<u){const r=4*(e*d+t),i=e*d+t;let n=!0;if(x){const t=i>>3,e=7&i;!(t>=M.length||0===M[t])&&M[t]&1<<7-e||(n=!1)}if(n)if(p)f[i]=g;else{const t=c[r+3]/255*w,e=R+t;if(e>0){const i=1/e;c[r]=(o*R+c[r]*t)*i,c[r+1]=(a*R+c[r+1]*t)*i,c[r+2]=(l*R+c[r+2]*t)*i,c[r+3]=255*e}}}if(t===r&&e===i)break;const h=2*C;h>-s&&(C-=s,t+=y),h<n&&(C+=n,e+=S)}}drawLineThick(t,e,r,i,n,s,o,a,l){this._drawLineThickPolygonScan(t,e,r,i,n,s,o,a,l)}_drawLineThickBoundingBox(t,e,r,i,n,s,o,a,l){const h=(r-=.5)-(t-=.5),c=(i-=.5)-(e-=.5),f=Math.sqrt(h*h+c*c);if(0===f)return;const d=-c/f,u=h/f,x=n/2,M=[[t+d*x,e+u*x],[t-d*x,e-u*x],[r+d*x,i+u*x],[r-d*x,i-u*x]],m=Math.floor(Math.min(...M.map((t=>t[0])))),p=Math.ceil(Math.max(...M.map((t=>t[0])))),g=Math.floor(Math.min(...M.map((t=>t[1])))),R=Math.ceil(Math.max(...M.map((t=>t[1]))));for(let r=g;r<=R;r++)for(let i=m;i<=p;i++){const n=i-t,d=r-e,u=(n*h+d*c)/f,M=n-h/f*u,m=d-c/f*u,p=Math.sqrt(M*M+m*m);u>=0&&u<=f&&p<=x&&this.pixelRenderer.setPixel(i,r,s,o,a,l)}}_drawLineThickModifiedBresenham(t,e,r,i,n,s,o,a,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1;let u,x;const M=Math.sqrt(h*h+c*c);if(0===M){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,o,a,l);return}u=-c/M,x=h/M;const m=n/2;let p=h-c,g=t,R=e;for(;this._drawPerpendicularSegment(g,R,u,x,m,s,o,a,l),g!==r||R!==i;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,R+=d)}const w=(r-t)/M,y=(i-e)/M;this._drawSquareCap(t,e,u,x,m,-w,-y,s,o,a,l),this._drawSquareCap(r,i,u,x,m,w,y,s,o,a,l)}_drawPerpendicularSegment(t,e,r,i,n,s,o,a,l){const h=Math.ceil(n);this.pixelRenderer.setPixel(t,e,s,o,a,l);for(let c=1;c<=h;c++){const f=c/h*n,d=Math.round(t+r*f),u=Math.round(e+i*f),x=Math.round(t-r*f),M=Math.round(e-i*f);this.pixelRenderer.setPixel(d,u,s,o,a,l),this.pixelRenderer.setPixel(x,M,s,o,a,l)}}_drawSquareCap(t,e,r,i,n,s,o,a,l,h,c){const f=Math.ceil(n);for(let d=1;d<=f;d++){const u=d/f*n,x=Math.round(t+s*u),M=Math.round(e+o*u);this._drawPerpendicularSegment(x,M,r,i,n,a,l,h,c)}}_drawLineThickDistanceOptimized(t,e,r,i,n,s,o,a,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.abs(r-t),c=Math.abs(i-e),f=t<r?1:-1,d=e<i?1:-1,u=Math.sqrt((r-t)**2+(i-e)**2);if(0===u){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,o,a,l);return}const x=-(i-e)/u,M=(r-t)/u,m=Math.floor(n/2);let p=h-c,g=t,R=e;const w=[];for(;w.push({x:g,y:R}),g!==r||R!==i;){const t=2*p;t>-c&&(p-=c,g+=f),t<h&&(p+=h,R+=d)}for(const t of w)for(let e=-m;e<=m;e++){const r=Math.round(t.x+x*e),i=Math.round(t.y+M*e);this.pixelRenderer.setPixel(r,i,s,o,a,l)}const y=-(r-t)/u,S=-(i-e)/u;for(let r=1;r<=m;r++){const i=Math.round(t+y*r),n=Math.round(e+S*r);for(let t=-m;t<=m;t++){const e=Math.round(i+x*t),r=Math.round(n+M*t);this.pixelRenderer.setPixel(e,r,s,o,a,l)}}const C=(r-t)/u,P=(i-e)/u;for(let t=1;t<=m;t++){const e=Math.round(r+C*t),n=Math.round(i+P*t);for(let t=-m;t<=m;t++){const r=Math.round(e+x*t),i=Math.round(n+M*t);this.pixelRenderer.setPixel(r,i,s,o,a,l)}}}_drawLineThickParallelOffset(t,e,r,i,n,s,o,a,l){t=Math.floor(t-.5),e=Math.floor(e-.5),r=Math.floor(r-.5),i=Math.floor(i-.5);const h=Math.sqrt((r-t)**2+(i-e)**2);if(0===h){const r=Math.floor(n/2);for(let i=-r;i<=r;i++)for(let n=-r;n<=r;n++)this.pixelRenderer.setPixel(t+n,e+i,s,o,a,l);return}const c=-(i-e)/h,f=(r-t)/h,d=(r-t)/h,u=(i-e)/h,x=n/2,M=Math.ceil(x);for(let n=-M;n<=M;n++){const h=n/M*x,d=t+c*h,u=e+f*h,m=r+c*h,p=i+f*h;this._drawBresenhamLine(Math.round(d),Math.round(u),Math.round(m),Math.round(p),s,o,a,l)}for(let r=-M;r<=M;r++){const i=r/M*x;for(let r=1;r<=x;r++){const n=Math.round(t-d*r+c*i),h=Math.round(e-u*r+f*i);this.pixelRenderer.setPixel(n,h,s,o,a,l)}}for(let t=-M;t<=M;t++){const e=t/M*x;for(let t=1;t<=x;t++){const n=Math.round(r+d*t+c*e),h=Math.round(i+u*t+f*e);this.pixelRenderer.setPixel(n,h,s,o,a,l)}}}_drawBresenhamLine(t,e,r,i,n,s,o,a){const l=Math.abs(r-t),h=Math.abs(i-e),c=t<r?1:-1,f=e<i?1:-1;let d=l-h;for(;this.pixelRenderer.setPixel(t,e,n,s,o,a),t!==r||e!==i;){const r=2*d;r>-h&&(d-=h,t+=c),r<l&&(d+=l,e+=f)}}_drawLineThickPolygonScan(t,e,r,i,n,s,o,a,l){const h=r-t,c=i-e,f=Math.sqrt(h*h+c*c),d=this._pixelRuns;if(d.length=0,0===f){const r=n>>1,i=0|t,h=0|e;for(let t=-r;t<=r;t++)d.push(i-r,h+t,1+(r<<1));return void this.pixelRenderer.setPixelRuns(d,s,o,a,l)}const u=1/f,x=-c*u,M=h*u,m=.5*n,p=this._corners,g=x*m,R=M*m;p[0].x=t+g,p[0].y=e+R,p[1].x=t-g,p[1].y=e-R,p[2].x=r-g,p[2].y=i-R,p[3].x=r+g,p[3].y=i+R;const w=0|Math.min(p[0].y,p[1].y,p[2].y,p[3].y),y=Math.max(p[0].y,p[1].y,p[2].y,p[3].y)+.999|0,S=this._edges;for(let t=0;t<4;t++){const e=S[t],r=p[t],i=p[t+1&3];e.p1=r,e.p2=i,r.y!==i.y&&(e.invDeltaY=1/(i.y-r.y),e.deltaX=i.x-r.x)}const C=this._intersections;for(let t=w;t<=y;t++){let e=0;for(let r=0;r<4;r++){const i=S[r],n=i.p1,s=i.p2;if(n.y!==s.y&&(t>=n.y&&t<s.y||t>=s.y&&t<n.y)){const r=(t-n.y)*i.invDeltaY;C[e++]=n.x+r*i.deltaX}}if(1===e){const e=0|C[0];d.push(e,t,1)}else if(2===e){const e=C[0],r=C[1],i=e<r?0|e:0|r,n=(e>r?e+.999|0:r+.999|0)-i;n>0&&d.push(i,t,n)}}d.length>0&&this.pixelRenderer.setPixelRuns(d,s,o,a,l)}}class SWRendererRect{constructor(t,e,r,i,n,s){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=s}drawRect(t){if(t.clippingOnly){if(isNearMultipleOf90Degrees(t.rotation)){const{adjustedWidth:e,adjustedHeight:r}=getRotatedDimensionsIfTheCase(t.width,t.height,t.rotation);this.drawAxisAlignedRect(t.center.x,t.center.y,e,r,!0)}else this.drawRotatedRect(t.center.x,t.center.y,t.width,t.height,t.rotation,!0);return}const{center:e,width:r,height:i,rotation:n,clippingOnly:s,strokeWidth:o,strokeColor:{r:a,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:x}}=t;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:M}=getRotatedDimensionsIfTheCase(r,i,n);this.drawAxisAlignedRect(e.x,e.y,t,M,s,o,a,l,h,c,f,d,u,x)}else this.drawRotatedRect(e.x,e.y,r,i,n,s,o,a,l,h,c,f,d,u,x)}clearRect(t){const e=t.center,r=t.width,i=t.height,n=t.rotation;if(isNearMultipleOf90Degrees(n)){const{adjustedWidth:t,adjustedHeight:s}=getRotatedDimensionsIfTheCase(r,i,n);if(t===this.width&&s===this.height&&e.x===t/2&&e.y===s/2)return void this.frameBufferUint8ClampedView.fill(0);this.clearAxisAlignedRect(e.x,e.y,t,s)}else this.fillRotatedRect(e.x,e.y,r,i,n,!1,!0)}drawRotatedRect(t,e,r,i,n,s,o,a,l,h,c,f,d,u,x){const M=Math.cos(n),m=Math.sin(n);if((s||x>0)&&this.fillRotatedRect(t,e,r,i,n,s,!1,f,d,u,x),!s&&c>0){const n=r/2,s=i/2,f=[[-n,-s],[n,-s],[n,s],[-n,s]].map((([r,i])=>({x:t+r*M-i*m,y:e+r*m+i*M})));if(1===o)for(let t=0;t<4;t++){const e=f[t],r=f[(t+1)%4];this.lineRenderer.drawLine1px(e.x,e.y,r.x,r.y,a,l,h,c)}else{const t=o/2;for(let e=0;e<4;e+=2){const r=extendLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,o,a,l,h,c)}for(let e=1;e<4;e+=2){const r=shortenLine(f[e],f[(e+1)%4],t);this.lineRenderer.drawLineThick(r.start.x,r.start.y,r.end.x,r.end.y,o,a,l,h,c)}}}}drawAxisAlignedRect(t,e,r,i,n,s,o,a,l,h,c,f,d,u){if(n&&(s=0),n||u>0){let o=null;if(o=255==h&&s>0?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i)),n){for(let t=Math.floor(o.y);t<Math.ceil(o.y+o.h);t++)for(let e=Math.floor(o.x);e<Math.ceil(o.x+o.w);e++)this.pixelRenderer.clipPixel(e,t);return}const a=this.pixelRenderer.context.globalAlpha,l=255===u&&a>=1;let x=0;l&&(x=255<<24|d<<16|f<<8|c);for(let t=Math.floor(o.y);t<Math.ceil(o.y+o.h);t++)for(let e=Math.floor(o.x);e<Math.ceil(o.x+o.w);e++){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}l?this.frameBufferUint32View[r]=x:this.pixelRenderer.setPixel(e,t,c,f,d,u)}}if(h>0&&s>0){let n=getRectangularStrokeGeometry(t,e,r,i);const c=s/2;for(let t=Math.floor(n.x-c);t<n.x+n.w+c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(t,n.y+e,o,a,l,h),this.pixelRenderer.setPixel(t,n.y+n.h+e,o,a,l,h);for(let t=Math.floor(n.y+c);t<n.y+n.h-c;t++)for(let e=-c;e<c;e++)this.pixelRenderer.setPixel(n.x+e,t,o,a,l,h),this.pixelRenderer.setPixel(n.x+n.w+e,t,o,a,l,h)}}clearAxisAlignedRect(t,e,r,i){t=Math.round(t),e=Math.round(e),r=Math.round(r),i=Math.round(i);const n=t-Math.floor(r/2),s=e-Math.floor(i/2),o=n+r,a=s+i;for(let t=s;t<a;t++)for(let e=n;e<o;e++)this.pixelRenderer.clearPixel(e,t)}fillRotatedRect(t,e,r,i,n,s,o,a,l,h,c){const f=Math.cos(n),d=Math.sin(n),u=r/2,x=i/2,M=[{x:t+u*f-x*d,y:e+u*d+x*f},{x:t+u*f+x*d,y:e+u*d-x*f},{x:t-u*f+x*d,y:e-u*d-x*f},{x:t-u*f-x*d,y:e-u*d+x*f}],m=[];for(let t=0;t<4;t++){const e=M[t],r=M[(t+1)%4],i=r.y-e.y,n=e.x-r.x,s=r.x*e.y-e.x*r.y;m.push({a:i,b:n,c:s})}const p=Math.floor(Math.min(...M.map((t=>t.x)))),g=Math.ceil(Math.max(...M.map((t=>t.x)))),R=Math.floor(Math.min(...M.map((t=>t.y)))),w=Math.ceil(Math.max(...M.map((t=>t.y)))),y=this.pixelRenderer.context.globalAlpha;if(s)for(let t=R;t<=w;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clipPixel(e,t)}else if(o)for(let t=R;t<=w;t++)for(let e=p;e<=g;e++){m.every((r=>r.a*e+r.b*t+r.c>=0))&&this.pixelRenderer.clearPixel(e,t)}else{const t=255===c&&y>=1;let e=0;t&&(e=255<<24|h<<16|l<<8|a);for(let r=R;r<=w;r++)for(let i=p;i<=g;i++){if(m.every((t=>t.a*i+t.b*r+t.c>=0))){if(i<0||i>=this.width||r<0||r>=this.height)continue;const n=r*this.width+i;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=n>>3,r=7&n;if(0===t[e])continue;if(!(t[e]&1<<7-r))continue}t?this.frameBufferUint32View[n]=e:this.pixelRenderer.setPixel(i,r,a,l,h,c)}}}}}class SWRendererCircle{constructor(t){this.pixelRenderer=t}drawCircle(t){const{center:e,radius:r,strokeWidth:i,strokeColor:{r:n,g:s,b:o,a:a},fillColor:{r:l,g:h,b:c,a:f}}=t,d=f>0;if(!d&&(1===i&&a>0)){return void(255===a&&this.pixelRenderer.context.globalAlpha>=1?this.draw1PxStrokeFullCircleBresenhamOpaque(e.x,e.y,r,n,s,o):this.draw1PxStrokeFullCircleBresenhamAlpha(e.x,e.y,r,n,s,o,a))}const u=i>0&&a>0,x=255===f&&this.pixelRenderer.context.globalAlpha>=1;if(d&&!u&&x)return void this.drawOpaqueFillFullCircleBresenham(e.x,e.y,r,l,h,c);if(d&&!u&&!x)return void this.drawSemiTransparentFillFullCircleBresenham(e.x,e.y,r,l,h,c,f);const M=i>0?r-i/2:r,m=r+i/2;this.drawFullCircleFast(e.x,e.y,M,m,l,h,c,f,n,s,o,a)}drawFullCircleSlow(t,e,r,i,n,s,o,a,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,R=g*g,w=a>0,y=f>0&&i>r;if(w&&!y)for(let t=x;t<=M;t++){const e=t-u,r=R-e*e;if(r<0)continue;const i=Math.sqrt(r),l=Math.max(m,Math.ceil(d-i+1e-4)),h=Math.min(p,Math.floor(d+i-1e-4));for(let e=l;e<=h;e++)this.pixelRenderer.setPixel(e,t,n,s,o,a)}else if(y&&!w){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),x=Math.min(p,Math.floor(d+o));if(r<=0||s>e)for(let t=a;t<=x;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{const t=Math.sqrt(e-s),r=Math.min(x,Math.floor(d-t)),n=Math.max(a,Math.ceil(d+t));for(let t=a;t<=r;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=n;t<=x;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}else if(w&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const x=i-u,M=x*x;if(M>t)continue;const g=Math.sqrt(t-M),w=Math.max(m,Math.ceil(d-g)),y=Math.min(p,Math.floor(d+g));let S=-1,C=-1;if(r>0&&M<=e){const t=Math.sqrt(e-M);S=Math.min(y,Math.floor(d-t)),C=Math.max(w,Math.ceil(d+t))}const P=R-M;let k=-1,b=-1;if(P>=0){const t=Math.sqrt(P);k=Math.max(m,Math.ceil(d-t+1e-4)),b=Math.min(p,Math.floor(d+t-1e-4))}if(k>=0)for(let t=k;t<=b;t++)this.pixelRenderer.setPixel(t,i,n,s,o,a);if(r<=0||M>e)for(let t=w;t<=y;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);else{for(let t=w;t<=S;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f);for(let t=C;t<=y;t++)this.pixelRenderer.setPixel(t,i,l,h,c,f)}}}}drawFullCircleFast(t,e,r,i,n,s,o,a,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,R=g*g,w=a>0,y=f>0&&i>r,S=[],C=[];if(w&&!y){for(let t=x;t<=M;t++){const e=t-u,r=R-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(m,Math.ceil(d-i+1e-4)),s=Math.min(p,Math.floor(d+i-1e-4))-n+1;s>0&&S.push(n,t,s)}S.length>0&&this.pixelRenderer.setPixelRuns(S,n,s,o,a)}else if(y&&!w){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));if(r<=0||s>e){const t=l-a+1;t>0&&C.push(a,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),n=Math.max(a,Math.ceil(d+t)),o=r-a+1;o>0&&C.push(a,i,o);const h=l-n+1;h>0&&C.push(n,i,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(w&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(a,Math.ceil(d+t))}const f=R-s;let x=-1,M=-1;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4))}if(x>=0){const t=M-x+1;t>0&&S.push(x,i,t)}if(r<=0||s>e){const t=l-a+1;t>0&&C.push(a,i,t)}else{const t=h-a+1;t>0&&C.push(a,i,t);const e=l-c+1;e>0&&C.push(c,i,e)}}S.length>0&&this.pixelRenderer.setPixelRuns(S,n,s,o,a),C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}}drawFullCircleFastest(t,e,r,i,n,s,o,a,l,h,c,f){const d=t-.5,u=e-.5,x=Math.max(0,Math.floor(u-i-1)),M=Math.min(this.pixelRenderer.height-1,Math.ceil(u+i+1)),m=Math.max(0,Math.floor(d-i-1)),p=Math.min(this.pixelRenderer.width-1,Math.ceil(d+i+1)),g=(r+i)/2,R=g*g,w=a>0,y=f>0&&i>r,S=[],C=[],P=[];if(w&&!y){for(let t=x;t<=M;t++){const e=t-u,r=R-e*e;if(r<0)continue;const i=Math.sqrt(r),n=Math.max(m,Math.ceil(d-i+1e-4)),s=Math.min(p,Math.floor(d+i-1e-4))-n+1;s>0&&S.push(n,t,s)}S.length>0&&this.pixelRenderer.setPixelRuns(S,n,s,o,a)}else if(y&&!w){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));if(r<=0||s>e){const t=l-a+1;t>0&&C.push(a,i,t)}else{const t=Math.sqrt(e-s),r=Math.min(l,Math.floor(d-t)),n=Math.max(a,Math.ceil(d+t)),o=r-a+1;o>0&&C.push(a,i,o);const h=l-n+1;h>0&&C.push(n,i,h)}}C.length>0&&this.pixelRenderer.setPixelRuns(C,l,h,c,f)}else if(w&&y){const t=i*i,e=r*r;for(let i=x;i<=M;i++){const n=i-u,s=n*n;if(s>t)continue;const o=Math.sqrt(t-s),a=Math.max(m,Math.ceil(d-o)),l=Math.min(p,Math.floor(d+o));let h=-1,c=-1;if(r>0&&s<=e){const t=Math.sqrt(e-s);h=Math.min(l,Math.floor(d-t)),c=Math.max(a,Math.ceil(d+t))}const f=R-s;let x=-1,M=-1,g=0;if(f>=0){const t=Math.sqrt(f);x=Math.max(m,Math.ceil(d-t+1e-4)),M=Math.min(p,Math.floor(d+t-1e-4)),g=M-x+1}let w=-1,y=0,S=-1,C=0;r<0||s>e?(w=a,y=l-a+1):(w=a,y=h-a+1,S=c,C=l-c+1),P.push(g>0?x:-1,g>0?g:-1,y>0?w:-1,y>0?y:-1,C>0?S:-1,C>0?C:-1)}P.length>0&&this.pixelRenderer.setPixelFillAndStrokeRuns(x,P,n,s,o,a,l,h,c,f)}}draw1PxStrokeFullCircleBresenhamOpaque(t,e,r,i,n,s){const o=this.pixelRenderer;if(!o)return void console.error("Pixel renderer not found!");const a=o.width,l=o.height,h=(o.frameBufferUint8ClampedView,o.frameBufferUint32View),c=o.context,f=c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=r,x=Math.floor(t),M=Math.floor(e),m=Math.floor(u);if(m<0)return;if(0===m){if(u>=0){const r=Math.round(t),a=Math.round(e);o.setPixel(r,a,i,n,s,255)}return}let p=0,g=0;u>0&&2*u%2==1&&(p=1,g=1);if(x+m<0||x-m-p>=a||M+m<0||M-m-g>=l)return;let R=0,w=m,y=3-2*m;for(;R<=w;){const t=x+R,e=M+w,r=x+w,i=M+R,n=x+w,s=M-R-g,o=x+R,c=M-w-g,u=x-R-p,m=M-w-g,S=x-w-p,C=M-R-g,P=x-w-p,k=M+R,b=x-R-p,B=M+w;if(t>=0&&t<a&&e>=0&&e<l){const r=e*a+t;(!f||0!==f[r>>3]&&f[r>>3]&1<<7-(7&r))&&(h[r]=d)}if(r>=0&&r<a&&i>=0&&i<l&&R!==w){const t=i*a+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(n>=0&&n<a&&s>=0&&s<l){const t=s*a+n;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(o>=0&&o<a&&c>=0&&c<l){const t=c*a+o;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(u>=0&&u<a&&m>=0&&m<l){const t=m*a+u;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(S>=0&&S<a&&C>=0&&C<l&&R!==w){const t=C*a+S;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(P>=0&&P<a&&k>=0&&k<l){const t=k*a+P;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}if(b>=0&&b<a&&B>=0&&B<l){const t=B*a+b;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}y<0?y=y+4*R+6:(y=y+4*(R-w)+10,w--),R++}}draw1PxStrokeFullCircleBresenhamAlpha(t,e,r,i,n,s,o){const a=this.pixelRenderer;if(!a)return void console.error("Pixel renderer not found!");const l=a.context.globalAlpha;if(0===o||l<=0)return;const h=a.width,c=a.height,f=a.frameBufferUint8ClampedView,d=a.context,u=d.currentState?d.currentState.clippingMask:null,x=o/255*l,M=1-x;if(x<=0)return;const m=r,p=Math.floor(t),g=Math.floor(e),R=Math.floor(m);if(R<0)return;if(0===R){if(m>=0){const r=Math.round(t),l=Math.round(e);a.setPixel(r,l,i,n,s,o)}return}let w=0,y=0;m>0&&2*m%2==1&&(w=1,y=1);if(p+R<0||p-R-w>=h||g+R<0||g-R-y>=c)return;let S=0,C=R,P=3-2*R;const k=new Set;for(;S<=C;){const t=p+S,e=g+C,r=p+C,i=g+S,n=p+C,s=g-S-y,o=p+S,a=g-C-y,l=p-S-w,f=g-C-y,d=p-C-w,u=g-S-y,x=p-C-w,M=g+S,m=p-S-w,R=g+C;t>=0&&t<h&&e>=0&&e<c&&k.add(e*h+t),r>=0&&r<h&&i>=0&&i<c&&k.add(i*h+r),n>=0&&n<h&&s>=0&&s<c&&k.add(s*h+n),o>=0&&o<h&&a>=0&&a<c&&k.add(a*h+o),l>=0&&l<h&&f>=0&&f<c&&k.add(f*h+l),d>=0&&d<h&&u>=0&&u<c&&k.add(u*h+d),x>=0&&x<h&&M>=0&&M<c&&k.add(M*h+x),m>=0&&m<h&&R>=0&&R<c&&k.add(R*h+m),P<0?P=P+4*S+6:(P=P+4*(S-C)+10,C--),S++}if(k.size>0)for(const t of k){const e=4*t;let r=!1;if(u){const e=t>>3,i=7&t;0!==u[e]&&u[e]&1<<7-i||(r=!0)}if(!r){const t=f[e+3]/255*M,r=x+t;if(r>0){const o=1/r;f[e]=(i*x+f[e]*t)*o,f[e+1]=(n*x+f[e+1]*t)*o,f[e+2]=(s*x+f[e+2]*t)*o,f[e+3]=255*r}}}}_generateRelativeHorizontalExtentsBresenham(t){const e=t,r=Math.floor(e);if(r<0)return null;let i=0,n=0;if(e>0&&2*e%2==1&&(i=1,n=1),0===r)return{relativeExtents:[0],intRadius:0,xOffset:i,yOffset:n};const s=new Array(r+1).fill(0);let o=0,a=r,l=3-2*r;for(;o<=a;)s[a]=Math.max(s[a],o),s[o]=Math.max(s[o],a),l<0?l=l+4*o+6:(l=l+4*(o-a)+10,a--),o++;return{relativeExtents:s,intRadius:r,xOffset:i,yOffset:n}}drawOpaqueFillFullCircleBresenham(t,e,r,i,n,s){const o=this.pixelRenderer;if(!o)return void console.error("Pixel renderer not found!");const a=o.width,l=o.height,h=(o.frameBufferUint8ClampedView,o.frameBufferUint32View),c=o.context,f=c&&c.currentState?c.currentState.clippingMask:null,d=255<<24|s<<16|n<<8|i,u=this._generateRelativeHorizontalExtentsBresenham(r);if(!u)return;const{relativeExtents:x,intRadius:M,xOffset:m,yOffset:p}=u;if(0===M&&r>=0){const r=Math.round(t),i=Math.round(e);if(r>=0&&r<a&&i>=0&&i<l){const t=i*a+r;(!f||0!==f[t>>3]&&f[t>>3]&1<<7-(7&t))&&(h[t]=d)}return}const g=Math.floor(t-.5),R=Math.floor(e-.5),w=x[0];if(!(g+w<0||g-w-m>=a||R+M<0||R-M-p>=l))if(f)for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,i=g+e,n=R+t,s=R-t-p+1;if(n>=0&&n<l){const t=Math.max(0,r),e=n*a+Math.min(a-1,i);let s=n*a+t;for(;s<=e;){const t=s>>3,r=7&s;if(0===r&&s+7<=e){const e=f[t];if(255===e){const t=s+7;for(;s<=t;)h[s]=d,s++;continue}if(0===e){s+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[s]=d),s++}}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){const t=Math.max(0,r),e=s*a+Math.min(a-1,i);let n=s*a+t;for(;n<=e;){const t=n>>3,r=7&n;if(0===r&&n+7<=e){const e=f[t];if(255===e){const t=n+7;for(;n<=t;)h[n]=d,n++;continue}if(0===e){n+=8;continue}}const i=1<<7-r;0!==(f[t]&i)&&(h[n]=d),n++}}}else for(let t=0;t<=M;t++){const e=x[t],r=g-e-m+1,i=g+e,n=R+t,s=R-t-p+1;if(n>=0&&n<l){let t=n*a+Math.max(0,r);const e=n*a+Math.min(a-1,i);for(;t<=e;)h[t]=d,t++}if(t>0&&!(1===t&&0===p)&&s>=0&&s<l){let t=s*a+Math.max(0,r);const e=s*a+Math.min(a-1,i);for(;t<=e;)h[t]=d,t++}}}drawSemiTransparentFillFullCircleBresenham(t,e,r,i,n,s,o){const a=this.pixelRenderer;if(!a)return void console.error("Pixel renderer not found!");const l=a.context.globalAlpha;if(0===o||l<=0)return;const h=a.width,c=a.height,f=a.frameBufferUint8ClampedView,d=a.context,u=d&&d.currentState?d.currentState.clippingMask:null,x=o/255*l,M=1-x;if(x<=0)return;const m=this._generateRelativeHorizontalExtentsBresenham(r);if(!m)return;const{relativeExtents:p,intRadius:g,xOffset:R,yOffset:w}=m;if(0===g&&r>=0){const r=Math.round(t),l=Math.round(e);return void a.setPixel(r,l,i,n,s,o)}const y=Math.floor(t-.5),S=Math.floor(e-.5),C=p[0];if(y+C<0||y-C-R>=h||S+g<0||S-g-w>=c)return;const P=t=>{const e=4*t,r=f[e+3]/255*M,o=x+r;if(o>0){const t=1/o;f[e]=(i*x+f[e]*r)*t,f[e+1]=(n*x+f[e+1]*r)*t,f[e+2]=(s*x+f[e+2]*r)*t,f[e+3]=255*o}};if(u)for(let t=0;t<=g;t++){const e=p[t],r=y-e-R+1,i=y+e,n=S+t,s=S-t-w+1;if(n>=0&&n<c){const t=Math.max(0,r),e=n*h+Math.min(h-1,i);let s=n*h+t;for(;s<=e;){const t=s>>3,r=7&s,i=1<<7-r;if(0===r&&s+7<=e){if(0===u[t]){s+=8;continue}}0!==(u[t]&i)&&P(s),s++}}if(t>0&&!(1===t&&0===w)&&s>=0&&s<c){const t=Math.max(0,r),e=s*h+Math.min(h-1,i);let n=s*h+t;for(;n<=e;){const t=n>>3,r=7&n,i=1<<7-r;if(0===r&&n+7<=e){if(0===u[t]){n+=8;continue}}0!==(u[t]&i)&&P(n),n++}}}else for(let t=0;t<=g;t++){const e=p[t],r=y-e-R+1,i=y+e,n=S+t,s=S-t-w+1;if(n>=0&&n<c){let t=n*h+Math.max(0,r);const e=n*h+Math.min(h-1,i);for(;t<=e;)P(t),t++}if(t>0&&!(1===t&&0===w)&&s>=0&&s<c){let t=s*h+Math.max(0,r);const e=s*h+Math.min(h-1,i);for(;t<=e;)P(t),t++}}}}class SWRendererRoundedRect{constructor(t,e,r,i,n,s,o){this.frameBufferUint8ClampedView=t,this.frameBufferUint32View=e,this.width=r,this.height=i,this.lineRenderer=n,this.pixelRenderer=s,this.swRectRenderer=o}drawRoundedRect(t){const{center:e,width:r,height:i,radius:n,rotation:s,strokeWidth:o,strokeColor:{r:a,g:l,b:h,a:c},fillColor:{r:f,g:d,b:u,a:x}}=t;if(isNearMultipleOf90Degrees(s)){const{adjustedWidth:t,adjustedHeight:M}=getRotatedDimensionsIfTheCase(r,i,s),m=n>2?n-1:n;0==o||255===c||o<5&&255===c?this.drawCrispAxisAlignedRoundedRectThinOpaqueStroke(e.x,e.y,t,M,m,o,a,l,h,c,f,d,u,x):this.drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(e.x,e.y,t,M,m,o,a,l,h,c,f,d,u,x)}else this.drawRotatedRoundedRect(e.x,e.y,r,i,n,s,o,a,l,h,c,f,d,u,x)}drawCrispAxisAlignedRoundedRectThinOpaqueStroke(t,e,r,i,n,s,o,a,l,h,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");if(u>0&&this.drawRoundedRectFill(t,e,r,i,n,s,c,f,d,u,255==h&&s>0),h>0&&s>0)if(1===s){let s=getRectangularStrokeGeometry(t,e,r,i),c=Math.round(Math.min(n,Math.min(s.w,s.h)/2));for(let t=Math.floor(s.x+c);t<s.x+s.w-c;t++)this.pixelRenderer.setPixel(t,s.y-.5,o,a,l,h),this.pixelRenderer.setPixel(t,s.y+s.h-.5,o,a,l,h);for(let t=Math.floor(s.y+c);t<s.y+s.h-c;t++)this.pixelRenderer.setPixel(s.x-.5,t,o,a,l,h),this.pixelRenderer.setPixel(s.x+s.w-.5,t,o,a,l,h);const f=(t,e,r,i)=>{for(let n=r;n<=i;n+=Math.PI/180){const r=c-.5,i=t+r*Math.cos(n),s=e+r*Math.sin(n);this.pixelRenderer.setPixel(Math.floor(i),Math.floor(s),o,a,l,h)}};f(s.x+c,s.y+c,Math.PI,3*Math.PI/2),f(s.x+s.w-c,s.y+c,3*Math.PI/2,2*Math.PI),f(s.x+s.w-c,s.y+s.h-c,0,Math.PI/2),f(s.x+c,s.y+s.h-c,Math.PI/2,Math.PI)}else this.drawRoundedRectStroke(t,e,r,i,n,s,o,a,l,h)}drawCrispAxisAlignedRoundedRectThickOrSemitrasparentStroke(t,e,r,i,n,s,o,a,l,h,c,f,d,u){if(r%1!=0||i%1!=0)throw new Error("Width and height must be integers");u>0&&this.drawRoundedRectFill(t,e,r,i,n,s,c,f,d,u,255==h&&s>0),h>0&&s>0&&this.drawRoundedRectStroke(t,e,r,i,n,s,o,a,l,h)}drawRoundedRectFill(t,e,r,i,n,s,o,a,l,h,c=!1){let f=null;f=c?roundCornerOfRectangularGeometry(getRectangularFillGeometry(t,e,r,i)):roundCornerOfRectangularGeometryWithWarning(getRectangularFillGeometry(t,e,r,i));let d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));function u(t,e){if(t>=f.x+d&&t<f.x+f.w-d&&e>=f.y&&e<f.y+f.h)return!0;if(t>=f.x&&t<f.x+f.w&&e>=f.y+d&&e<f.y+f.h-d)return!0;const r=[{x:f.x+d,y:f.y+d},{x:f.x+f.w-d,y:f.y+d},{x:f.x+f.w-d,y:f.y+f.h-d},{x:f.x+d,y:f.y+f.h-d}];for(const i of r){const r=t-i.x+1,n=e-i.y+1;if(r*r+n*n<d*d)return!0}return!1}const x=this.pixelRenderer.context.globalAlpha,M=255===h&&x>=1;let m=0;M&&(m=255<<24|l<<16|a<<8|o);for(let t=Math.floor(f.y);t<=Math.ceil(f.y+f.h);t++)for(let e=Math.floor(f.x);e<=Math.ceil(f.x+f.w);e++)if(u(Math.ceil(e),Math.ceil(t))){if(e<0||e>=this.width||t<0||t>=this.height)continue;const r=t*this.width+e;if(this.pixelRenderer.context.currentState){const t=this.pixelRenderer.context.currentState.clippingMask,e=r>>3,i=7&r;if(0===t[e])continue;if(!(t[e]&1<<7-i))continue}M?this.frameBufferUint32View[r]=m:this.pixelRenderer.setPixel(e,t,o,a,l,h)}}drawRoundedRectStroke(t,e,r,i,n,s,o,a,l,h){const c=s/2;let f=getRectangularStrokeGeometry(t,e,r,i),d=Math.round(Math.min(n,Math.min(f.w,f.h)/2));const u=new PixelSet(this.pixelRenderer),x=new ScanlineSpans;for(let t=f.y-c;t<f.y+c;t++)x.addSpan(t,f.x+d,f.x+f.w-d);for(let t=f.y+f.h-c;t<f.y+f.h+c;t++)x.addSpan(t,f.x+d,f.x+f.w-d);x.addToPixelSet(u,o,a,l,h);const M=new ScanlineSpans,m=new ScanlineSpans;for(let t=f.y+d;t<f.y+f.h-d;t++){for(let e=f.x-c;e<f.x+c;e++)M.addPixel(e,t);for(let e=f.x+f.w-c;e<f.x+f.w+c;e++)m.addPixel(e,t)}M.addToPixelSet(u,o,a,l,h),m.addToPixelSet(u,o,a,l,h);const p=(t,e,r,i)=>{const n=new ScanlineSpans,s=Math.PI/180;for(let o=r;o<=i;o+=s)for(let r=-c;r<c;r++){const i=d+r,s=t+i*Math.cos(o),a=e+i*Math.sin(o);n.addPixel(Math.floor(s),Math.floor(a))}n.addToPixelSet(u,o,a,l,h)};p(f.x+d,f.y+d,Math.PI,3*Math.PI/2),p(f.x+f.w-d,f.y+d,3*Math.PI/2,2*Math.PI),p(f.x+f.w-d,f.y+f.h-d,0,Math.PI/2),p(f.x+d,f.y+f.h-d,Math.PI/2,Math.PI),u.paint()}drawRotatedRoundedRect(t,e,r,i,n,s,o,a,l,h,c,f,d,u,x){const M=Math.cos(s),m=Math.sin(s),p=r/2,g=i/2,R=[[-p+n,-g+n],[p-n,-g+n],[p-n,g-n],[-p+n,g-n]].map((([r,i])=>({x:t+r*M-i*m,y:e+r*m+i*M}))),w=R.map(((t,e)=>{const r=R[(e+1)%4],i=r.x-t.x,n=r.y-t.y,s=Math.sqrt(i*i+n*n);return{dx:i/s,dy:n/s}})),y=R.map(((t,e)=>{const r=w[(e+3)%4],i=w[e],s=-r.dy,o=r.dx,a=-i.dy,l=i.dx;return{start:{x:t.x-n*s,y:t.y-n*o},end:{x:t.x-n*a,y:t.y-n*l}}}));if(x>0){this.swRectRenderer.fillRotatedRect(t,e,r-2*n,i-2*n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+-n*m,e+(-i/2+n/2)*M,r-2*n,n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+(r/2-n/2)*M,e+(r/2-n/2)*m,n,i-2*n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+n*m,e+(i/2-n/2)*M,r-2*n,n,s,!1,!1,f,d,u,x),this.swRectRenderer.fillRotatedRect(t+(-r/2+n/2)*M,e+(-r/2+n/2)*m,n,i-2*n,s,!1,!1,f,d,u,x);const o=180*s/Math.PI;R.forEach(((t,e)=>{const r=[[180,270],[270,360],[0,90],[90,180]][e],i=(r[0]+o)%360,s=(r[1]+o)%360;drawArcSWHelper(t.x,t.y,n,i,s,f,d,u,x,!0)}))}if(c>0){for(let t=0;t<4;t++){const e=y[t],r=y[(t+1)%4];this.lineRenderer.drawLineThick(e.end.x,e.end.y,r.start.x,r.start.y,o,a,l,h,c)}const t=180*s/Math.PI;R.forEach(((e,r)=>{const i=[[180,270],[270,360],[0,90],[90,180]][r],s=(i[0]+t)%360,f=(i[1]+t)%360;drawArcSWHelper(e.x,e.y,n,s,f,a,l,h,c,!1,o)}))}}}class CrispSwCanvas{static version="1.0.2";constructor(t,e){if("object"==typeof t){const e=t;this.width=e.width,this.height=e.height,this.title=e.title||""}else this.width=t,this.height=e,this.title="";this._context=new CrispSwContext(this)}getContext(t){if("2d"!==t)throw new Error("Only '2d' context is supported");return this._context}}const isNode="undefined"==typeof window&&"undefined"!=typeof process;class CrispSwContext{constructor(t){this.canvas=t,t.title||(t.title=""),this.displayCanvas={width:t.width,height:t.height,title:t.title},this.title=t.title,this.stateStack=[new ContextState(t.width,t.height)],this.frameBufferUint8ClampedView=new Uint8ClampedArray(t.width*t.height*4).fill(0),this.frameBufferUint32View=new Uint32Array(this.frameBufferUint8ClampedView.buffer),this.tempClippingMask=new Uint8Array(Math.ceil(t.width*t.height/8)).fill(0),this.pixelRenderer=new SWRendererPixel(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this),this.lineRenderer=new SWRendererLine(this.pixelRenderer),this.rectRenderer=new SWRendererRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer),this.roundedRectRenderer=new SWRendererRoundedRect(this.frameBufferUint8ClampedView,this.frameBufferUint32View,t.width,t.height,this.lineRenderer,this.pixelRenderer,this.rectRenderer),this.circleRenderer=new SWRendererCircle(this.pixelRenderer)}get currentState(){return this.stateStack[this.stateStack.length-1]}save(){this.stateStack.push(this.currentState.clone())}restore(){if(this.stateStack.length<=1)throw new Error("Cannot restore() - stack is empty");this.stateStack.pop()}scale(t,e){this.currentState.transform=this.currentState.transform.scale(t,e)}rotate(t){this.currentState.transform=this.currentState.transform.rotate(t)}translate(t,e){this.currentState.transform=this.currentState.transform.translate(t,e)}resetTransform(){this.currentState.transform.reset()}set fillStyle(t){this.currentState.fillColor=parseColor(t)}set strokeStyle(t){this.currentState.strokeColor=parseColor(t)}set lineWidth(t){this.currentState.lineWidth=t}set globalAlpha(t){this.currentState.globalAlpha=Math.max(0,Math.min(1,t))}get globalAlpha(){return this.currentState.globalAlpha}beginPath(){this.tempClippingMask.fill(0)}fill(){throw new Error("fill() is not supported - use fillRect() instead")}stroke(){throw new Error("stroke() is not supported - use strokeRect() instead")}strokeLine(t,e,r,i){const n=this.currentState,s=getScaledLineWidth(n.transform.elements,n.lineWidth),o=transformPoint(t,e,n.transform.elements),a=transformPoint(r,i,n.transform.elements);this.lineRenderer.drawLine({start:{x:o.tx,y:o.ty},end:{x:a.tx,y:a.ty},thickness:s,color:n.strokeColor})}clearRect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements);this.rectRenderer.clearRect({center:{x:s.tx,y:s.ty},width:r,height:i,rotation:o})}rect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements),{scaleX:a,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*a,height:i*l,rotation:o,clippingOnly:!0})}clip(){for(let t=0;t<this.currentState.clippingMask.length;t++)this.currentState.clippingMask[t]=this.currentState.clippingMask[t]&this.tempClippingMask[t]}fillRect(t,e,r,i){const n=this.currentState,s=transformPoint(t+r/2,e+i/2,n.transform.elements),o=getRotationAngle(n.transform.elements),{scaleX:a,scaleY:l}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:s.tx,y:s.ty},width:r*a,height:i*l,rotation:o,clippingOnly:!1,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:n.fillColor})}strokeRect(t,e,r,i){const n=this.currentState,s=getScaledLineWidth(n.transform.elements,n.lineWidth),o=transformPoint(t+r/2,e+i/2,n.transform.elements),a=getRotationAngle(n.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(n.transform.elements);this.rectRenderer.drawRect({center:{x:o.tx,y:o.ty},width:r*l,height:i*h,rotation:a,clippingOnly:!1,strokeWidth:s,strokeColor:n.strokeColor,fillColor:{r:0,g:0,b:0,a:0}})}blitToCanvas(t){if(isNode)return;const e=new ImageData(this.frameBufferUint8ClampedView,this.canvas.width,this.canvas.height);t.getContext("2d").putImageData(e,0,0)}fillCircle(t,e,r,i,n,s,o){const a=this.currentState,l=transformPoint(t,e,a.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(a.transform.elements),f=r*Math.max(h,c),d={center:{x:l.tx,y:l.ty},radius:f,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0},fillColor:{r:i,g:n,b:s,a:o}};this.circleRenderer.drawCircle(d)}strokeCircle(t,e,r,i,n,s,o,a){const l=this.currentState,h=transformPoint(t,e,l.transform.elements),{scaleX:c,scaleY:f}=getScaleFactors(l.transform.elements),d=r*Math.max(c,f),u=getScaledLineWidth(l.transform.elements,i),x={center:{x:h.tx,y:h.ty},radius:d,strokeWidth:u,strokeColor:{r:n,g:s,b:o,a:a},fillColor:{r:0,g:0,b:0,a:0}};this.circleRenderer.drawCircle(x)}fillAndStrokeCircle(t,e,r,i,n,s,o,a,l,h,c,f){const d=this.currentState,u=transformPoint(t,e,d.transform.elements),{scaleX:x,scaleY:M}=getScaleFactors(d.transform.elements),m=r*Math.max(x,M),p=getScaledLineWidth(d.transform.elements,a),g={center:{x:u.tx,y:u.ty},radius:m,strokeWidth:p,strokeColor:{r:l,g:h,b:c,a:f},fillColor:{r:i,g:n,b:s,a:o}};this.circleRenderer.drawCircle(g)}getImageData(t,e,r,i){const n=this.canvas.width,s=this.canvas.height;t=Math.max(0,Math.min(Math.floor(t),n)),e=Math.max(0,Math.min(Math.floor(e),s)),r=Math.max(0,Math.min(Math.floor(r),n-t)),i=Math.max(0,Math.min(Math.floor(i),s-e));const o=new Uint8ClampedArray(r*i*4);if(0===t&&0===e&&r===n&&i===s)o.set(this.frameBufferUint8ClampedView);else for(let s=0;s<i;s++)for(let i=0;i<r;i++){const a=4*((e+s)*n+(t+i)),l=4*(s*r+i);o[l]=this.frameBufferUint8ClampedView[a],o[l+1]=this.frameBufferUint8ClampedView[a+1],o[l+2]=this.frameBufferUint8ClampedView[a+2],o[l+3]=this.frameBufferUint8ClampedView[a+3]}const a=new ImageData(o,r,i);return void 0===a.canvasTitle&&Object.defineProperty(a,"canvasTitle",{get:()=>this.canvas.title||this.title||"",configurable:!0}),a}roundRect(t,e,r,i,n){const s=this.currentState,{scaleX:o,scaleY:a}=(transformPoint(t+r/2,e+i/2,s.transform.elements),getRotationAngle(s.transform.elements),getScaleFactors(s.transform.elements));throw new Error("CrispSwContext.roundRect() for path definition / clipping is not yet implemented.")}fillRoundRect(t,e,r,i,n){const s=this.currentState,o=transformPoint(t+r/2,e+i/2,s.transform.elements),a=getRotationAngle(s.transform.elements),{scaleX:l,scaleY:h}=getScaleFactors(s.transform.elements),c=n*Math.min(Math.abs(l),Math.abs(h));this.roundedRectRenderer.drawRoundedRect({center:{x:o.tx,y:o.ty},width:r*l,height:i*h,radius:c,rotation:a,fillColor:s.fillColor,strokeWidth:0,strokeColor:{r:0,g:0,b:0,a:0}})}strokeRoundRect(t,e,r,i,n){const s=this.currentState,o=getScaledLineWidth(s.transform.elements,s.lineWidth),a=transformPoint(t+r/2,e+i/2,s.transform.elements),l=getRotationAngle(s.transform.elements),{scaleX:h,scaleY:c}=getScaleFactors(s.transform.elements),f=n*Math.min(Math.abs(h),Math.abs(c));this.roundedRectRenderer.drawRoundedRect({center:{x:a.tx,y:a.ty},width:r*h,height:i*c,radius:f,rotation:l,fillColor:{r:0,g:0,b:0,a:0},strokeWidth:o,strokeColor:s.strokeColor})}}