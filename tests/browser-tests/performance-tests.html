<!DOCTYPE html>
<html>
<head>
  <title>Performance Tests - Software Canvas vs HTML5 Canvas</title>
  <link rel="stylesheet" href="styles/main.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1, h2, h3 {
      color: #333;
    }
    
    .test-controls {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 5px;
    }
    
    .canvas-container {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    
    .canvas-wrapper {
      width: 48%;
    }
    
    canvas {
      border: 1px solid #ddd;
      margin-bottom: 10px;
    }
    
    .test-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .results {
      font-family: monospace;
      padding: 15px;
      background-color: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
      white-space: pre-wrap;
      overflow-x: auto;
      max-height: 500px;
      overflow-y: auto;
    }
    
    #progress-container {
      width: 100%;
      background-color: #ddd;
      border-radius: 4px;
      margin-top: 10px;
      margin-bottom: 20px;
    }
    
    #progress-bar {
      height: 20px;
      width: 0;
      background-color: #4CAF50;
      border-radius: 4px;
      text-align: center;
      color: white;
      line-height: 20px;
    }
    
    label {
      margin-right: 10px;
    }
    
    .value-display {
      display: inline-block;
      width: 50px;
      text-align: center;
    }
    
    .chart-container {
      width: 100%;
      height: 400px;
      margin-top: 20px;
      margin-bottom: 30px;
      border: 1px solid #ddd;
      background-color: #fff;
    }
  </style>
</head>

<body>
  <h1>Performance Tests - Software Canvas vs HTML5 Canvas</h1>
  
  <div class="test-controls">
    <h2>Test Configuration</h2>
    
    <div>
      <label for="sw-increment-size">SW Canvas increment size:</label>
      <input type="number" id="sw-increment-size" min="1" max="100" value="1" style="width: 60px;">
    </div>
    
    <div>
      <label for="html-increment-size">HTML5 Canvas increment size:</label>
      <input type="number" id="html-increment-size" min="1" max="1000" value="500" style="width: 60px;">
    </div>
    
    <div>
      <label for="consecutive-exceedances">Consecutive budget exceedances:</label>
      <input type="number" id="consecutive-exceedances" min="1" max="20" value="10" style="width: 60px;">
    </div>
    
    <div>
      <label>
        <input type="checkbox" id="include-blitting" checked>
        Include blitting time for Software Canvas
      </label>
    </div>
    
    <div class="test-buttons">
      <button id="btn-lines-test">Run Lines Test</button>
      <button id="btn-rects-test">Run Rectangles Test</button>
      <button id="btn-circles-test">Run Circles Test</button>
      <button id="btn-run-all">Run All Tests</button>
      <button id="btn-abort" disabled>Abort Tests</button>
    </div>
  </div>
  
  <div id="progress-container" style="display: none;">
    <div id="progress-bar">0%</div>
  </div>
  
  <div class="canvas-container">
    <div class="canvas-wrapper">
      <h3>Software Canvas</h3>
      <canvas id="sw-canvas" width="500" height="400"></canvas>
    </div>
    <div class="canvas-wrapper">
      <h3>HTML5 Canvas</h3>
      <canvas id="canvas" width="500" height="400"></canvas>
    </div>
  </div>
  
  <h2>Test Results</h2>
  <div class="results" id="results-container"></div>
  
  <div class="chart-container" id="chart-container"></div>

  <!-- Load library scripts -->
  <script src="../../build/crisp-sw-canvas-v1.0.2.min.js"></script>
  <script src="../../src/scene-creation/SeededRandom.js"></script>
  
  <script>
    // Constants
    const CANVAS_WIDTH = 500;
    const CANVAS_HEIGHT = 400;
    const FRAME_BUDGET = 16.7; // milliseconds (60fps)
    const STARTING_SHAPE_COUNT = 10;
    
    // Elements
    const swCanvas = document.getElementById('sw-canvas');
    const canvas = document.getElementById('canvas');
    const resultsContainer = document.getElementById('results-container');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const chartContainer = document.getElementById('chart-container');
    
    // Canvas contexts
    const swCtx = new CrispSwContext(swCanvas);
    const ctx = canvas.getContext('2d');
    
    // Controls
    const swIncrementSize = document.getElementById('sw-increment-size');
    const htmlIncrementSize = document.getElementById('html-increment-size');
    const consecutiveExceedances = document.getElementById('consecutive-exceedances');
    const includeBlittingCheckbox = document.getElementById('include-blitting');
    
    // Buttons
    const btnLinesTest = document.getElementById('btn-lines-test');
    const btnRectsTest = document.getElementById('btn-rects-test');
    const btnCirclesTest = document.getElementById('btn-circles-test');
    const btnRunAll = document.getElementById('btn-run-all');
    const btnAbort = document.getElementById('btn-abort');
    
    // Test state
    let currentTest = null;
    let abortRequested = false;
    let animationFrameId = null;
    
    // Button event listeners
    btnLinesTest.addEventListener('click', () => runTest('lines'));
    btnRectsTest.addEventListener('click', () => runTest('rects'));
    btnCirclesTest.addEventListener('click', () => runTest('circles'));
    btnRunAll.addEventListener('click', runAllTests);
    btnAbort.addEventListener('click', abortTests);
    
    // Test execution functions
    function runAllTests() {
      const tests = ['lines', 'rects', 'circles'];
      let currentIndex = 0;
      
      // Clear previous results
      resultsContainer.innerHTML = "Running all tests...\n\n";
      
      // Store results for overall summary
      const allResults = {
        tests: [],
        swMaxShapes: [],
        canvasMaxShapes: [],
        ratios: []
      };
      
      function runNextTest() {
        if (currentIndex < tests.length && !abortRequested) {
          runTest(tests[currentIndex], (testResults) => {
            // Store individual test results
            allResults.tests.push(tests[currentIndex]);
            allResults.swMaxShapes.push(testResults.swMaxShapes);
            allResults.canvasMaxShapes.push(testResults.canvasMaxShapes);
            allResults.ratios.push(testResults.ratio);
            
            currentIndex++;
            runNextTest();
          }, false);
        } else {
          // Show overall results after all tests are done
          displayOverallResults(allResults);
          resetTestState();
        }
      }
      
      runNextTest();
    }
    
    function abortTests() {
      abortRequested = true;
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      resetTestState();
      resultsContainer.innerHTML += "Tests aborted by user.\n";
    }
    
    function resetTestState() {
      currentTest = null;
      abortRequested = false;
      setButtonsState(true);
      progressContainer.style.display = 'none';
    }
    
    function setButtonsState(enabled) {
      btnLinesTest.disabled = !enabled;
      btnRectsTest.disabled = !enabled;
      btnCirclesTest.disabled = !enabled;
      btnRunAll.disabled = !enabled;
      btnAbort.disabled = enabled;
    }
    
    function runTest(testType, callback = null, clearResults = true) {
      setButtonsState(false);
      currentTest = testType;
      abortRequested = false;
      
      // Get test parameters
      const swIncrement = parseInt(swIncrementSize.value);
      const htmlIncrement = parseInt(htmlIncrementSize.value);
      const requiredExceedances = parseInt(consecutiveExceedances.value);
      const includeBlitting = includeBlittingCheckbox.checked;
      
      // Clear previous results if not part of "Run All Tests"
      if (clearResults) {
        resultsContainer.innerHTML = `Running ${testType} test with SW increment ${swIncrement}, HTML increment ${htmlIncrement}${includeBlitting ? ' (including blitting time)' : ' (excluding blitting time)'}...\n\n`;
      } else {
        resultsContainer.innerHTML += `\nRunning ${testType} test with SW increment ${swIncrement}, HTML increment ${htmlIncrement}${includeBlitting ? ' (including blitting time)' : ' (excluding blitting time)'}...\n\n`;
      }
      
      // Show progress bar
      progressContainer.style.display = 'block';
      progressBar.style.width = '0%';
      progressBar.textContent = '0%';
      
      // Testing data structure
      const testData = {
        testType,
        swIncrement,
        htmlIncrement,
        includeBlitting,
        requiredExceedances,
        // Software Canvas results
        swShapeCounts: [],
        swTimings: [],
        swMaxShapes: 0,
        // HTML5 Canvas results
        canvasShapeCounts: [],
        canvasTimings: [],
        canvasMaxShapes: 0
      };
      
      // First phase: Test Software Canvas
      resultsContainer.innerHTML += "PHASE 1: Testing Software Canvas...\n";
      resultsContainer.scrollTop = resultsContainer.scrollHeight;
      
      // Start with the software canvas test
      runSoftwareCanvasRampTest(testType, STARTING_SHAPE_COUNT, swIncrement, includeBlitting, requiredExceedances, testData, () => {
        
        // After SW canvas test completes, run HTML5 canvas test
        resultsContainer.innerHTML += "\nPHASE 2: Testing HTML5 Canvas...\n";
        resultsContainer.scrollTop = resultsContainer.scrollHeight;
        
        runHTML5CanvasRampTest(testType, STARTING_SHAPE_COUNT, htmlIncrement, requiredExceedances, testData, () => {
          
          // Calculate performance ratio
          testData.ratio = testData.canvasMaxShapes / testData.swMaxShapes;
          
          // Display final results
          displayRampTestResults(testData);
          
          // Generate performance chart
          generatePerformanceChart(testData);
          
          // Reset test state if not part of "Run All Tests"
          if (!callback) {
            resetTestState();
          }
          
          // Call callback if provided (for runAllTests), passing the results
          if (callback) callback(testData);
        });
      });
    }
    
    // Software Canvas Ramp Test
    function runSoftwareCanvasRampTest(testType, startCount, incrementSize, includeBlitting, requiredExceedances, testData, callback) {
      let currentShapeCount = startCount;
      let exceededBudget = false;
      let totalPhaseSteps = 1000; // Just an estimate for progress bar
      let currentPhaseStep = 0;
      let consecutiveExceedances = 0;
      
      function testNextShapeCount() {
        if (abortRequested || exceededBudget) {
          // All done, report back
          testData.swMaxShapes = findMaxShapes(testData.swShapeCounts, testData.swTimings);
          resultsContainer.innerHTML += `Software Canvas Maximum Shapes: ${testData.swMaxShapes}\n`;
          resultsContainer.scrollTop = resultsContainer.scrollHeight;
          callback();
          return;
        }
        
        // Update progress for this phase
        currentPhaseStep++;
        const progress = Math.min(100, Math.round((currentPhaseStep / totalPhaseSteps) * 50)); // First phase is 50% of total
        progressBar.style.width = `${progress}%`;
        progressBar.textContent = `${progress}%`;
        
        // Clear canvas
        swCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Seed random for consistent shapes
        SeededRandom.seedWithInteger(currentPhaseStep);
        
        // Run the specific test and measure time
        let startTime = performance.now();
        
        // Draw shapes based on test type
        if (testType === 'lines') {
          drawRandomLines(swCtx, currentShapeCount);
        } else if (testType === 'rects') {
          drawRandomRects(swCtx, currentShapeCount);
        } else if (testType === 'circles') {
          drawRandomCircles(swCtx, currentShapeCount);
        }
        
        // Include blitting time if requested
        if (includeBlitting) {
          swCtx.blitToCanvas(swCanvas);
        }
        
        let endTime = performance.now();
        let elapsedTime = endTime - startTime;
        
        const avgTime = elapsedTime;
        const stdDev = 0; // No standard deviation with single measurement
        
        // Store results
        testData.swShapeCounts.push(currentShapeCount);
        testData.swTimings.push(avgTime);
        
        // Log to results
        resultsContainer.innerHTML += `SW Canvas with ${currentShapeCount} shapes: ${avgTime.toFixed(2)}ms\n`;
        // Auto-scroll to show latest results
        resultsContainer.scrollTop = resultsContainer.scrollHeight;
        
        // Check if we exceeded the frame budget
        if (avgTime > FRAME_BUDGET) {
          consecutiveExceedances++;
          resultsContainer.innerHTML += `  Exceeded budget (${consecutiveExceedances}/${requiredExceedances})\n`;
          // Auto-scroll to show exceedance messages
          resultsContainer.scrollTop = resultsContainer.scrollHeight;
          
          // Only stop if we've exceeded enough times consecutively
          if (consecutiveExceedances >= requiredExceedances) {
            exceededBudget = true;
          } else {
            // Continue with the same shape count to confirm if it consistently exceeds budget
            // No need to increment here
          }
        } else {
          // Reset consecutive exceedances counter
          consecutiveExceedances = 0;
          // Increment shape count and continue testing
          currentShapeCount += incrementSize;
        }
        
        // Wait for the next frame before proceeding to next shape count
        animationFrameId = requestAnimationFrame(testNextShapeCount);
      }
      
      // Start with the first shape count
      testNextShapeCount();
    }
    
    // HTML5 Canvas Ramp Test
    function runHTML5CanvasRampTest(testType, startCount, incrementSize, requiredExceedances, testData, callback) {
      let currentShapeCount = startCount;
      let exceededBudget = false;
      let totalPhaseSteps = 1000; // Just an estimate for progress bar
      let currentPhaseStep = 0;
      let consecutiveExceedances = 0;
      
      function testNextShapeCount() {
        if (abortRequested || exceededBudget) {
          // All done, report back
          testData.canvasMaxShapes = findMaxShapes(testData.canvasShapeCounts, testData.canvasTimings);
          resultsContainer.innerHTML += `HTML5 Canvas Maximum Shapes: ${testData.canvasMaxShapes}\n`;
          resultsContainer.scrollTop = resultsContainer.scrollHeight;
          callback();
          return;
        }
        
        // Update progress for this phase
        currentPhaseStep++;
        const progress = Math.min(100, 50 + Math.round((currentPhaseStep / totalPhaseSteps) * 50)); // Second phase is last 50%
        progressBar.style.width = `${progress}%`;
        progressBar.textContent = `${progress}%`;
        
        // Clear canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Seed random for consistent shapes
        SeededRandom.seedWithInteger(currentPhaseStep);
        
        // Run the specific test and measure time
        let startTime = performance.now();
        
        // Draw shapes based on test type
        if (testType === 'lines') {
          drawRandomLinesHTML5(ctx, currentShapeCount);
        } else if (testType === 'rects') {
          drawRandomRectsHTML5(ctx, currentShapeCount);
        } else if (testType === 'circles') {
          drawRandomCirclesHTML5(ctx, currentShapeCount);
        }
        
        let endTime = performance.now();
        let elapsedTime = endTime - startTime;
        
        const avgTime = elapsedTime;
        const stdDev = 0; // No standard deviation with single measurement
        
        // Store results
        testData.canvasShapeCounts.push(currentShapeCount);
        testData.canvasTimings.push(avgTime);
        
        // Log to results
        resultsContainer.innerHTML += `HTML5 Canvas with ${currentShapeCount} shapes: ${avgTime.toFixed(2)}ms\n`;
        // Auto-scroll to show latest results
        resultsContainer.scrollTop = resultsContainer.scrollHeight;
        
        // Check if we exceeded the frame budget
        if (avgTime > FRAME_BUDGET) {
          consecutiveExceedances++;
          resultsContainer.innerHTML += `  Exceeded budget (${consecutiveExceedances}/${requiredExceedances})\n`;
          // Auto-scroll to show exceedance messages
          resultsContainer.scrollTop = resultsContainer.scrollHeight;
          
          // Only stop if we've exceeded enough times consecutively
          if (consecutiveExceedances >= requiredExceedances) {
            exceededBudget = true;
          } else {
            // Continue with the same shape count to confirm if it consistently exceeds budget
            // No need to increment here
          }
        } else {
          // Reset consecutive exceedances counter
          consecutiveExceedances = 0;
          // Increment shape count and continue testing
          currentShapeCount += incrementSize;
        }
        
        // Wait for the next frame before proceeding to next shape count
        animationFrameId = requestAnimationFrame(testNextShapeCount);
      }
      
      // Start with the first shape count
      testNextShapeCount();
    }
    
    // Find the maximum number of shapes that stayed within the frame budget
    function findMaxShapes(shapeCounts, timings) {
      // If we have no data, return 0
      if (shapeCounts.length === 0) {
        return 0;
      }
      
      // Start from the end and find the first shape count before we exceeded budget 10 times in a row
      // This is the last shape count we tested
      let lastShapeCount = shapeCounts[shapeCounts.length - 1];
      
      // If we have shape counts and last entry is the one that exceeded budget,
      // return the last shape count that didn't consistently exceed budget 
      // (which is the last shape count before exceeding budget 10 times)
      return lastShapeCount;
    }
    
    // Drawing functions
    function drawRandomLines(ctx, count) {
      for (let i = 0; i < count; i++) {
        const x1 = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const y1 = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const x2 = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const y2 = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const lineWidth = Math.floor(SeededRandom.getRandom() * 5) + 1;
        const r = Math.floor(SeededRandom.getRandom() * 256);
        const g = Math.floor(SeededRandom.getRandom() * 256);
        const b = Math.floor(SeededRandom.getRandom() * 256);
        const a = 0.3 + SeededRandom.getRandom() * 0.7;
        
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        ctx.strokeLine(x1, y1, x2, y2);
      }
    }
    
    function drawRandomLinesHTML5(ctx, count) {
      for (let i = 0; i < count; i++) {
        const x1 = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const y1 = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const x2 = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const y2 = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const lineWidth = Math.floor(SeededRandom.getRandom() * 5) + 1;
        const r = Math.floor(SeededRandom.getRandom() * 256);
        const g = Math.floor(SeededRandom.getRandom() * 256);
        const b = Math.floor(SeededRandom.getRandom() * 256);
        const a = 0.3 + SeededRandom.getRandom() * 0.7;
        
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
    
    function drawRandomRects(ctx, count) {
      for (let i = 0; i < count; i++) {
        const x = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const y = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const width = Math.floor(SeededRandom.getRandom() * 100) + 20;
        const height = Math.floor(SeededRandom.getRandom() * 100) + 20;
        const hasFill = SeededRandom.getRandom() > 0.3;
        const hasStroke = SeededRandom.getRandom() > 0.3;
        const r = Math.floor(SeededRandom.getRandom() * 256);
        const g = Math.floor(SeededRandom.getRandom() * 256);
        const b = Math.floor(SeededRandom.getRandom() * 256);
        const a = 0.3 + SeededRandom.getRandom() * 0.7;
        const lineWidth = Math.floor(SeededRandom.getRandom() * 5) + 1;
        
        if (hasFill) {
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          ctx.fillRect(x, y, width, height);
        }
        
        if (hasStroke) {
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          ctx.strokeRect(x, y, width, height);
        }
      }
    }
    
    function drawRandomRectsHTML5(ctx, count) {
      for (let i = 0; i < count; i++) {
        const x = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const y = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const width = Math.floor(SeededRandom.getRandom() * 100) + 20;
        const height = Math.floor(SeededRandom.getRandom() * 100) + 20;
        const hasFill = SeededRandom.getRandom() > 0.3;
        const hasStroke = SeededRandom.getRandom() > 0.3;
        const r = Math.floor(SeededRandom.getRandom() * 256);
        const g = Math.floor(SeededRandom.getRandom() * 256);
        const b = Math.floor(SeededRandom.getRandom() * 256);
        const a = 0.3 + SeededRandom.getRandom() * 0.7;
        const lineWidth = Math.floor(SeededRandom.getRandom() * 5) + 1;
        
        if (hasFill) {
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          ctx.fillRect(x, y, width, height);
        }
        
        if (hasStroke) {
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          ctx.strokeRect(x, y, width, height);
        }
      }
    }
    
    // Circle drawing for Software Canvas
    function drawRandomCircles(ctx, count) {
      for (let i = 0; i < count; i++) {
        const centerX = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const centerY = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const radius = Math.floor(SeededRandom.getRandom() * 40) + 10;
        const drawType = SeededRandom.getRandom();
        
        const r = Math.floor(SeededRandom.getRandom() * 256);
        const g = Math.floor(SeededRandom.getRandom() * 256);
        const b = Math.floor(SeededRandom.getRandom() * 256);
        const a = Math.floor((0.3 + SeededRandom.getRandom() * 0.7) * 255);
        const strokeWidth = Math.floor(SeededRandom.getRandom() * 5) + 1;
        
        // 33% fill only, 33% stroke only, 33% both
        if (drawType < 0.33) {
          // Fill only
          ctx.fillCircle(centerX, centerY, radius, r, g, b, a);
        } else if (drawType < 0.66) {
          // Stroke only
          ctx.strokeCircle(centerX, centerY, radius, strokeWidth, r, g, b, a);
        } else {
          // Both fill and stroke
          const sr = Math.floor(SeededRandom.getRandom() * 256);
          const sg = Math.floor(SeededRandom.getRandom() * 256);
          const sb = Math.floor(SeededRandom.getRandom() * 256);
          const sa = Math.floor((0.3 + SeededRandom.getRandom() * 0.7) * 255);
          
          ctx.fillAndStrokeCircle(
            centerX, centerY, radius,
            r, g, b, a,
            strokeWidth,
            sr, sg, sb, sa
          );
        }
      }
    }
    
    // Circle drawing for HTML5 Canvas
    function drawRandomCirclesHTML5(ctx, count) {
      for (let i = 0; i < count; i++) {
        const centerX = Math.floor(SeededRandom.getRandom() * CANVAS_WIDTH);
        const centerY = Math.floor(SeededRandom.getRandom() * CANVAS_HEIGHT);
        const radius = Math.floor(SeededRandom.getRandom() * 40) + 10;
        const drawType = SeededRandom.getRandom();
        
        const r = Math.floor(SeededRandom.getRandom() * 256);
        const g = Math.floor(SeededRandom.getRandom() * 256);
        const b = Math.floor(SeededRandom.getRandom() * 256);
        const a = 0.3 + SeededRandom.getRandom() * 0.7;
        const strokeWidth = Math.floor(SeededRandom.getRandom() * 5) + 1;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        
        // 33% fill only, 33% stroke only, 33% both
        if (drawType < 0.33) {
          // Fill only
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          ctx.fill();
        } else if (drawType < 0.66) {
          // Stroke only
          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        } else {
          // Both fill and stroke
          const sr = Math.floor(SeededRandom.getRandom() * 256);
          const sg = Math.floor(SeededRandom.getRandom() * 256);
          const sb = Math.floor(SeededRandom.getRandom() * 256);
          const sa = 0.3 + SeededRandom.getRandom() * 0.7;
          
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          ctx.fill();
          
          ctx.strokeStyle = `rgba(${sr}, ${sg}, ${sb}, ${sa})`;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        }
      }
    }
    
    // Results display functions
    function displayRampTestResults(testData) {
      // Format results
      let results = "";
      results += `\n=== ${testData.testType.toUpperCase()} TEST RESULTS ===\n`;
      results += `Test Parameters:\n`;
      results += `- Frame budget: ${FRAME_BUDGET}ms (60fps)\n`;
      results += `- SW Canvas increment: ${testData.swIncrement}\n`;
      results += `- HTML5 Canvas increment: ${testData.htmlIncrement}\n`;
      results += `- Consecutive exceedances required: ${testData.requiredExceedances}\n`;
      results += `- Blitting time: ${testData.includeBlitting ? "Included" : "Excluded"}\n\n`;
      
      results += `Software Canvas Performance:\n`;
      results += `- Maximum shapes per frame: ${testData.swMaxShapes}\n\n`;
      
      results += `HTML5 Canvas Performance:\n`;
      results += `- Maximum shapes per frame: ${testData.canvasMaxShapes}\n\n`;
      
      results += `Performance Ratio (HTML5 / Software): ${testData.ratio.toFixed(2)}x\n`;
      results += `HTML5 canvas can render ${testData.ratio.toFixed(2)}x ${testData.ratio > 1 ? "more" : "fewer"} shapes than Software canvas within frame budget.\n\n`;
      
      // Append results to container
      resultsContainer.innerHTML += results;
      resultsContainer.scrollTop = resultsContainer.scrollHeight;
    }
    
    function displayOverallResults(allResults) {
      // Calculate overall statistics
      const avgSwMaxShapes = calculateAverage(allResults.swMaxShapes);
      const avgCanvasMaxShapes = calculateAverage(allResults.canvasMaxShapes);
      const avgRatio = calculateAverage(allResults.ratios);
      
      // Format overall results
      let results = "\n=== OVERALL TEST RESULTS ===\n";
      results += `Tests run: ${allResults.tests.length}\n\n`;
      
      // Test specific summary
      results += "Test Summary:\n";
      for (let i = 0; i < allResults.tests.length; i++) {
        results += `- ${allResults.tests[i].toUpperCase()}: SW Canvas ${allResults.swMaxShapes[i]} shapes, HTML5 Canvas ${allResults.canvasMaxShapes[i]} shapes, Ratio ${allResults.ratios[i].toFixed(2)}x\n`;
      }
      results += "\n";
      
      results += "Average Performance Across All Tests:\n";
      results += `- Software Canvas: ${Math.round(avgSwMaxShapes)} shapes/frame\n`;
      results += `- HTML5 Canvas: ${Math.round(avgCanvasMaxShapes)} shapes/frame\n`;
      results += `- Average Ratio: ${avgRatio.toFixed(2)}x\n`;
      results += `HTML5 canvas can render on average ${avgRatio.toFixed(2)}x ${avgRatio > 1 ? "more" : "fewer"} shapes than Software canvas within frame budget.\n\n`;
      
      // Append results to container
      resultsContainer.innerHTML += results;
      resultsContainer.scrollTop = resultsContainer.scrollHeight;
    }
    
    // Simple chart generation function
    function generatePerformanceChart(testData) {
      // Clear previous chart if any
      chartContainer.innerHTML = '';
      
      // Create canvas for chart
      const chartCanvas = document.createElement('canvas');
      chartCanvas.width = chartContainer.clientWidth - 20;
      chartCanvas.height = chartContainer.clientHeight - 20;
      chartContainer.appendChild(chartCanvas);
      
      const chartCtx = chartCanvas.getContext('2d');
      
      // Chart settings
      const chartPadding = { top: 40, right: 40, bottom: 40, left: 60 };
      const chartWidth = chartCanvas.width - chartPadding.left - chartPadding.right;
      const chartHeight = chartCanvas.height - chartPadding.top - chartPadding.bottom;
      
      // Find max values for scaling
      const maxShapeCount = Math.max(
        ...testData.swShapeCounts,
        ...testData.canvasShapeCounts
      );
      
      const maxTime = Math.max(
        ...testData.swTimings,
        ...testData.canvasTimings,
        FRAME_BUDGET * 1.5 // Ensure frame budget line is visible
      );
      
      // Draw chart background
      chartCtx.fillStyle = '#f8f8f8';
      chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);
      
      // Draw frame budget line
      const budgetY = chartPadding.top + chartHeight - (FRAME_BUDGET / maxTime) * chartHeight;
      
      chartCtx.beginPath();
      chartCtx.moveTo(chartPadding.left, budgetY);
      chartCtx.lineTo(chartPadding.left + chartWidth, budgetY);
      chartCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
      chartCtx.lineWidth = 2;
      chartCtx.setLineDash([5, 5]);
      chartCtx.stroke();
      chartCtx.setLineDash([]);
      
      // Add frame budget label
      chartCtx.fillStyle = 'rgba(255, 0, 0, 0.9)';
      chartCtx.font = '12px Arial';
      chartCtx.textAlign = 'right';
      chartCtx.fillText(`Frame Budget (${FRAME_BUDGET}ms)`, chartPadding.left + chartWidth - 10, budgetY - 5);
      
      // Draw axes
      chartCtx.beginPath();
      chartCtx.moveTo(chartPadding.left, chartPadding.top);
      chartCtx.lineTo(chartPadding.left, chartPadding.top + chartHeight);
      chartCtx.lineTo(chartPadding.left + chartWidth, chartPadding.top + chartHeight);
      chartCtx.strokeStyle = '#333';
      chartCtx.lineWidth = 2;
      chartCtx.stroke();
      
      // Draw axis labels
      chartCtx.fillStyle = '#333';
      chartCtx.font = '14px Arial';
      chartCtx.textAlign = 'center';
      chartCtx.fillText('Number of Shapes', chartPadding.left + chartWidth / 2, chartPadding.top + chartHeight + 30);
      
      chartCtx.save();
      chartCtx.translate(15, chartPadding.top + chartHeight / 2);
      chartCtx.rotate(-Math.PI / 2);
      chartCtx.textAlign = 'center';
      chartCtx.fillText('Render Time (ms)', 0, 0);
      chartCtx.restore();
      
      // Draw title
      chartCtx.font = '16px Arial';
      chartCtx.textAlign = 'center';
      chartCtx.fillText(`${testData.testType.toUpperCase()} Test: Render Time vs. Shape Count`, chartPadding.left + chartWidth / 2, 20);
      
      // Draw Software Canvas data points
      drawChartLine(
        chartCtx,
        testData.swShapeCounts,
        testData.swTimings,
        maxShapeCount,
        maxTime,
        chartPadding,
        chartWidth,
        chartHeight,
        'rgba(0, 0, 255, 0.8)',
        'Software Canvas'
      );
      
      // Draw HTML5 Canvas data points
      drawChartLine(
        chartCtx,
        testData.canvasShapeCounts,
        testData.canvasTimings,
        maxShapeCount,
        maxTime,
        chartPadding,
        chartWidth,
        chartHeight,
        'rgba(0, 128, 0, 0.8)',
        'HTML5 Canvas'
      );
      
      // Draw legend
      const legendY = chartPadding.top + 20;
      
      // Software Canvas legend
      chartCtx.fillStyle = 'rgba(0, 0, 255, 0.8)';
      chartCtx.fillRect(chartPadding.left + 10, legendY, 20, 10);
      chartCtx.fillStyle = '#333';
      chartCtx.textAlign = 'left';
      chartCtx.fillText('Software Canvas', chartPadding.left + 40, legendY + 9);
      
      // HTML5 Canvas legend
      chartCtx.fillStyle = 'rgba(0, 128, 0, 0.8)';
      chartCtx.fillRect(chartPadding.left + 180, legendY, 20, 10);
      chartCtx.fillStyle = '#333';
      chartCtx.fillText('HTML5 Canvas', chartPadding.left + 210, legendY + 9);
    }
    
    function drawChartLine(ctx, xValues, yValues, maxX, maxY, padding, width, height, color, label) {
      if (xValues.length < 2) return;
      
      ctx.beginPath();
      
      for (let i = 0; i < xValues.length; i++) {
        const x = padding.left + (xValues[i] / maxX) * width;
        const y = padding.top + height - (yValues[i] / maxY) * height;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        
        // Draw data point
        ctx.fillStyle = color;
        ctx.fillRect(x - 3, y - 3, 6, 6);
      }
      
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Utility functions
    function calculateAverage(values) {
      if (values.length === 0) return 0;
      return values.reduce((sum, val) => sum + val, 0) / values.length;
    }
    
    function calculateStandardDeviation(values, avg) {
      if (values.length <= 1) return 0;
      const squareDiffs = values.map(value => Math.pow(value - avg, 2));
      const avgSquareDiff = calculateAverage(squareDiffs);
      return Math.sqrt(avgSquareDiff);
    }
  </script>
</body>
</html>